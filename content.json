{"meta":{"title":"alonealice","subtitle":"alonealice","description":"study life","author":"alonealice","url":"https://earthwo.github.io","root":"/"},"pages":[{"title":"Archives","date":"2017-08-02T04:32:20.000Z","updated":"2019-03-11T07:35:22.331Z","comments":true,"path":"archives/index.html","permalink":"https://earthwo.github.io/archives/index.html","excerpt":"","text":""},{"title":"tags","date":"2016-09-18T05:57:02.000Z","updated":"2019-03-11T07:35:22.332Z","comments":true,"path":"tags/index.html","permalink":"https://earthwo.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Android8.0通知栏","slug":"Android8-0通知栏","date":"2018-06-29T03:14:52.000Z","updated":"2019-03-11T07:35:22.314Z","comments":true,"path":"2018/06/29/Android8-0通知栏/","link":"","permalink":"https://earthwo.github.io/2018/06/29/Android8-0通知栏/","excerpt":"","text":"在日常使用Android手机的过程中，我们经常会遇到被各种通知轰炸的情况。大量的通知，极大的降低了使用体验，同时也将真正有用的信息淹没。虽然手机可以屏蔽这些通知，但是一旦屏蔽，应用里重要的通知也无法再提示，让人进退两难。 面对这种情况，google在Android8.0系统中开始对其进行改进优化。 在Android8.0中，google引入了通知渠道的概念。每个应用都可以创建自己的通知渠道，发送通知时，通知也需要指定相应的渠道。这些通知渠道有用户控制，用户可以对不同的渠道设置不同的重要级，也可以对不同的渠道进行开启和关闭，这样就可以将部分不重要的通知进行屏蔽。 渠道创建要想使用最新的通知渠道，首先需要将项目的targetSdkVersion大于26，当然，如果你想直接兼容之前版本避免渠道的使用，也可以通过修改targetSdkVersion小于25实现。 private val channel1=&quot;default&quot;private val channel2=&quot;high&quot;fun createChannel(v: View)&#123; createChannel(channel1,&quot;默认通道&quot;,NotificationManager.IMPORTANCE_DEFAULT) createChannel(channel2,&quot;高级通道&quot;,NotificationManager.IMPORTANCE_HIGH)&#125;private fun createChannel(channelId: String,channelName: String,important: Int)&#123; val channel=NotificationChannel(channelId,channelName,important) val notificationManager=getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager notificationManager.createNotificationChannel(channel)&#125; 创建渠道的方式也很简单，指定渠道的id、名字和重要性即可。渠道创建之后会一直存在，并且重复创建时也不会出现重复渠道，直到渠道删除。 val notificationManager=getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManagernotificationManager.deleteNotificationChannel(channel1)notificationManager.deleteNotificationChannel(channel2) 渠道创建之后无法修改，用户可以在应用的设置中修改通知，用户一旦修改渠道的重要性后，程序无法再次对其修改，即使删除渠道再创建也不行，除非创建不同id的渠道。 渠道重要性渠道的重要性主要是6级，IMPORTANCE_DEFAULT，IMPORTANCE_HIGH，IMPORTANCE_LOW，IMPORTANCE_MAX， IMPORTANCE_MIN ，IMPORTANCE_NONE。但是实际上的重要性是四级。 因此实际上，IMPORTANCE_HIGH和IMPORTANCE_MAX对应紧急的重要性，IMPORTANCE_DEFAULT对应高的重要性，IMPORTANCE_LOW对应中，而IMPORTANCE_NONE和IMPORTANCE_MIN对应低； 重要性一旦被用户手动修改后，程序无法再调整其重要性，除非创建不同的渠道，同时在设置中会显示程序删除的通道数量。 这些重要性分别是怎样的效果呢？ 低：程序不会有任何视觉和声音的提示，除非用户将整个通知栏滑开才能看到； 中：程序不会有声音提示，但是会在通知栏上显示图标； 高：程序会有声音提示，并且会在通知栏上提示图标； 紧急：程序会提示声音，并且会直接弹出窗口提示用户； 发送渠道通知发送通知时需要将通知指定相应的渠道： val manager = getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManagerval notification = NotificationCompat.Builder(this, channel1)//指定渠道 .setContentTitle(&quot;消息标题&quot;) .setContentText(&quot;消息内容？&quot;) .setWhen(System.currentTimeMillis()) .setSmallIcon(R.drawable.ic_launcher_background) .setLargeIcon(BitmapFactory.decodeResource(resources, R.drawable.ic_launcher_background)) .setAutoCancel(true) .build()manager.notify(1, notification) 用户可以通过优化，对通知设置静默时间，那么在该时间段内，该渠道的通知就都会被屏蔽。 设置数字Android8.0可以直接在发送通知时设置图标数字 val notification = NotificationCompat.Builder(this, channel1) ... .setNumber(10) .build() 不过具体到实际的设备中时，很多的设备可以设置是否显示图标数字。","categories":[{"name":"Android8.0","slug":"Android8-0","permalink":"https://earthwo.github.io/categories/Android8-0/"}],"tags":[{"name":"Android8.0","slug":"Android8-0","permalink":"https://earthwo.github.io/tags/Android8-0/"}]},{"title":"nio学习笔记(三)","slug":"nio学习笔记-三","date":"2018-02-05T06:31:04.000Z","updated":"2019-03-11T07:35:22.327Z","comments":true,"path":"2018/02/05/nio学习笔记-三/","link":"","permalink":"https://earthwo.github.io/2018/02/05/nio学习笔记-三/","excerpt":"","text":"FileChannelFileChannel是一个文件的通道，可以通过它来读写文件。FileChannel无法设置为非阻塞模式。 读数据：RandomAccessFile accessFile = new RandomAccessFile(filePath, &quot;rw&quot;);FileChannel fileChannel = accessFile.getChannel();ByteBuffer buffer = ByteBuffer.allocate(48);int bytesRead = inChannel.read(buffer); 读数据时，使用read方法返回读取的数据大小，如果返回-1，就说明已经到了文件的最后。 写数据：String text = &quot;...&quot;;ByteBuffer buf = ByteBuffer.allocate(48);buf.clear();buf.put(text.getBytes());buf.flip();while(buf.hasRemaining()) &#123; fileChannel.write(buf);&#125; write方法在写入数据时，每次写入的量是不定的，所以需要在循环体中把所有的数据写入文件。 使用完FileChannel之后，需要把通道关闭。 fileChannel.close(); 其他方法position(long pos)：该方法可以获取通道的当前位置，同时也可以设置在特定的位置进行读写操作。 long pos = channel.position();channel.position(pos +10); 这样操作会是数据之间存在空数据。 size：size()方法将返回该通道里数据的大小。 truncate()：该方法可以截取指定的数据长度，这样就可以达到截取文件的目的。 force()：该方法将通道里尚未写入磁盘的数据强制写到磁盘上。 SocketChannelSocketChannel是一个连接到TCP网络套接字的通道，一般会使用两个地方使用到它：使用SocketChannel连接到互联网上的某台服务器，或者使用ServerSocketChannel时，当有新的连接时，会自动创建SocketChannel。 读写数据SocketChannel socketChannel = SocketChannel.open();socketChannel.connect(new InetSocketAddress(ip, 80));//读取数据ByteBuffer buf = ByteBuffer.allocate(48);int bytesRead = socketChannel.read(buf);//写入数据ByteBuffer buf = ByteBuffer.allocate(48);buf.clear();buf.put(text.getBytes());buf.flip();while(buf.hasRemaining()) &#123; channel.write(buf);&#125;socketChannel.close(); 非阻塞模式当设置成非阻塞模式后，就可以在异步模式下调用connect()，read() 和write()了。 socketChannel.configureBlocking(false);socketChannel.connect(new InetSocketAddress(ip, 80));while(! socketChannel.finishConnect() )&#123; ...&#125;socketChannel.close(); ServerSocketChannel ServerSocketChannel 是一个可以监听新进来的TCP连接的通道，主要用于在服务器中监听连接。 ServerSocketChannel serverSocketChannel = ServerSocketChannel.open(); //打来通道serverSocketChannel.socket().bind(new InetSocketAddress(90)); //绑定端口while(true)&#123; SocketChannel socketChannel = //获取连接 serverSocketChannel.accept(); ...&#125;...serverSocketChannel.close(); //关闭 非阻塞模式ServerSocketChannel同样可以设置为非阻塞模式。此时，accept() 方法会立刻返回，如果还没有新进来的连接,返回的将是null。 ServerSocketChannel serverSocketChannel = ServerSocketChannel.open(); //打来通道serverSocketChannel.socket().bind(new InetSocketAddress(90)); //绑定端口while(true)&#123; SocketChannel socketChannel = //获取连接 serverSocketChannel.accept(); if(socketChannel!=null)&#123; ... &#125;&#125;...serverSocketChannel.close(); //关闭 DatagramChannelDatagramChannel是收发UDP包的通道，因此它发送和结束的是数据包。 接收发送数据： DatagramChannel channel = DatagramChannel.open(); //打开channel.socket().bind(new InetSocketAddress(100)); //绑定接口//接收数据ByteBuffer buf = ByteBuffer.allocate(48);buf.clear();channel.receive(buf); //发送数据ByteBuffer buf = ByteBuffer.allocate(48);buf.clear();buf.put(text.getBytes());buf.flip();int bytesSent = channel.send(buf, new InetSocketAddress(ip, 100)); Pipe管道是2个线程之间的单向数据连接。Pipe有一个source通道和一个sink通道。数据会被写到sink通道，从source通道读取。 读写数据： Pipe pipe = Pipe.open(); //打开通道Pipe.SinkChannel sinkChannel = pipe.sink();String newData = &quot;...&quot;;ByteBuffer buf = ByteBuffer.allocate(48);buf.clear();buf.put(newData.getBytes());buf.flip();//写入数据while(buf.hasRemaining()) &#123; sinkChannel.write(buf);&#125;//读取数据Pipe.SourceChannel sourceChannel = pipe.source();ByteBuffer buf = ByteBuffer.allocate(48);int bytesRead = sourceChannel.read(buf);","categories":[{"name":"nio","slug":"nio","permalink":"https://earthwo.github.io/categories/nio/"}],"tags":[{"name":"nio","slug":"nio","permalink":"https://earthwo.github.io/tags/nio/"}]},{"title":"nio学习笔记(二)","slug":"nio学习笔记-二","date":"2018-02-02T01:38:27.000Z","updated":"2019-03-11T07:35:22.327Z","comments":true,"path":"2018/02/02/nio学习笔记-二/","link":"","permalink":"https://earthwo.github.io/2018/02/02/nio学习笔记-二/","excerpt":"","text":"RandomAccessFileRandomAccessFile允许你来回读写文件，也可以替换文件中的某些部分。 读写文件//打开文件RandomAccessFile file = new RandomAccessFile(filePath, &quot;rw&quot;);//读取文件int aByte = file.read();//写入文件file.write(testBytes);//关闭file.close(); 来回读写在RandomAccessFile的某个位置读写之前，必须把文件指针指向该位置。通过seek()方法可以达到这一目标。可以通过调用getFilePointer()获得当前文件指针的位置 RandomAccessFile file = new RandomAccessFile(filePath, &quot;rw&quot;);file.seek(200);long pointer = file.getFilePointer();file.close(); 分散和聚集分散（scatter）是指从通道中读取的数据写入到多个buffer中；聚集是指将多个buffer中的数据写入同一个通道中。 ByteBuffer header = ByteBuffer.allocate(128);ByteBuffer body = ByteBuffer.allocate(1024);ByteBuffer[] bufferArray = &#123; header, body &#125;;channel.read(bufferArray);//channel.write(bufferArray); 从channel中读取数据时，会按顺序先写满一个buffer后，在写到后面的buffer中，因此这种情况不适合数据长度不定的情况。写数据时，也会按buffer顺序依次把数据写入到channel中。 通道数据传输两个通道中有一个是FileChannel，就可以直接将数据从一个通道传输到另外一个通道。 Channel的transferFrom()方法可以将数据从源通道传输到FileChannel中 RandomAccessFile fromFile = new RandomAccessFile(fileFrom, &quot;rw&quot;);FileChannel fromChannel = fromFile.getChannel();RandomAccessFile toFile = new RandomAccessFile(fileTo, &quot;rw&quot;);FileChannel toChannel = toFile.getChannel();long position = 0;long count = fromChannel.size();toChannel.transferFrom(position, count, fromChannel); 如果fromchannel是socketchannels时，传输时只会将已经有的数据进行传输。 transferTo()方法将数据从FileChannel传输到其他的channel中。 ...fromChannel.transferTo(position, count, toChannel);","categories":[{"name":"nio","slug":"nio","permalink":"https://earthwo.github.io/categories/nio/"}],"tags":[{"name":"nio","slug":"nio","permalink":"https://earthwo.github.io/tags/nio/"}]},{"title":"nio学习笔记","slug":"nio概念","date":"2018-02-01T06:13:04.000Z","updated":"2019-03-11T07:35:22.328Z","comments":true,"path":"2018/02/01/nio概念/","link":"","permalink":"https://earthwo.github.io/2018/02/01/nio概念/","excerpt":"","text":"在学习nio之前，首先要弄清楚什么是nio，以及它与平时使用的io的区别。 NIO（Non-blocking I/O，在Java领域，也称为New I/O），是一种同步非阻塞的I/O模型，也是I/O多路复用的基础。它已经被越来越多地应用到了大型应用服务器中，是一种解决高并发与大量连接、I/O处理问题的有效方式。 我们都知道，IO是面向流的， 这面向流意味着每次可以从流中读一个或多个字节，直至读取所有字节，它们没有被缓存在任何地方。此外，它不能前后移动流中的数据。如果需要前后移动从流中读取的数据，需要先将它缓存到一个缓冲区。 同时IO也是阻塞的。当一个线程调用read() 或 write()时，该线程是会被阻塞的，直到有一些数据被读取，或数据完全写入。该线程在此期间不能再干任何事情了，但是cpu却是空闲的。 而NIO是面向缓冲区的，读取数据读时会将数据放到一个缓冲区，需要时可在缓冲区中前后移动。同时，它还会检查是否该缓冲区中包含所有您需要处理的数据。当读入更多的数据到缓冲区时，要保证不会覆盖缓冲区里尚未处理的数据。 在nio中有几个重要的概念，通道，缓冲区和选择器。 通道java中的通道类似流，我们既可以冲通道中读取数据，又可以将数据写到通道，但是流的读取写入都是单向的。同时，通道可以异步读写，读写数据时总是先读到一个缓冲区，或者将数据写入一个缓冲区。 nio中重要的通道有：FileChannel从文件中读写数据、DatagramChannel能通过UDP读写网络中的数据、SocketChannel能通过TCP读写网络中的数据、ServerSocketChannel可以监听新进来的TCP连接，像Web服务器那样。对每一个新进来的连接都会创建一个SocketChannel。 RandomAccessFile aFile = new RandomAccessFile(filePath, &quot;rw&quot;);FileChannel inChannel = aFile.getChannel(); 缓存区Buffer用于和NIO通道进行交互，本质上是一块可以写入数据和读取数据的内存。这块内存被包装成NIO Buffer对象后，提供了一组方法，用来方便的访问该块内存。 它有3个重要的属性： capacity：Buffer有一个固定的大小值capacity。当往里面存储数据时满时，需要通过读取和清除等方式将数据清除才能往里面继续存储数据。 position：position表示当前的位置。初始的position值为0.当写入一个数据时， position会向前移动到下一个可插入数据的Buffer单元。position最大可为capacity – 1。当读取数据时，也是从某个特定位置读。当将Buffer从写模式切换到读模式，position会被重置为0. 当从Buffer的position处读取数据时，position向前移动到下一个可读的位置。 limit：在写模式下，Buffer的limit表示你最多能往Buffer里写多少数据。 写模式下，limit等于Buffer的capacity。当切换Buffer到读模式时， limit表示你最多能读到多少数据。因此，当切换Buffer到读模式时，limit会被设置成写模式下的position值。换句话说，你能读到之前写入的所有数据。 Buffer的类型Java NIO 有以下Buffer类型：ByteBuffer、MappedByteBuffer、CharBuffer、DoubleBuffer、FloatBuffer、IntBuffer、LongBuffer、ShortBuffer。 Buffer的使用buffer读写数据时首先需要分配一块内存大小， 每一个Buffer类都有一个allocate方法，大小值就是capacity值。 ByteBuffer buf = ByteBuffer.allocate(48); 之后需要将数据写入到buffer中： int bytesRead = inChannel.read(buf); 写入之后需要将buffer的模式有写换到读，然后读取数据： buf.flip(); //将buffer切换到读模式while(buf.hasRemaining())&#123; System.out.print((char) buf.get()); //逐个读取数据&#125; 选择器Selector允许单线程处理多个 通道。当单线程中需要处理多个连接时，且连接数量较多时，适合这种情况。当用单个线程来处理多个通道时，只需要更少的线程来处理，甚至可以只用一个线程来处理所有的通道。对于操作系统来说，线程之间上下文切换的开销很大，而且每个线程都要占用系统的一些资源。因此，使用的线程越少越好。 注册通道和使用通道和选择器配合使用，必须要将通道注册到选择器上。 Selector selector = Selector.open();//开启选择器channel.configureBlocking(false);SelectionKey key = channel.register(selector,Selectionkey.OP_READ); 这里有几个点需要注意一下，首先是与选择器一起使用的通道必须是非阻塞模式的，因此FileChannel不能与selector一起使用，因为FileChannel不能切换到非阻塞模式；第二是在注册时需要传入注册监听的事件的类型，可以监听一下事件：connect、Accept、Read和write，使用时既可以使用其中的一种，也可以多种。如： SelectionKey.OP_READ | SelectionKey.OP_WRITE 注册完通道后，就可以调用elect()方法，返回已经准备好的通道。 select()阻塞到至少有一个通道在你注册的事件上就绪了。 select(long timeout)和select()一样，除了最长会阻塞timeout毫秒(参数)。 selectNow()不阻塞，只要有通道准备好就立刻返回，如果没有就返回0。 select()方法返回准备好的新通道数量，就是说如果是返回上次调用select方法之后的准备好的通道。调用了select()方法之后，如果有一个或更多个通道就绪了，然后可以通过调用selector的selectedKeys()方法，获取已经准备好的通道集合。 Set selectedKeys = selector.selectedKeys(); 然后可以遍历通道集合，根据通道不同的状态做相应的处理。在处理完之后，需要调用iterator.remove()，因为selector不会自己从已选择键集中移除SelectionKey实例。必须在处理完通道时自己移除。下次该通道变成就绪时，Selector会再次将其放入已选择键集中。 Selector selector = Selector.open();channel.configureBlocking(false);SelectionKey key = channel.register(selector, SelectionKey.OP_READ);while(true) &#123; int readyChannels = selector.select(); if(readyChannels == 0) continue; Set selectedKeys = selector.selectedKeys(); Iterator keyIterator = selectedKeys.iterator(); while(keyIterator.hasNext()) &#123; SelectionKey key = keyIterator.next(); if(key.isAcceptable()) &#123; // a connection was accepted by a ServerSocketChannel. &#125; else if (key.isConnectable()) &#123; // a connection was established with a remote server. &#125; else if (key.isReadable()) &#123; // a channel is ready for reading &#125; else if (key.isWritable()) &#123; // a channel is ready for writing &#125; keyIterator.remove(); &#125;&#125;","categories":[{"name":"nio","slug":"nio","permalink":"https://earthwo.github.io/categories/nio/"}],"tags":[{"name":"nio","slug":"nio","permalink":"https://earthwo.github.io/tags/nio/"}]},{"title":"android WebView优化","slug":"android-WebView优化分析","date":"2017-12-19T09:47:34.000Z","updated":"2019-03-11T07:35:22.323Z","comments":true,"path":"2017/12/19/android-WebView优化分析/","link":"","permalink":"https://earthwo.github.io/2017/12/19/android-WebView优化分析/","excerpt":"","text":"在android使用WebView去显示页面时，有一个很严重的问题就是慢。这个慢会导致页面白屏时间或者等待时间过长，严重影响用户体验。 在WebView加载页面的过程中，主要有这么几个步骤：WebView初始化，建立连接，获取数据，页面框架渲染，JS加载、解析。那么我们依次来看看这些环节有哪些可以优化的地方可以加快WebView的页面显示。 WebView初始化App中打开WebView的第一步并不是建立连接，而是启动浏览器内核，而app中与普通浏览器中不同，当我们打开浏览器时，系统会先初始化浏览器内核，完成后，用户再输入链接。而在app中，这两部操作是连在一起的。这就导致连接网络过程时间看起来会更长，因为这当中还有WebView初始化的时间。 那怎样优化呢？目前主要有两种方案：全部WebView和代理数据请求。 使用全局WebView时，我们需要在程序启动时就初始化一个WebView，在使用时就可以直接使用该WebView，这样可以直接减少第一次初始化的时间。 但是这样做也会有问题。首先是内存：在未使用WebView时就已经预先有个WebView准备在那里了，而我们都知道，Webview本身是很耗内存的，这样就照成了内存的浪费；其次，当多个页面都需要使用WebView时，我们需要在页面跳转时清空上一个页面的痕迹，这很容易照成内存泄漏。 连接连接部分能够优化的主要是在DNS，这部分时间很容易被人忽略。当我们请求链接时，我们首先会去DNS服务器上获取正确的ip。但是DNS会在系统级别进行缓存，对于WebView的地址，如果使用的域名与native的API相同，则可以直接使用缓存的DNS而不用再发起请求。 因此，WebView请求的地址最好与app中请求的域名统一，同理也使用在HTML页面中的各种资源的地址。 获取数据获取数据时，如果采用普通方式输出页面，则页面会在服务器请求完所有API并处理完成后开始传输。浏览器要在后端所有API都加载完成后才能开始解析。这时就可以考虑采用chunk编码，将数据放在最后，并优先将静态内容输出。 在HTTP协议中，我们可以在header中设置 transfer-encoding:chunked 使得页面可以分块输出。如果合理设计页面，让head部分都是确定的静态资源版本相关内容，而body部分是业务数据相关内容，那么我们可以在用户请求的时候，首先将Web API可以确定的部分先输出给浏览器，然后等API完全获取后，再将API数据传输给浏览器。 这样虽然在后端时间上并没有区别，但是可以提升首字节速度，从而让前端加载资源和后端加载API不互相阻塞。 页面框架渲染一般来说HTML在开始接收到返回数据的时候就开始解析HTML并构建DOM树。如果没有JS阻塞的话一般会相继完成。当中遇到CSS时，并不会停止解析，而是会继续往下解析，而遇到内联的JS时，一般也能很快执行完。但是，当两者同时出现时，就会出现问题。 当CSS后面有JS，则会阻塞JS的执行，直到CSS加载完成（即便JS是内联的脚本），从而间接阻塞HTML的解析。 因此在优化时，CSS的加载会在HTML解析到CSS的标签时开始，所以CSS的标签要尽量靠前，但是，CSS链接下面不能有任何的JS标签（包括很简单的内联JS），否则会阻塞HTML的解析，如果必须要在头部增加内联脚本，一定要放在CSS标签之前。 JS加载、解析JS框架的初始化，数据的请求，逻辑的处理都是需要消耗资源和时间的，这种情况在低端手机上尤其明显。所以在app中使用的框架，要尽可能的轻量。而JS代码的编译和执行中往往会有缓存，同App中网页尽量统一框架。 参考本文参考WebView性能、体验分析与优化，当中还有更加详细的分析和数据。","categories":[{"name":"WebView","slug":"WebView","permalink":"https://earthwo.github.io/categories/WebView/"}],"tags":[{"name":"WebView","slug":"WebView","permalink":"https://earthwo.github.io/tags/WebView/"}]},{"title":"WebView缓存简述","slug":"WebView缓存原理","date":"2017-12-19T09:46:34.000Z","updated":"2019-03-11T07:35:22.322Z","comments":true,"path":"2017/12/19/WebView缓存原理/","link":"","permalink":"https://earthwo.github.io/2017/12/19/WebView缓存原理/","excerpt":"","text":"WebView缓存在日常的使用中非常重要，它不仅能使用户能够在离线的情况下依旧可以使用它，更重要的是，它可以加快网页的加载速度，减少服务器的负载。 WebView主要包括两类缓存，一类是浏览器自带的网页数据缓存，这是所有的浏览器都支持的、由HTTP协议定义的缓存；另一类是H5缓存，这是由web页面的开发者设置的。 浏览器自带的网页数据缓存浏览器缓存机制是通过HTTP协议Header里的Cache-Control（或Expires）和Last-Modified（或 Etag）等字段来控制文件缓存的机制。下面具体来讲讲这几个字段的意义： Cache-Control:max-age=60，这表示缓存时长为60秒。如果60秒内需要再次请求这个文件，那么浏览器不会发出请求，直接使用本地的缓存的文件。这是HTTP/1.1标准中的字段。 Expires: Thu, 31 Dec 2017 23:55:55 GMT，这表示这个文件的过期时间是2017年12月31日晚上23点55分55秒，在这个时间之前浏览器都不会再次发出请求去获取这个文件。这是HTTP/1.0中的字段，如果客户端和服务器时间不同步会导致缓存出现问题。 当它们同时出现在HTTP Response的Header中时，Cache-Control优先级更高。 Last-Modified:Wed, 28 Sep 2016 09:24:35 GMT，这表示这个文件最后的修改时间是2016年9月28日9点24分35秒。这个字段对于浏览器来说，会在下次请求的时候，作为Request Header的If-Modified-Since字段带上。例如浏览器缓存的文件已经超过了Cache-Control（或者Expires），那么需要加载这个文件时，就会发出请求，请求的Header有一个字段为If-Modified-Since：Wed, 28 Sep 2016 09:24:35 GMT，服务器接收到请求后，会把文件的Last-Modified时间和这个时间对比，如果时间没变，那么浏览器将返回304 Not Modified给浏览器，让浏览器继续使用缓存。如果时间有变化，那么服务器会返回200 OK，并返回相应的内容给浏览器。 ETag:”57eb8c5c-129”，这是文件的特征串。功能同上面的Last-Modified是一样的。只是在浏览器下次请求时，ETag是作为Request Header中的If-None-Match:&quot;57eb8c5c-129&quot;字段传到服务器。服务器和最新的文件特征串对比，如果相同那么返回304 Not Modified，不同则返回200 OK。当ETag和Last-Modified同时出现时，任何一个字段只要生效了，就认为文件是没有更新的。 WebView要支持这些属性，需要对WebSetting做相应的设置。 WebSettings settings = webView.getSettings();settings.setCacheMode(WebSettings.LOAD_DEFAULT); WebView总共有下面几个Cache Mode： LOAD_CACHE_ONLY: 不使用网络，只读取本地缓存数据。 LOAD_DEFAULT: 根据cache-control决定是否从网络上取数据。 LOAD_CACHE_NORMAL: API level 17中已经废弃，从API level 11开始作用同LOAD_DEFAULT模式 LOAD_NO_CACHE: 不使用缓存，只从网络获取数据。 LOAD_CACHE_ELSE_NETWORK，只要本地有，无论是否过期，或者no-cache，都使用缓存中的数据。本地没有缓存时才从网络上获取。 H5的缓存到目前为止，H5 一共有6种缓存机制，有些是之前已有，有些是 H5 才新加入的。浏览器缓存机制：Dom Storgage（Web Storage）存储机制，Web SQL Database 存储机制，Application Cache（AppCache）机制，Indexed Database （IndexedDB），File System API。 下面我们就依次来讲讲这些缓存机制以及WebView要支持这些机制时需要做哪些。 Dom Storage 存储机制DOM 存储是一套在 Web Applications 1.0 规范中首次引入的与存储相关的特性的总称，现在已经分离出来，单独发展成为独立的 W3C Web 存储规范。 DOM 存储被设计为用来提供一个更大存储量、更安全、更便捷的存储方法，从而可以代替掉将一些不需要让服务器知道的信息存储到 cookies 里的这种传统方法。 Dom Storage 是通过存储字符串的 Key/Value 对来提供的，并提供 5MB（不同浏览器可能不同，分 HOST)的存储空间。 DOM Storage 分为 sessionStorage 和 localStorage。localStorage 对象和 sessionStorage 对象使用方法基本相同，它们的区别在于作用的范围不同。sessionStorage 用来存储与页面相关的数据，它在页面关闭后无法使用。而 localStorage 则持久存在，在页面关闭后也可以使用。 localStorage 是个全局对象，它维护着在页面会话(page session)期间有效的存储空间。只要浏览器开着，页面会话周期就会一直持续。当页面重新载入(reload)或者被恢复(restores)时，页面会话也是一直存在的。每在新标签或者新窗口中打开一个新页面，都会初始化一个新的会话。 LocalStorage 是全局性的，同时打开两个页面会共享一份存数据，在一个页面中修改数据，另一个页面中是可以感知到的。 总体上来说，Dom Storage 给 Web 提供了一种更录活的数据存储方式，存储空间更大（相对 Cookies)，用法也比较简单，方便存储服务器或本地的一些临时数据，但是它只适合存储比较简单的数据，如果要存储对象，需要将其转为json数据。 WebView中如果需要使用Dom Storage，那么就需要在WebSetting中将其的开关打开。 webView.getSettings().setDomStorageEnabled(true); Web SQL Database存储机制Web SQL Database是H5 提供的基于 SQL 的数据库存储机制，用于存储适合数据库的结构化数据。根据官方的标准文档，Web SQL Database 存储机制不再推荐使用，将来也不再维护，而是推荐使用 AppCache 和 IndexedDB。 SQL Database 的主要优势在于能够存储结构复杂的数据，能充分利用数据库的优势，可方便对数据进行增加、删除、修改、查询。由于 SQL 语法的复杂性，使用起来麻烦一些。SQL Database 也不太适合做静态文件的缓存。 在 Android 内嵌 Webview 中，需要通过 Webview 设置接口启用 SQL Database，同时还要设置数据库文件的存储路径。 webView.getSettings().setDatabaseEnabled(true);webView.getSettings().setDatabasePath(path); Application Cache 机制Application Cache（简称 AppCache类似于浏览器的缓存（Cache-Control 和 Last-Modified）机制，都是以文件为单位进行缓存，且文件有一定更新机制。但 AppCache 是对浏览器缓存机制的补充，不是替代。 要使用 AppCache，需要在HTML 在头中通过 manifest 属性引用 manifest 文件。在manifest 文件中列出了缓存文件CACHE MANIFEST，网络文件NETWORK以及错误文件FALLBACK。 总的来说，浏览器在首次加载 HTML 文件时，会解析 manifest 属性，并读取 manifest 文件，获取 Section：CACHE MANIFEST 下要缓存的文件列表，再对文件缓存。 在使用AppCache也会有一些问题： 1.要更新缓存的文件，需要更新包含它的 manifest 文件，那怕只加一个空格。常用的方法，是修改 manifest 文件注释中的版本号。如：# 2012-02-21 v1.0.02.被缓存的文件，浏览器是先使用，再通过检查 manifest 文件是否有更新来更新缓存文件。这样缓存文件可能用的不是最新的版本。3.在更新缓存过程中，如果有一个文件更新失败，则整个更新会失败。4.manifest 和引用它的HTML要在相同 HOST。5.manifest 文件中的文件列表，如果是相对路径，则是相对 manifest 文件的相对路径。6.manifest 也有可能更新出错，导致缓存文件更新失败。7.没有缓存的资源在已经缓存的 HTML 中不能加载，即使有网络。8.manifest 文件本身不能被缓存，且 manifest 文件的更新使用的是浏览器缓存机制。所以 manifest 文件的 Cache-Control 缓存时间不能设置太长。 另外，根据官方文档，AppCache 已经不推荐使用了，Webview要使用AppCache，需要设置接口启用 AppCache，同时还要设置缓存文件的存储路径，另外还可以设置缓存的空间大小。 webSettings.setAppCacheEnabled(true);webSettings.setAppCachePath(cachePath); webSettings.setAppCacheMaxSize(5*1024*1024); Indexed DatabaseIndexedDB 也是一种数据库的存储机制，但不同于已经不再支持的 Web SQL Database。IndexedDB 不是传统的关系数据库，可归为 NoSQL 数据库。IndexedDB 又类似于 Dom Storage 的 key-value 的存储方式，但功能更强大，且存储空间更大。 IndexedDB 存储数据是 key-value 的形式。Key 是必需，且要唯一；Key 可以自己定义，也可由系统自动生成。Value 也是必需的，但 Value 非常灵活，可以是任何类型的对象。一般 Value 都是通过 Key 来存取的。 Android 在4.4开始加入对 IndexedDB 的支持，只需打开允许 JS 执行的开关就好了。 webSettings.setJavaScriptEnabled(true); File System APIFile System API 是 H5 新加入的存储机制。它为 Web App 提供了一个虚拟的文件系统，就像 Native App 访问本地文件系统一样。由于安全性的考虑，这个虚拟文件系统有一定的限制。Web App 在虚拟的文件系统中，可以进行文件（夹）的创建、读、写、删除、遍历等操作。File System API 也是一种可选的缓存机制，和前面的 SQLDatabase、IndexedDB 和 AppCache 等一样。File System API 有自己的一些特定的优势：1.可以满足大块的二进制数据（ large binary blobs）存储需求;2.可以通过预加载资源文件来提高性能;3.可以直接编辑文件。 到目前，Android 系统的 Webview 还不支持 File System API。 参考资料WebView缓存原理分析和应用 H5 缓存机制浅析 移动端 Web 加载性能优化","categories":[{"name":"WebView","slug":"WebView","permalink":"https://earthwo.github.io/categories/WebView/"}],"tags":[{"name":"WebView","slug":"WebView","permalink":"https://earthwo.github.io/tags/WebView/"}]},{"title":"WebView与Js交互","slug":"WebView与Js交互","date":"2017-12-19T09:43:03.000Z","updated":"2019-03-11T07:35:22.322Z","comments":true,"path":"2017/12/19/WebView与Js交互/","link":"","permalink":"https://earthwo.github.io/2017/12/19/WebView与Js交互/","excerpt":"","text":"在日常开发中我们经常会使用WebView，尤其是那些动态化要求很高的页面。而在使用WebView的过程中，又会有很多的问题。比如说WebView加载慢，内存消耗大以及和原生代码交互的问题。这篇文章就来简单讲讲WebView与Native交互的问题。 Native于 JavaScript 交互java Native代码与 JavaScript 交互主要有3中方法： 1.使用系统方法 addJavascriptInterface 注入 java 对象来实现 //开启Js可用mWebView.getSettings().setJavaScriptEnabled(true);// 创建要注入的 Java 类public class NativeInterface &#123; @JavascriptInterface public void showToast() &#123; Toast.makeText(mContext, &quot;hello&quot;, Toast.LENGTH_SHORT).show(); &#125;&#125;// WebView 注入即可mWebView.addJavascriptInterface(new NativeInterface(this), &quot;AndroidNative&quot;); 利用 WebViewClient 中 shouldOverrideUrlLoading 利用WebViewClient的中的shouldOverrideUrlLoading接口，拦截网页中的链接请求，通过对共同约定的url的解析，解析出需要的数据进行处理。在页面上，使用iframe来调用native代码，实现互通。 WebViewClient mWebViewClient=new WebViewClient()&#123; @Override public boolean shouldOverrideUrlLoading(WebView view, String url) &#123; Toast.makeText(content,url,Toast.LENGTH_SHORT).show(); return false; &#125; &#125;; 利用 WebChromeClient 中的 onJsAlert、onJsConfirm、onJsPrompt 接口 利用WebChromeClient 中的 onJsAlert、onJsConfirm、onJsPrompt 接口，通过拦截页面上的弹框来实现与native层的数据交互。一般情况下，会使用onJsPrompt方法，因为该方法使用的情况最少，对其他业务的影响也最小。 WebChromeClient mWebChromeClient=new WebChromeClient()&#123; @Override public boolean onJsAlert(WebView view, String url, String message, JsResult result) &#123; return super.onJsAlert(view, url, message, result); &#125; @Override public boolean onJsConfirm(WebView view, String url, String message, JsResult result) &#123; return super.onJsConfirm(view, url, message, result); &#125; @Override public boolean onJsPrompt(WebView view, String url, String message, String defaultValue, JsPromptResult result) &#123; return super.onJsPrompt(view, url, message, defaultValue, result); &#125; &#125;; Js 注入漏洞通过注入方式来实现 WebView 和 JS 交互会带来相应的安全问题。在早期的android版本中，native可被调用的方法不需要添加@JavascriptInterface即可被调用，这就导致代码会被远程调用。 已知漏洞： 1、CVE-2012-6636，揭露了 WebView 中 addJavascriptInterface 接口会引起远程代码执行漏洞；2、CVE-2013-4710，针对某些特定机型会存在 addJavascriptInterface API 引起的远程代码执行漏洞；3、CVE-2014-1939 爆出 WebView 中内置导出的 “searchBoxJavaBridge_” Java Object 可能被利用，实现远程任意代码；4、CVE-2014-7224，类似于 CVE-2014-1939 ，WebView 内置导出 “accessibility” 和 “accessibilityTraversal” 两个 Java Object 接口，可被利用实现远程任意代码执行。 解决方法： 1、Android 4.2 以下不要在使用 JavascriptInterface方式，4.2 以上需要添加注解 @JavascriptInterface 才能调用。 2、在创建 WebView 时，使用 removeJavascriptInterface 方法将系统注入的 searchBoxJavaBridge_ 对象删除。 3、当系统辅助功能服务被开启时，在 Android 4.4 以下的系统中，由系统提供的 WebView 组件都默认导出 ”accessibility” 和 ”accessibilityTraversal” 这两个接口，这两个接口同样存在远程任意代码执行的威胁，同样的需要通过 removeJavascriptInterface 方法将这两个对象删除。 super.removeJavascriptInterface(&quot;searchBoxJavaBridge_&quot;);super.removeJavascriptInterface(&quot;accessibility&quot;);super.removeJavascriptInterface(&quot;accessibilityTraversal&quot;); 参考资料Android WebView 全面干货指南 H5与Native交互之JSBridge技术","categories":[{"name":"WebView","slug":"WebView","permalink":"https://earthwo.github.io/categories/WebView/"}],"tags":[{"name":"WebView","slug":"WebView","permalink":"https://earthwo.github.io/tags/WebView/"}]},{"title":"ConstraintLayout 1.1新功能","slug":"ConstraintLayout-1-1新功能","date":"2017-12-18T10:03:07.000Z","updated":"2019-03-11T07:35:22.314Z","comments":true,"path":"2017/12/18/ConstraintLayout-1-1新功能/","link":"","permalink":"https://earthwo.github.io/2017/12/18/ConstraintLayout-1-1新功能/","excerpt":"","text":"在ConstraintLayout初步探究中简单的介绍了ConstraintLayout的几个实用的属性，那些都是基于1.0.2的版本的功能。今年的google开发者大会，google为我们带来了新的ConstraintLayout。那么新版的ConstraintLayout又有哪些新的功能呢。 首先，本文基于的版本为1.1.0-beta3. 引用该版本：compile &#39;com.android.support.constraint:constraint-layout:1.1.0-beta3&#39; 宽、高度比例在之前的版本中，如果设置宽度或高度为0dp，View的相应宽、高度会自动撑满布局，这个可以通过设置layout_constraintHeight_default来改变。在1.1版本中，我们可以设置layout_constraintHeight_default=”percent”，同时设置layout_constraintWidth_percent=”0.4”，该属性的值为0-1。 &lt;View android:layout_width=&quot;0dp&quot; android:layout_height=&quot;100dp&quot; android:layout_marginTop=&quot;200dp&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; app:layout_constraintWidth_default=&quot;percent&quot; app:layout_constraintWidth_percent=&quot;0.4&quot; android:background=&quot;#332211&quot;&gt;&lt;/View&gt; barrier当我们的界面布局因为内容的变化而改变时，布局有时候会出现错乱的情况。比如View在两个TextView的右边，但是我们只能设置View的layout_constraintLeft_toRightOf其中的一个TextView，当另一个TextView的文字长度变化时，就会超过并与View重叠，而如果TextView设置layout_constraintRight_toLeftOf时，又会限制TextView的宽度。这时，我们就可以用到barrier了。 关于barrier的详细介绍，可以参考ConstraintLayout之Barrier &lt;TextView android:id=&quot;@+id/v1&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;100dp&quot; android:text=&quot;dadsadsadasdsadsads&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; &gt;&lt;/TextView&gt; &lt;TextView android:id=&quot;@+id/view&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginTop=&quot;100dp&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; android:text=&quot;dadsadsadasdsadsadsdsadsadsa&quot; &gt;&lt;/TextView&gt; &lt;android.support.constraint.Barrier android:id=&quot;@+id/Barrier&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; app:barrierDirection=&quot;right&quot; app:constraint_referenced_ids=&quot;v1,view&quot;/&gt; &lt;View android:id=&quot;@+id/view2&quot; android:layout_width=&quot;10dp&quot; android:layout_height=&quot;match_parent&quot; android:background=&quot;#ff0000&quot; app:layout_constraintLeft_toRightOf=&quot;@+id/Barrier&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot;&gt;&lt;/View&gt; barrier在这里是一个不可见的控件，但是它可以帮我们添加约束条件。这里我们看到，我们设置了app:barrierDirection=”right”，说明约束条件为右，同时将设置constraint_referenced_ids设置barrier的childview。最后将View的layout_constraintLeft_toRightOf设置为barrier。 效果图： GroupGroup顾名思义就是将多个View放在Group中进行统一处理。 &lt;TextView android:id=&quot;@+id/v1&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;100dp&quot; android:text=&quot;dadsadsadasdsadsads&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; &gt;&lt;/TextView&gt; &lt;TextView android:id=&quot;@+id/view&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginTop=&quot;100dp&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; android:text=&quot;dadsadsadasdsadsadsdsadsadsa&quot; &gt;&lt;/TextView&gt;&lt;android.support.constraint.Group android:id=&quot;@+id/group&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; app:constraint_referenced_ids=&quot;v1,view&quot;/&gt; 当我们在代码中设置group.setVisibility(View.GONE)时，两个TextView都会消失。 PlaceholderPlaceholder 可以将自己的内容替换为其他View，所以它可以用来写布局模板，也可以动态修改UI内容。 用作模板模板xml： &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;merge xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:parentTag=&quot;android.support.constraint.ConstraintLayout&quot;&gt; &lt;android.support.constraint.Placeholder android:id=&quot;@+id/template_save&quot; android:layout_width=&quot;48dp&quot; android:layout_height=&quot;48dp&quot; app:content=&quot;@+id/save&quot; app:layout_constraintBottom_toBottomOf=&quot;parent&quot; app:layout_constraintHorizontal_chainStyle=&quot;spread&quot; app:layout_constraintEnd_toStartOf=&quot;@+id/template_delete&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; /&gt; &lt;android.support.constraint.Placeholder android:id=&quot;@+id/template_delete&quot; android:layout_width=&quot;48dp&quot; android:layout_height=&quot;48dp&quot; app:content=&quot;@+id/delete&quot; app:layout_constraintBottom_toBottomOf=&quot;parent&quot; app:layout_constraintEnd_toStartOf=&quot;@+id/template_cancel&quot; app:layout_constraintStart_toEndOf=&quot;@+id/template_save&quot; /&gt; &lt;android.support.constraint.Placeholder android:id=&quot;@+id/template_cancel&quot; android:layout_width=&quot;48dp&quot; android:layout_height=&quot;48dp&quot; app:content=&quot;@+id/cancel&quot; app:layout_constraintBottom_toBottomOf=&quot;parent&quot; app:layout_constraintEnd_toStartOf=&quot;@+id/template_edit&quot; app:layout_constraintStart_toEndOf=&quot;@+id/template_delete&quot; /&gt; &lt;android.support.constraint.Placeholder android:id=&quot;@+id/template_edit&quot; android:layout_width=&quot;48dp&quot; android:layout_height=&quot;48dp&quot; app:content=&quot;@+id/edit&quot; app:layout_constraintBottom_toBottomOf=&quot;parent&quot; app:layout_constraintEnd_toEndOf=&quot;parent&quot; app:layout_constraintStart_toEndOf=&quot;@+id/template_cancel&quot; /&gt;&lt;/merge&gt; Placeholder中都设置了 app:content=”id”，表示需要替换的View的id。 真正的布局文件： &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;android.support.constraint.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;include layout=&quot;@layout/temp&quot; /&gt; &lt;ImageView android:id=&quot;@+id/save&quot; android:layout_width=&quot;48dp&quot; android:layout_height=&quot;48dp&quot; app:srcCompat=&quot;@mipmap/two_point&quot; /&gt; &lt;ImageView android:id=&quot;@+id/edit&quot; android:layout_width=&quot;48dp&quot; android:layout_height=&quot;48dp&quot; app:srcCompat=&quot;@mipmap/three_point&quot; /&gt; &lt;ImageView android:id=&quot;@+id/cancel&quot; android:layout_width=&quot;48dp&quot; android:layout_height=&quot;48dp&quot; app:srcCompat=&quot;@mipmap/four_point&quot; /&gt; &lt;ImageView android:id=&quot;@+id/delete&quot; android:layout_width=&quot;48dp&quot; android:layout_height=&quot;48dp&quot; app:srcCompat=&quot;@mipmap/five_point&quot; /&gt;&lt;/android.support.constraint.ConstraintLayout&gt; 这里模板文件需要放在最前面。 最后看看效果图： 动态替换Placeholder可以在代码中动态替换掉代替的View mPlaceholder= (Placeholder) findViewById(R.id.template_action); findViewById(R.id.save).setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; mPlaceholder.setContentId(v.getId()); &#125; &#125;); 这里的save是不能用Placeholder代替。 最后在1.1版本中，我们可以看到ConstraintLayout的功能越来越多，不仅可以更好的减少代码层级，还可以代替掉一部分逻辑层的代码。","categories":[{"name":"ConstraintLayout","slug":"ConstraintLayout","permalink":"https://earthwo.github.io/categories/ConstraintLayout/"}],"tags":[{"name":"ConstraintLayout","slug":"ConstraintLayout","permalink":"https://earthwo.github.io/tags/ConstraintLayout/"}]},{"title":"ConstraintLayout初步探究","slug":"ConstraintLayout初步探究","date":"2017-12-18T07:33:09.000Z","updated":"2019-03-11T07:35:22.315Z","comments":true,"path":"2017/12/18/ConstraintLayout初步探究/","link":"","permalink":"https://earthwo.github.io/2017/12/18/ConstraintLayout初步探究/","excerpt":"","text":"ConstraintLayout是这两年Google新推出的一个布局，俗称约束布局。相比于之前常用的线性布局和相对布局，ConstraintLayout能够使用的场景更多，能更好的见地页面的布局层级，提升页面的渲染性能。 目前稳定版本是1.0.2，本文后面的内容也都是基于该版本。 基本相对位置属性ConstraintLayout有多个相对位置属性，满足开发者在构建界面的需要，主要使用的如下： layout_constraintTop_toTopOf — 期望视图的上边对齐另一个视图的上边。layout_constraintTop_toBottomOf — 期望视图的上边对齐另一个视图的底边。layout_constraintBottom_toTopOf — 期望视图的下边对齐另一个视图的上边。layout_constraintBottom_toBottomOf — 期望视图的底边对齐另一个视图的底边。layout_constraintLeft_toLeftOf — 期望视图的左边对齐另一个视图的左边。layout_constraintLeft_toRightOf — 期望视图的左边对齐另一个视图的右边。layout_constraintRight_toLeftOf — 期望视图的右边对齐另一个视图的左边。layout_constraintRight_toRightOf — 期望视图的右边对齐另一个视图的右边。 这些属性，从命名上就可以看出它的使用效果，这里就不再详细解释了。不过有一点，这些属性除了可以设置另一个view座位基准，还可以设置其父控件（也就是）ConstraintLayout，比如，将一个view设置在ConstraintLayout中间，就可以这样设置： &lt;View android:layout_width=&quot;100dp&quot; android:layout_height=&quot;100dp&quot; android:background=&quot;@color/colorPrimaryDark&quot; app:layout_constraintRight_toRightOf=&quot;parent&quot; app:layout_constraintBottom_toBottomOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; app:layout_constraintLeft_toLeftOf=&quot;parent&quot;&gt; &lt;/View&gt; 偏移这设置居中后，可以设置其向某一个方向偏移： layout_constraintHorizontal_bias //水平方向layout_constraintVertical_bias //垂直方向 这两个参数的值都是0-1，当大于1是，view会移出屏幕，小于1时无效。在具体理解上，比如说，当layout_constraintHorizontal_bias=0.25时，相当于在水平方面，从左向右，空余部分宽度的0.25处。 &lt;View android:layout_width=&quot;100dp&quot; android:layout_height=&quot;100dp&quot; android:background=&quot;@color/colorPrimaryDark&quot; app:layout_constraintRight_toRightOf=&quot;parent&quot; app:layout_constraintBottom_toBottomOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; app:layout_constraintHorizontal_bias=&quot;0.25&quot; app:layout_constraintLeft_toLeftOf=&quot;parent&quot;&gt; &lt;/View&gt; &lt;View android:layout_width=&quot;100dp&quot; android:layout_height=&quot;100dp&quot; android:background=&quot;@color/colorAccent&quot; app:layout_constraintRight_toRightOf=&quot;parent&quot; app:layout_constraintLeft_toLeftOf=&quot;parent&quot;&gt; &lt;/View&gt; 效果： 可见属性visiable是之前就有的可见属性，在ConstraintLayout中作用也是一样的，不过当设置一个View为visiable=GONE时，与它相关的约束条件依旧是存在的。同时，我们还可以使用layout_goneMarginLeft、layout_goneMarginRight、layout_goneMarginTop、layout_goneMarginBottom来设置在约束view不可见的情况下的距离。 &lt;View android:id=&quot;@+id/v1&quot; android:layout_width=&quot;100dp&quot; android:layout_height=&quot;100dp&quot; android:background=&quot;@color/colorPrimaryDark&quot; app:layout_constraintRight_toRightOf=&quot;parent&quot; app:layout_constraintBottom_toBottomOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; android:visibility=&quot;gone&quot; app:layout_constraintLeft_toLeftOf=&quot;parent&quot;&gt; &lt;/View&gt; &lt;View android:layout_width=&quot;50dp&quot; android:layout_height=&quot;50dp&quot; android:background=&quot;@color/colorAccent&quot; app:layout_goneMarginLeft=&quot;100dp&quot; app:layout_goneMarginTop=&quot;100dp&quot; app:layout_constraintLeft_toRightOf=&quot;@+id/v1&quot; app:layout_constraintTop_toBottomOf=&quot;@+id/v1&quot;&gt; 效果图： 宽高比ConstraintLayout中可以使用layout_constraintDimentionRatio属性来直接设置View的宽高比。 使用方法有如下几种： 1.直接使用float设置： app:layout_constraintDimensionRatio=&quot;2&quot;//宽：高=2 2.使用比值设置： app:layout_constraintDimensionRatio=&quot;2:1&quot;////宽：高=2 3.自定义宽高比： app:layout_constraintDimensionRatio=&quot;W,1:2&quot;//宽：高=2app:layout_constraintDimensionRatio=&quot;H,1:2&quot;//宽：高=0.5 链式约束链这个概念是约束布局新提出的，它提供了在一个维度（水平或者垂直），管理一组控件的方式。使用时，我们需要将整条链上的view都相互约束，同时，处于水平或者垂直方向第一个控件为chain head(链头)，当我们给chain head设置layout_constraintHorizontal_chainStyle或layout_constraintVertical_chainStyle，整条链的状态将会发生改变。 &lt;View android:id=&quot;@+id/v1&quot; android:layout_width=&quot;100dp&quot; android:layout_height=&quot;100dp&quot; app:layout_constraintHorizontal_chainStyle=&quot;spread&quot; android:background=&quot;@color/colorPrimaryDark&quot; app:layout_constraintRight_toLeftOf=&quot;@+id/v2&quot; app:layout_constraintLeft_toLeftOf=&quot;parent&quot;&gt; &lt;/View&gt; &lt;View android:id=&quot;@+id/v2&quot; android:layout_width=&quot;100dp&quot; android:layout_height=&quot;100dp&quot; android:background=&quot;#453535&quot; app:layout_constraintLeft_toRightOf=&quot;@id/v1&quot; app:layout_constraintRight_toLeftOf=&quot;@+id/v3&quot;&gt; &lt;/View&gt; &lt;View android:id=&quot;@+id/v3&quot; android:layout_width=&quot;100dp&quot; android:layout_height=&quot;100dp&quot; android:background=&quot;@color/colorAccent&quot; app:layout_constraintLeft_toRightOf=&quot;@id/v2&quot; app:layout_constraintRight_toRightOf=&quot;parent&quot; &gt; &lt;/View&gt; 效果图： 这里layout_constraintHorizontal_chainStyle或layout_constraintVertical_chainStyle有3个参数: packed:首尾两条链将会分配空间，链内部将不会分配空间 spread:元素之间的空间将会均匀分布，这是系统默认的排列方式 spread_inside:首尾的两条链将不会分配空间，其余内部的链将均匀分配空间。 最后ConstraintLayout一开始觉得没什么特殊的，用起来还麻烦。但是在实际使用后，发现其确实可以避免很多布局嵌套的问题。本文简略的介绍了它的基本用法，如果需要更好的了解，可以去看官方详细的文档。同时，最新的ConstraintLayout也添加了一些新属性，功能也变得更加强大。","categories":[{"name":"ConstraintLayout","slug":"ConstraintLayout","permalink":"https://earthwo.github.io/categories/ConstraintLayout/"}],"tags":[{"name":"ConstraintLayout","slug":"ConstraintLayout","permalink":"https://earthwo.github.io/tags/ConstraintLayout/"}]},{"title":"记录那些经常用却又打死记不住的代码(持续更新)","slug":"记录那些经常用却又打死记不住的代码-持续更新","date":"2017-08-02T07:37:38.000Z","updated":"2019-03-11T07:35:22.330Z","comments":true,"path":"2017/08/02/记录那些经常用却又打死记不住的代码-持续更新/","link":"","permalink":"https://earthwo.github.io/2017/08/02/记录那些经常用却又打死记不住的代码-持续更新/","excerpt":"","text":"时间固定格式转LongSimpleDateFormat simpleDateFormat = new SimpleDateFormat(style);Date date = simpleDateFormat.parse(time);return date.getTime(); 组合属性动画方法1：PropertyValuesHolder holder1=PropertyValuesHolder.ofFloat(&quot;scaleX&quot;,1.0f,1,5f);...ObjectAnimator animator=ObjectAnimator.ofPropertyValuesHolder(view,holder1,holder2,holder3); 方法2：AnimatorSet set=new AnimatorSet();AnimatorSet.Builder builder=set.play(animator1);builder.after(animator2);set.start(); 方法3： AnimatorInflater.loadAnimator(context,R.animator.t); 动画配置文件： &lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:duration=&quot;200&quot; android:ordering=&quot;together&quot;&gt; &lt;objectAnimator android:propertyName=&quot;translationX&quot;&gt;&lt;/objectAnimator&gt; &lt;objectAnimator android:propertyName=&quot;translationY&quot;&gt;&lt;/objectAnimator&gt;&lt;/set&gt; DOM解析xmlDocumentBuilderFactory builderFactory=DocumentBuilderFactory.newInstance(); DocumentBuilder documentBuilder=builderFactory.newDocumentBuilder(); Document document= documentBuilder.parse(inputStream); Element rootNode=document.getDocumentElement(); NodeList nodeList=rootNode.getChildNodes(); ... PULL解析XmlResourceParser xmlResourceParser= getResources().getLayout(id);AttributeSet attrs=Xml.asAttributeSet(xmlResourceParser); while(XmlPullParser.END_DOCUMENT!=xmlResourceParser.getEventType())&#123; if(xmlResourceParser.getEventType()==XmlPullParser.START_TAG&amp;&amp;xmlResourceParser.getName().equals(&quot;item&quot;))&#123;//条件满足，解析具体的值 int a=obtainStyledAttributes(attrs, R.styleable.MenuItem).getInt(R.styleable.CircleImage2_d3,0); &#125; XmlPullParser.next(); &#125; SAX解析SAXParserFactory sax=SAXParserFactory.newInstance();InputStream inputStream=getResources().openRawResource(R.raw.sax);SAXParser saxParser= sax.newSAXParser();saxParser.parse(inputStream,new DefaultHandler()&#123; @Override public void startDocument() throws SAXException &#123; super.startDocument(); &#125; @Override public void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException &#123; super.startElement(uri, localName, qName, attributes); &#125; @Override public void endElement(String uri, String localName, String qName) throws SAXException &#123; super.endElement(uri, localName, qName); &#125; @Override public void endDocument() throws SAXException &#123; super.endDocument(); &#125; @Override public void characters(char[] ch, int start, int length) throws SAXException &#123; super.characters(ch, start, length); &#125; &#125;); 其中characters是解析具体的数据时的回调，在startDocument、startElement和endElement方法执行。","categories":[{"name":"tips和坑","slug":"tips和坑","permalink":"https://earthwo.github.io/categories/tips和坑/"}],"tags":[{"name":"tips和坑","slug":"tips和坑","permalink":"https://earthwo.github.io/tags/tips和坑/"}]},{"title":"Rxjava常用操作符","slug":"Rxjava常用操作符","date":"2017-07-27T03:38:49.000Z","updated":"2019-03-11T07:35:22.321Z","comments":true,"path":"2017/07/27/Rxjava常用操作符/","link":"","permalink":"https://earthwo.github.io/2017/07/27/Rxjava常用操作符/","excerpt":"","text":"创建操作符just操作符Observable observable=Observable.just(10,2); 依次会调用onNext(10)和onNext(2)； interval操作符按照固定时间间隔发送整数序列的Observable(从0开始)。Observable observable=Observable.interval(10,TimeUnit.SECONDS); range操作符创建发送指定范围的整数序列的ObservableObservable observable=Observable.range(2,3); 从2开始3个整数 repeat操作符创建重复N次的发送数据的OnservableObservable observable=Observable.range(2,2).repeat(4); 从2开始2个整数,再重复4次 defer操作符直到有订阅者订阅时，才通过Observable的工厂方法创建Observable并执行i=9; Observable observable=Observable.just(i); Observable deferObservable = Observable.defer(new Callable&lt;ObservableSource&lt;Integer&gt;&gt;() &#123; @Override public ObservableSource call() throws Exception &#123; return Observable.just(i); &#125; &#125;); i=10; deferObservable.subscribe(new Consumer() &#123; @Override public void accept(@io.reactivex.annotations.NonNull Object o) throws Exception &#123; Log.d(&quot;延迟显示&quot;,o.toString()); &#125; &#125;); observable.subscribe(new Consumer() &#123; @Override public void accept(@io.reactivex.annotations.NonNull Object o) throws Exception &#123; Log.d(&quot;显示&quot;,o.toString()); &#125; &#125;); 结果延迟显示: 10显示: 9 timer操作符指定时间后发射一个数字0的OnservableObservable observable = Observable.timer(2,TimeUnit.SECONDS); 变换操作符map操作符将Observable转换为新的Observable并发送i=9; Observable observable = Observable.just(i).map(new Function() &#123; @Override public Object apply(@io.reactivex.annotations.NonNull Object o) throws Exception &#123; return Integer.parseInt(o.toString())+20; &#125; &#125;); flatMap操作符将Observalbes的数据变化为Observable。i=9; Observable observable = Observable.just(i).flatMap(new Function&lt;Integer, ObservableSource&lt;?&gt;&gt;() &#123; @Override public ObservableSource&lt;?&gt; apply(@io.reactivex.annotations.NonNull Integer integer) throws Exception &#123; return Observable.range(integer,3); &#125; &#125;); 它与map的区别是它返回一个Observable，所以你可以在返回时再次进行操作。 cast操作符可以将发射的数据转换为指定类型(比如子类转化为父类)Observable observable = Observable.just(i).flatMap(new Function&lt;Integer, ObservableSource&lt;?&gt;&gt;() &#123; @Override public ObservableSource&lt;?&gt; apply(@io.reactivex.annotations.NonNull Integer integer) throws Exception &#123; return Observable.range(integer,3); &#125; &#125;).cast(Integer.class); concatMap操作符与flatMap的使用方法基本一样，但是flatMap变换后的输出顺序可能是交错的，concatMap不会交错。Observable observable = Observable.just(1,2,3,4,5).concatMap(new Function&lt;Integer, ObservableSource&lt;Integer&gt;&gt;() &#123; @Override public ObservableSource apply(@io.reactivex.annotations.NonNull Integer integer) throws Exception &#123; return Observable.just(integer*10).delay(10-integer,TimeUnit.SECONDS); &#125; &#125;); 在上面这种情况下，输入依旧是：10，20，30，40，50；而如果是flatMap，则输出是50，40，30，20，10 flatMapIterable操作符可以将数据打包成IterableObservable observable = Observable.just(1,2,3,4,5).flatMapIterable(new Function&lt;Integer, Iterable&lt;Integer&gt;&gt;() &#123; @Override public Iterable apply(@io.reactivex.annotations.NonNull Integer integer) throws Exception &#123; List&lt;Integer&gt;list=new ArrayList&lt;&gt;() list.add(integer); return list; &#125; &#125;); buffer操作符将传入的数据变成列表传输Observable observable = Observable.just(1,2,3,4,5).buffer(3); 以3个数据为一组。输出:[1,2,3],[4,5] groupBy操作符将传入的数据分组后传出Person p1=new Person(1); Person p2=new Person(1); Person p3=new Person(3); Person p4=new Person(4); Person p5=new Person(3); Person p6=new Person(2); Observable observable = Observable.just(p1,p2,p3,p4,p5,p6).groupBy(new Function&lt;Person, Integer&gt;() &#123; @Override public Integer apply(@io.reactivex.annotations.NonNull Person person) throws Exception &#123; return person.getAge(); &#125; &#125;); Observable.concat(observable).subscribe(new Consumer&lt;Person&gt;() &#123; @Override public void accept(@io.reactivex.annotations.NonNull Person o) throws Exception &#123; Log.d(&quot;显示&quot;,o.getAge()+&quot;&quot;); &#125; &#125;); &#125; 结果：1,1,3,3,4,2 过滤操作符filter操作符对源数据进行过滤Observable observable = Observable.just(1,3,3,45,67,78).filter(new Predicate&lt;Integer&gt;() &#123; @Override public boolean test(@io.reactivex.annotations.NonNull Integer integer) throws Exception &#123; return integer&gt;50; &#125; &#125;); elementAt操作符返回指定位置的数据Observable observable = Observable.just(1,3,3,45,67,78).elementAt(3).toObservable(); 只取45 dustinct操作符去重Observable observable=Observable.just(1,2,3,5,6,7,8,1,2).distinct(); 输出：1，2，3，5，6，7，8 skip操作符过滤掉n个数据Observable observable=Observable.just(1,2,3,5,6,7,8,1,2).skip(3); 输出：5,6,7,8,1,2 take操作符取前N个数据Observable observable=Observable.just(1,2,3,5,6,7,8,1,2).take(3); 输出：1，2，3还有takeLast，取后n个 ignoreElements操作符将源数据全部忽略掉Observable bservable=Observable.just(1,2,3,5,6,7,8,1,2).ignoreElements().toObservable(); 直接执行onCompleted() throttleFirst操作符定时发射时间段里收到的第一个数据Observable observable=Observable.interval(1,TimeUnit.SECONDS).throttleFirst(3,TimeUnit.SECONDS); 结果：0，4，8… throttleWithTimeout操作符在限定时间内如果有值传出来，就重新及时，超时就传出值Observable observable=Observable.interval(2,TimeUnit.SECONDS).throttleWithTimeout(1,TimeUnit.SECONDS); 结果：0，1，2，3… 组合操作符startWith在数据源前插入数据List&lt;Integer&gt;li=new ArrayList&lt;&gt;(); li.add(1);li.add(2);li.add(1);li.add(1); Observable observable=Observable.just(1,2,3).startWith(li); 结果：1，2，1，1，1，2，3 merge操作符将多个Observable合并到一个发送，数据可能会交错Observable observable1=Observable.just(1,2,3); Observable observable2=Observable.just(3,4,5); Observable observable= Observable.merge(observable1,observable2); 结果：1，2，3，3，4，5 concat操作符将多个数据合并发送，数据会严格按照顺序排列Observable observable1=Observable.just(1,2,3); Observable observable2=Observable.just(3,4,5); Observable observable= Observable.concat(observable1,observable2); 结果：1，2，3，3，4，5 zip操作符合并数据，并根据指定的函数变换Observable observable1=Observable.just(1,2,3); Observable observable2=Observable.just(3,4,5); Observable observable= Observable.zip(observable1, observable2, new BiFunction&lt;Integer,Integer,String&gt;() &#123; @Override public String apply(@io.reactivex.annotations.NonNull Integer o, @io.reactivex.annotations.NonNull Integer o2) throws Exception &#123; return o+&quot;***&quot;+o2; &#125; &#125;); 结果：13，24，3***5当数量不对等时，按最少的那个合并。 combineLastest操作符将最近发射的数据项合并Observable observable1=Observable.just(1,2); Observable observable2=Observable.just(3,4,5); Observable observable= Observable.combineLatest(observable1, observable2, new BiFunction&lt;Integer,Integer,String&gt;() &#123; @Override public String apply(@io.reactivex.annotations.NonNull Integer o, @io.reactivex.annotations.NonNull Integer o2) throws Exception &#123; return o+&quot;***&quot;+o2; &#125; &#125;); 当observable2发射数据时，observable1已经发射完，所有其最近数据项是2，所以结果是：23，24，2***5 辅助操作符delay操作符延迟操作Observable observable1=Observable.just(1,2).delay(2,TimeUnit.SECONDS); Do操作符Do系列操作符相当于在Observable生命周期时注册回调，比如：doOnEach:每次发送数据时执行doOnNext:执行onNext时调用doOnSubscribe:观察者订阅时执行doOnUnsubscribe:取消订阅时执行doOnCompleted:完成时执行doOnError:报错时执行doOnTerminate:终止前（结束或异常）执行finallyDo:终止后（结束或异常）执行 subscribeOn、observeOn操作符subscribeOn指定Observable在哪个线程上运行，observeOn指定Observer在哪个线程运行observable.subscribeOn(Schedulers.io()).observeOn(AndroidSchedulers.mainThread()) Observable在io线程，Observer在主线程 timeout操作符当指定时间没有数据时，会执行onErrorObservable observable=Observable.interval(2000,TimeUnit.SECONDS).timeout(100,TimeUnit.MILLISECONDS); 错误处理操作符catch操作符catch将拦截onError，将他替换成其他数据。实现有3个操作符：onErrorReturn、onErrorResumeNext、onExceptionResumeNext。onErrorReturn:错误时返回原来Observable的备用ObservableList&lt;Integer&gt;li=new ArrayList&lt;&gt;(); li.add(1);li.add(2);li.add(1);li.add(1); Observable observable=Observable.just(li).map(new Function&lt;List&lt;Integer&gt;,Integer&gt;() &#123; @Override public Integer apply(@io.reactivex.annotations.NonNull List&lt;Integer&gt; o) throws Exception &#123; return o.get(33); &#125; &#125;).onErrorReturn(new Function&lt;Throwable, Integer&gt;() &#123; @Override public Integer apply(@io.reactivex.annotations.NonNull Throwable throwable) throws Exception &#123; return 1231321; &#125; &#125;); 结果为：1231321 onErrorResumeNext:与onErrorReturn基本一样，但是它返回的是ObservableSource数据List&lt;Integer&gt;li=new ArrayList&lt;&gt;(); li.add(1);li.add(2);li.add(1);li.add(1); Observable observable=Observable.just(li).map(new Function&lt;List&lt;Integer&gt;,Integer&gt;() &#123; @Override public Integer apply(@io.reactivex.annotations.NonNull List&lt;Integer&gt; o) throws Exception &#123; return o.get(33); &#125; &#125;).onErrorResumeNext(new Function&lt;Throwable, ObservableSource&lt;? extends Integer&gt;&gt;() &#123; @Override public ObservableSource&lt;? extends Integer&gt; apply(@io.reactivex.annotations.NonNull Throwable throwable) throws Exception &#123; return Observable.just(11,3); &#125; &#125;); 结果:11,3 onExceptionResumeNext:它收到后，需要自己重新调用onNext和onCompleted方法逻辑，不会返回Observable。List&lt;Integer&gt;li=new ArrayList&lt;&gt;(); li.add(1);li.add(2);li.add(1);li.add(1); Observable observable=Observable.just(li).map(new Function&lt;List&lt;Integer&gt;,Integer&gt;() &#123; @Override public Integer apply(@io.reactivex.annotations.NonNull List&lt;Integer&gt; o) throws Exception &#123; return o.get(33); &#125; &#125;).onExceptionResumeNext(new ObservableSource&lt;Integer&gt;() &#123; @Override public void subscribe(@io.reactivex.annotations.NonNull Observer&lt;? super Integer&gt; observer) &#123; observer.onNext(333); observer.onComplete(); &#125; &#125;); retry操作符出错时，它会重新订阅相应的次数。List&lt;Integer&gt;li=new ArrayList&lt;&gt;(); li.add(1);li.add(2);li.add(1);li.add(1); Observable observable=Observable.just(li).map(new Function&lt;List&lt;Integer&gt;,Integer&gt;() &#123; @Override public Integer apply(@io.reactivex.annotations.NonNull List&lt;Integer&gt; o) throws Exception &#123; Log.d(&quot;显示&quot;,&quot;错误了&quot;); return o.get(33); &#125; &#125;).retry(2); 会打印3次错误了。 条件操作符和布尔操作符all操作符会对所有的数据进行判断，全部满足则返回true，否则返回falseObservable observable=Observable.just(1,2,3).all(new Predicate&lt;Integer&gt;() &#123; @Override public boolean test(@io.reactivex.annotations.NonNull Integer integer) throws Exception &#123; return integer&gt;0; &#125; &#125;).toObservable(); 结果：true contain、isEmptycontain:判断是否包含某个值isEmpty:判断是否为空Observable observable=Observable.just(1,2,3).contains(2).toObservable();Observable observable=Observable.just(1,2,3).isEmpty().toObservable(); 结果：true，false abm、abmArray操作符发射先发射数据的Observable observabl1=Observable.just(1); Observable observabl2=Observable.just(2).delay(10,TimeUnit.SECONDS); Observable observable=Observable.ambArray(observabl1,observabl2); 结果：1 defaultIfEmpty操作符发射原来的数据，如果没有数据就发射一个默认的数据。 转换操作符toList操作符将多个数据转换为List数据Observable observable=Observable.just(1,2,3).toList().toObservable(); 结果为：[1, 2, 3] toSortedList用法与toList一样，但是它会自动排列顺序，默认按升序排序，数据项没有定义comparable接口，会抱错。也可以使用toSortedList(Comparator&lt;? super T&gt; comparator)定义顺序。Observable observable=Observable.just(1,2,3,1,2,5,2).toSortedList(new Comparator&lt;Integer&gt;() &#123; @Override public int compare(Integer lhs, Integer rhs) &#123; return lhs-rhs; &#125; &#125;).toObservable(); 结果：[1, 1, 2, 2, 2, 3, 5] toMap操作符将数据添加到map（HashMap）发射，Observable observable=Observable.just(1,2,3,1,2,5,2).toMap(new Function&lt;Integer, Object&gt;() &#123; @Override public Object apply(@io.reactivex.annotations.NonNull Integer integer) throws Exception &#123; return integer+&quot;*&quot;; &#125; &#125;).toObservable(); apply中设置map的key结果： {5=5, 3=3, 1=1, 2=2}","categories":[{"name":"Rxjava","slug":"Rxjava","permalink":"https://earthwo.github.io/categories/Rxjava/"}],"tags":[{"name":"Rxjava","slug":"Rxjava","permalink":"https://earthwo.github.io/tags/Rxjava/"}]},{"title":"《Android进阶之光》读书笔记(五)","slug":"《Android进阶之光》读书笔记(五)","date":"2017-07-25T10:09:09.000Z","updated":"2019-03-11T07:35:22.328Z","comments":true,"path":"2017/07/25/《Android进阶之光》读书笔记(五)/","link":"","permalink":"https://earthwo.github.io/2017/07/25/《Android进阶之光》读书笔记(五)/","excerpt":"","text":"设计模式六大原则1.单一职责原则：就一个类而言，应该仅有一个引起它变化的原因。人话：我们不应该让一个类承担过多的责任，责任越多，耦合就越多，一个职责的变化会抑制或削弱其他职责的能力。 2.开放封闭原则：类、模块、函数等应该是可以扩展的，但是不可修改。人话：我们在面对需求改变的时候要尽可能的保证相对稳定，尽量通过拓展的方式来实现变化，而不是通过修改原有代码的方式。 3.里氏替换原则：所有引用基类（父类）的地方必须能透明的使用其子类的对象。人话：基类对象替换为子类对象时，程序将不能不会产生任何错误和异常；反之则不成立。所以在程序中尽可能的使用基类类型来对对象定义，在运行时再确定其子类类型。注意：子类的所有方法都必须在基类中声明，或子类必须实现父类中声明的所有方法。 4.依赖倒置原则：高层模块不应该依赖低层模块，两者都应该依赖于抽象，抽象不应该依赖细节，细节应该依赖抽象。人话：抽象指的是接口或抽象类，细节指的是具体的实现类；高层模块指的是调用端，低层模块指的是具体的实现端。这句话的意思就是两个实现类之间不能直接发生依赖，应该通过接口或者抽象类产生依赖。 5.迪米特原则：一个软件实体应该尽可能少的与其他实体发生相互作用。人话：两个对象之间要尽量避免相互作用，如果一个对象要调用另一个对象，那么要尽量使用第三者来调用。通过引入一个合理的第三者可以降低现有对象之间的耦合度。 6.接口隔离原则：一个类对另一个类的依赖应该建立在最小的接口上。人话：接口要尽可能的小，不要建立臃肿的接口，接口中的方法要尽量的少。 设计模式分类创建型设计模式：单例模式、工厂方法模式、抽象工厂模式、建造者模式、原型模式。结构型设计模式：适配器模式、装饰模式、代理模式、外观模式、桥接模式、组合模式、享元模式。 行为型设计模式：策略模式、模板方法模式、观察者模式、迭代器模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。 单例模式 饿汉模式public class Singleton&#123; private static Singleton singleton=new Singleton(); private Singleton()&#123; &#125; public static Singleton getInstance()&#123; return singleton; &#125;&#125; 类加载时就初始化，加载会慢，但是获取对象会快。同时避免了线程同步的问题，但是如果没有使用会存在内存浪费的问题。 懒汉模式（线程不安全版）public class Singleton&#123; private static Singleton singleton; private Singleton()&#123; &#125; public static Singleton getInstance()&#123; if(singleton==null)&#123; singleton=new Singleton(); &#125; return singleton; &#125;&#125; 节约了资源，但是第一次时会比较慢，同时多线程下也会不安全。 懒汉模式（线程安全）public class Singleton&#123; private static Singleton singleton; private Singleton()&#123; &#125; public static synchronized Singleton getInstance()&#123; if(singleton==null)&#123; singleton=new Singleton(); &#125; return singleton; &#125;&#125; 解决了线程安全问题，但是同步时会造成不必要的开销，所以不建议使用。 双重检查模式（DCL）public class Singleton&#123; private static volatile Singleton singleton; private Singleton()&#123; &#125; public static Singleton getInstance()&#123; if(singleton==null)&#123; synchronized(singleton)&#123; if(singleton==null)&#123; singleton=new Singleton(); &#125; &#125; &#125; return singleton; &#125;&#125; 资源利用率高，只有在第一次的时候才会有同步和创建问题，但是还是会有突然失效问题。 内部静态类模式public class Singleton&#123; private Singleton()&#123; &#125; public static Singleton getInstance()&#123; return SingletonHolder.mSingleton; &#125; private static class SingletonHolder&#123; private static final Singleton mSingleton=new Singleton(); &#125;&#125; 这种模式在加载类时不会初始化mSingleton，只会在第一次调用时初始化，同时也避免了同步问题。推荐使用。 枚举单例public enum Singleton&#123; SINGLETON; public void doSomething()&#123; &#125;&#125; 默认枚举实例的创建是线程安全的，并且在任何情况下都是单例。枚举单例最大的有点就是简单，但是枚举用到的情况很少。 在反序列化时，这些模式下都会重新创建对象，避免方法如下 重写readResolve方法：private Object readResolve() throws ObjectStreamException&#123; return singleton;&#125; 系统中单例使用的地方有：LocalBroadcastManager，InputMethodManager以及各种服务的注册。 简单工厂模式主要有三个角色： IProduct:抽象产品类，里面定义实例所有的公共方法。 Product:具体产品类，继承抽象产品类，实现相应的逻辑。 Factory:工厂类，实现所有的创建产品类的逻辑，里面的方法可以被外界调用，即根据不同的情况创建各个Product。 使用场景： 工厂类负责创建的对象较少；客户只需要知道传入工厂的参数，无须关心创建对象的逻辑。优缺点：避免了直接实例化类，降低了耦合；可实例化的类型在编译期间就已经确定，如果要增加，需要修改工厂，这违背了开放封闭原则；子类过多或子类层次过多时不适合使用。 工厂方法模式主要有三个角色： Product:抽象产品类，里面定义实例所有的公共方法。 ConcreteProduct:具体产品类，继承抽象产品类，实现相应的逻辑。 Factory:抽象工厂类，该方法返回一个Product类型的对象。 ConcreteFactory:具体工厂类，通过反射的方式创建返回ConcreteProduct实例。 优缺点：添加产品时不需要修改工厂类，可以直接通过添加类的方式完成。 也可以理解为继承实现抽象，但是实现的方法中返回或操作了不同的子类，那个该方法就是工厂方法。 具体的示例有：activity的oncreate，它会操作不同的View的子类；如ArrayList、HashMap等的interator，会返回不同的子类。 建造者模式定义：将一个复杂对象的构建与它的表示分离。一般会使用一个内部类Builder来创建对象。使用场景：对象一般比较复杂，有很多的变量需要传入的情况。 常见情况：AlertDialog 装饰模式角色如下： Component:抽象组件，接口或是抽象类。 ConcreteComponent:组件的具体实现，继承Component。 Decorator:抽象装饰者，实现Component，同时又Component变量。 ConcreteDecorator:装饰者实现，同时添加自己的相关逻辑功能。 实现时先回创建组件对象添加到装饰者中，装饰者即调用组件的逻辑，有调用自己的相关逻辑，从而实现功能的添加。 优缺点：通过组合而非继承的方式扩展对象的功能，增加了灵活性，组件和装饰者都可以独立的变化；但是如果抽象组件变化则所有的都要变化，同时装饰层数不能过多，否则会影响效率。 外观模式定义：要求一个子系统的外部与内部通信都必须通过一个对象。即所有子系统对象的方法调用都要通过另一个类。 优缺点：减少系统的相互依赖，子系统之间的依赖，可以通过外观类相互通信，隐藏了子系统，加强了安全性；缺点是不符合开放封闭原则，业务变更时需要直接修改外观类。 享元模式定义：使共享对象有效的支持大量细粒度对象。 对象由3个，一个是抽象享元角色，定义的方法的接口，第二个是实现了该接口的类，即具体享元角色，第三个是享元工厂，在里面有一个享元角色的容器（Map），有静态方法根据参数返回容器里面的角色或者创建新对象返回并添加到容器。 享元模式的使用场景是系统中存在大量的相似对象，而且需要缓存池。 策略模式定义：定义一系列算法，把每个算法封装起来，使他们可以互相替换。其实就是把一些不同情况下的具体的执行代码各自封装起来，避免大量代码功能相似的代码堆在一起。 优缺点：可以避免多重条件语句，添加策略时只需要在添加一个类实现方法接口就好了；缺点是复用性小，上层模块必须要知道有哪些策略。 使用场景：动画的插值器TimeInterpolator 模块方法模式实际上就是父类封装了固定的流程，同时有一些具体实现方法为抽象方法。子类继承后实现具体方法。 优缺点：去除了子类中的部分重复代码。 使用场景：AsyncTask中的方法，activty的生命周期的方法 观察者模式定义：定义对象间的一种一对多的依赖关系，每当一个对象改变状态时，所有依赖它的对象都会得到通知并更新。 即需要有一个被观察者，同时多个观察者创建都注册到被观察者，当被观察者改变时，向所有的观察者发送通知，更新观察者。 优缺点：观察者和被观察者都是抽象耦合，容易扩展。 使用场景：各种listener，adapter中的notifyDataSetChanged() （补充的设计模式）原型模式定义：原型模式是用户从一个样板对象中复制一个内部属性一致的对象即clone。被复制的对象就是原型，这种情况一般用在创建和初始化对象比较复杂的情况，其本质就是对象拷贝。 常见情况ArrayList 深拷贝和浅拷贝如果一个对象进行clone后，里面的所有字段都会重新构造一遍，而是引用的原始文档的字段，所以当改变字段内容后，两边都会改动。这种情况时浅拷贝。为避免这种情况，应该使用深拷贝，深拷贝是处理拷贝该对象外，还要将里面的需要拷贝的对象也都拷贝。ArrayList除了会拷贝object外，还会重新构建内部存储的数据，Intent的clone方法是重新new一个对象。 状态模式定义：一个对象的内在状态改变时，其具体的行为也会改变。想过与状态改变时，某些方法不执行等，其结构与策略模式一样，但是具体执行哪个策略与状态有关。 使用场景：WifiSetting中的wifi管理 责任链模式定义：多个对象都有机会处理请求，从而避免了请求的发送者和接受者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递请求，直到有对象处理它为止。 使用场景：touch事件的传递 解释器模式定义：给定一个语言，定义它的文法的一种表示，并定义一个解释器，该解释器使用该表示来解释语言中的句子。举个例子，比如说计算器，输入一个表达式，要解析里面的符号和数字，进行计算。 使用场景：PacketParser，该类会解析AndroidManifest.xml的内容，将其转换为相应的类。 命令模式定义：将一个请求封装成一个对象，从而让用户使用不同的请求将客户端参数化；对请求排队或者记录请求日志，以及支持可撤销的操作。 就是讲具体执行的逻辑封装在一个请求对象中，在将这个对象放到请求者中，请求者请求时执行请求对象，请求对象执行具体的逻辑代码。 备忘录模式定义：在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样可以将对象回复到原来保存的状态。 使用场景：onSaveInstancState和onRestoreInstance 迭代器模式定义：提供一种方法顺序访问一个容器对象中的各个元素，而又不需要暴露该对象的内部表示。迭代器主要是用在遍历容器对象时使用。 使用场景：Map,List中的Iterator 访问者模式定义：封装一些作用于某种数据结构中的各元素的操作，它可以在不改变这个数据结构的前提下定义作用于这些元素的新的操作。 其基本的想法是：一个由许多对象构成的、比较稳定的对象结构，这些对象都有一个accept方法来接收访问者对象的访问，访问者是一个接口，有visit方法，这个方法对访问到的对象中的不同类型的元素做出不同的处理。在对象的一次访问中，我们遍历所有的元素，对每个元素都进行accept方法，在accept方法中都调用visit方法，从而是访问者可以处理所有的元素，我们可以根据不同的访问者类来完成不同的操作，达到区别对待的结果。 使用场景：ButterKnife","categories":[{"name":"Android进阶之光","slug":"Android进阶之光","permalink":"https://earthwo.github.io/categories/Android进阶之光/"},{"name":"读书笔记","slug":"Android进阶之光/读书笔记","permalink":"https://earthwo.github.io/categories/Android进阶之光/读书笔记/"}],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://earthwo.github.io/tags/读书笔记/"},{"name":"Android进阶之光","slug":"Android进阶之光","permalink":"https://earthwo.github.io/tags/Android进阶之光/"}]},{"title":"《Android进阶之光》读书笔记(四)","slug":"《Android进阶之光》读书笔记（四）","date":"2017-07-24T09:20:26.000Z","updated":"2019-03-11T07:35:22.330Z","comments":true,"path":"2017/07/24/《Android进阶之光》读书笔记（四）/","link":"","permalink":"https://earthwo.github.io/2017/07/24/《Android进阶之光》读书笔记（四）/","excerpt":"","text":"网络分层1.物理层：负责比特流在节点间的传输，即负责物理传输。2.数据链路层：主要功能是在不可靠的物理线路上进行数据的可靠传输。它将从网络层收到的数据分割成特定的可被物理层传输的帧。3.网络层：该层决定如何将数据从发生方路由到接收方4.传输层：该层为两台主机上的应用程序提供端到端的通信，主要有两个传输协议；TCP和UDP。5.应用层：应用层就是规定应用程序的数据格式的，主要协议有HTTP，FTP，Telnet，SMTP，POP3等。 TCP 3次握手和4次挥手3次握手 建立连接。客户端发送连接请求报文端段，将SYN设置为1，Sequence Number(seq)为x,接下来客户端进入SYN_SENT状态，等待服务端的确认 服务端收到客户端的SYN报文段，对SYN报文进行确认，设置Acknowledgment Number(ACK)为x+1(seq+1)；同时自己发送SYN请求信息，将SYN设置为1，seq为y。服务端将上述所有的信息放到SYN+ACK报文段中，一并发送到客户端，此时服务端进入SYN_RCVD状态 客户端收到服务端SYN+ACK报文段，将ACK设置为y+1，向服务端发送ACK报文段，发送完后，两边都进入连接成功状态通俗点说：首先客户端向服务端发送一个消息，服务端收到后，知道客户端可以发送消息，自己可以接受消息；然后无服务向客户端发送一个消息，客户端收到后，知道自己可以发送接受消息，服务端可以发送接受消息；最后客户端再向服务端发送消息，服务端收到后，服务端就知道了自己可以发送消息，这样双方就都知道了双方都可以发送接收消息，连接建立。4次挥手 客户端设置seq和ACK，向服务端发送一个FIN报文段，此时，客户端进入FIN_WAIT_1状态 服务端收到FIN报文段，向客户端回一个ACK报文段 服务端收到客户端发送的FIN报文段，请求关闭连接，同时服务端进入LAST_ACK状态 客户端收到服务端发送的FIN报文段，向服务端发送ACK报文段，然后客户端进入TIME_WAIT状态。服务端收到客户端的ACK报文段后，关闭连接。此时，客户端等待2MSL后没有收到回复，说明服务端已经关闭，这样客户端也关闭。通俗点说：客户端向服务端发送一个请求，说明没有内要发送了；服务端收到后，也想客户端发一个消息，双方都进入等待关闭状态；服务端发送消息，请求关闭连接；客户端收到后发送消息，服务端收到后关闭，客户端等待一段时间后，也关闭。HTTP协议主要特点：支持客户/服务器模式；简单快速（只需传输请求方法和路径）；灵活（允许传输任意类型的数据对象）；无连接（每次连接只处理一个请求）；无状态：协议无状态协议，后续处理需要前面的信息就必须重传。 请求报文由请求行、请求报头、空行和请求数据构成。请求行由请求方法、url、Http协议版本组成，其中请求方法有：(GET、POST、HEAD、PUT、DELETE、TRACE、CONNECT、OPTION)请求报头会有0个或多个，每个请求报头都会包含一个名字和值，并用：分割。典型的请求报头如下：Host:请求主机名。User-Agent:发送请求的浏览器类型，操作系统信息等。Accetp:客户端可识别的内容类型列表Accept—Encoding:客户端可识别的数据编码Accept-Language:浏览器所支持的语言类型Connection:客户端与服务端的连接的有关选项，如keep-AliveTransfer-Encoding:接收端对报文的编码方式请求数据：在POST方法中使用。 响应报文由状态行、响应报头、空行、响应正文组成。状态行：100-199:指示信息200-299:请求成功300-399:重定向400-499:客户端错误500-599:服务端错误。响应报头:用于服务端传递自身信息的响应，常见的如下：Location:用于重定向接受者到一个新的位置Server:包含服务器用来处理请求的系统信息，与User-Agent相对应。 其他报头：通用报头：既可以在请求报头，也可以在响应报头。如下：Date:消息产生的日期和时间Connection:允许发送指定连接的选项Cache-Control:用于指定缓存指令实体报头：用来定义传输资源的信息，既可以在请求，也可以在响应。如下：Content-Type:发送给接受者的实体正文的媒体类型Content-Lenght:实体正文的长度Content-Language:描述资源所有的自然语言Content-Encoding:实体报文被用作媒体类型的修饰符。Last-Modified:实体报头用于指定资源的最后修改日期和时间Expires:实体报头给出响应过期的日期和时间。","categories":[{"name":"Android进阶之光","slug":"Android进阶之光","permalink":"https://earthwo.github.io/categories/Android进阶之光/"},{"name":"读书笔记","slug":"Android进阶之光/读书笔记","permalink":"https://earthwo.github.io/categories/Android进阶之光/读书笔记/"}],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://earthwo.github.io/tags/读书笔记/"},{"name":"Android进阶之光","slug":"Android进阶之光","permalink":"https://earthwo.github.io/tags/Android进阶之光/"}]},{"title":"记录那些经常用却又打死记不住的代码(一)","slug":"记录那些经常用却又打死记不住的代码","date":"2017-07-20T05:39:06.000Z","updated":"2019-03-11T07:35:22.330Z","comments":true,"path":"2017/07/20/记录那些经常用却又打死记不住的代码/","link":"","permalink":"https://earthwo.github.io/2017/07/20/记录那些经常用却又打死记不住的代码/","excerpt":"","text":"在开发过程中，总会遇到很多其实经常写，但又死活记不住(也许是本人比较笨)，每次都需要google的一些代码。这篇文章就是记录那些代码，以方便以后快速找到。 跳转到系统图库页面Intent albumIntent = new Intent(Intent.ACTION_PICK);albumIntent.setDataAndType(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, &quot;image/*&quot;);activity.startActivityForResult(albumIntent, 0); 跳转到系统相机页面Intent cameraIntent = new Intent(&quot;android.media.action.IMAGE_CAPTURE&quot;);cameraIntent.putExtra(MediaStore.EXTRA_OUTPUT, Uri.fromFile(new File(fileName)));activity.startActivityForResult(getImageByCamera, 0); 判断程序是否在后台ActivityManager activityManager = (ActivityManager) context.getApplicationContext() .getSystemService(Context.ACTIVITY_SERVICE); String packageName = context.getApplicationContext().getPackageName(); /** * 获取Android设备中所有正在运行的App */ List&lt;ActivityManager.RunningAppProcessInfo&gt; appProcesses = activityManager .getRunningAppProcesses(); if (appProcesses == null) return false; for (ActivityManager.RunningAppProcessInfo appProcess : appProcesses) &#123; if (appProcess.processName.equals(packageName) &amp;&amp; appProcess.importance == ActivityManager.RunningAppProcessInfo.IMPORTANCE_FOREGROUND) &#123; return true; &#125; &#125; return false; 发送/取消闹钟Intent intent = new Intent(context, AlarmClockBroadcast.class); // FLAG_UPDATE_CURRENT：如果PendingIntent已经存在，保留它并且只替换它的extra数据。 // FLAG_CANCEL_CURRENT：如果PendingIntent已经存在，那么当前的PendingIntent会取消掉，然后产生一个新的PendingIntent。 PendingIntent pi = PendingIntent.getBroadcast(context, id, intent, PendingIntent.FLAG_UPDATE_CURRENT); AlarmManager alarmManager = (AlarmManager) context .getSystemService(Context.ALARM_SERVICE); // 设置闹钟,当前版本为19（4.4）或以上使用精准闹钟 if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123; alarmManager.setExact(AlarmManager.RTC_WAKEUP, nextTime, pi); &#125; else &#123; alarmManager.set(AlarmManager.RTC_WAKEUP, nextTime, pi); &#125;//取消闹钟 am.cancel(pi); 屏幕宽度高度DisplayMetrics dm = context.getResources().getDisplayMetrics();int width=dm.widthPixels;int height=dm.heightPixels; Android获取StatusBar高度int x = 0, statusBarHeight = 0;Class&lt;?&gt; c = Class.forName(&quot;com.android.internal.R$dimen&quot;);Object obj = c.newInstance();Field field = c.getField(&quot;status_bar_height&quot;);x = Integer.parseInt(field.get(obj).toString());statusBarHeight = context.getResources().getDimensionPixelSize(x); 获取设备的imsiTelephonyManager mTelephonyMgr = (TelephonyManager) context.getSystemService(Context.TELEPHONY_SERVICE);String imsi = mTelephonyMgr.getSubscriberId(); 获取设备的imeiTelephonyManager mTelephonyMgr = (TelephonyManager) context.getSystemService(Context.TELEPHONY_SERVICE);String imei = mTelephonyMgr.getDeviceId(); 获取应用版本和版本号String appVersion=context.getPackageManager().getPackageInfo(context.getPackageName(), 0).versionName;int appVersionCode=context.getPackageManager().getPackageInfo(context.getPackageName(), 0).versionCode; 获取屏幕亮度ContentResolver resolver = activity.getContentResolver();int nowBrightnessValue = android.provider.Settings.System.getInt( resolver, Settings.System.SCREEN_BRIGHTNESS); dp转pxDisplayMetrics dm = context.getResources().getDisplayMetrics();float density=dm.density;int px= (int) (dp * density + 0.5f); px转dpDisplayMetrics dm = context.getResources().getDisplayMetrics();float density=dm.density;int dp= (int) (px / density + 0.5f); sp转pxfinal float fontScale = context.getResources().getDisplayMetrics().scaledDensity;int px=(int) (spValue * fontScale + 0.5f); px转spfinal float fontScale = context.getResources().getDisplayMetrics().scaledDensity;int sp=(int) (pxValue / fontScale + 0.5f); 获取缓存文件File f =context.getExternalCacheDir(); 获取SD卡路径File f =context.getExternalCacheDir(); 获取根目录文件File f = context.getExternalFilesDir(&quot;&quot;); if(null==f)&#123; f = context.getFilesDir(); &#125; 写文件File file = new File(fileName); FileOutputStream fos = new FileOutputStream(file); byte [] bytes = write.getBytes();fos.write(bytes);fos.close(); 读文件FileInputStream fin = new FileInputStream(fileName);int length = fin.available(); byte [] buffer = new byte[length]; fin.read(buffer); fin.close(); 读取assets或资源文件//InputStream is = activity.getResources().openRawResource(id)InputStream is = activity.getAssets().open(filePath);InputStreamReader inputStreamReader;inputStreamReader = new InputStreamReader(is, &quot;utf-8&quot;);BufferedReader reader = new BufferedReader(inputStreamReader);StringBuffer sb = new StringBuffer(&quot;&quot;);String line;while ((line = reader.readLine()) != null) &#123; sb.append(line); sb.append(&quot;\\n&quot;); &#125;return sb.toString(); Bitmap保存文件FileOutputStream fos = new FileOutputStream(file, false);bitmap.compress(Bitmap.CompressFormat.JPEG,100, fos);fos.flush();fos.close(); Bitmap.Option的设置BitmapFactory.Options options = new BitmapFactory.Options(); options.inJustDecodeBounds = true;//是否只解析边界（true,则解析返回null，但是option有outHeight和outWidth） BitmapFactory.decodeFile(res, options); options.inPreferredConfig= Bitmap.Config.ARGB_8888;//图片解码时使用的颜色模式(默认8888) options.inSampleSize =2;//缩放倍数（整数） options.inJustDecodeBounds = false; options.inBitmap=bitmap;//是否重用该bitmap options.inPremultiplied=true;//如果设置了true(默认是true)，那么返回的图片RGB都会预乘透明通道A后的颜色, // 系统View或者Canvas绘制图片,不建议设置为fase,否则会抛出异常, // 这是因为系统会假定所有图像都预乘A通道的已简化绘制时间. // 设置inPremultiplied的同时,设置inScale会导致绘制的颜色不正确. options.inDither=true; // 设置是否抖动处理图片(android N 被废弃) options.inMutable=true; // 是否是mutable可变的(BitmapFactory.decodeResource是可变的，BitmapFactory.decodeFile是不可变的) options.inScaled=true; //是否缩放 options.inDensity=400; //设置位图的像素密度，即每英寸有多少个像素 options.inTargetDensity=400; //设置绘制位图的屏幕密度,与inScale和inDesity一起使用,来对位图进行放缩. options.inScreenDensity=400; //表示正在使用的实际屏幕的像素密度. Bitmap旋转角度ExifInterface exif = null; int degree = 0; try &#123; exif = new ExifInterface(imgPath); &#125; catch (IOException e) &#123; e.printStackTrace(); exif = null; &#125; if (exif != null) &#123; int ori = exif.getAttributeInt(ExifInterface.TAG_ORIENTATION, ExifInterface.ORIENTATION_UNDEFINED); switch (ori) &#123; case ExifInterface.ORIENTATION_ROTATE_90: degree = 90; break; case ExifInterface.ORIENTATION_ROTATE_180: degree = 180; break; case ExifInterface.ORIENTATION_ROTATE_270: degree = 270; break; default: degree = 0; break; &#125; &#125; MD5加密char hexDigits[]=&#123;&apos;0&apos;,&apos;1&apos;,&apos;2&apos;,&apos;3&apos;,&apos;4&apos;,&apos;5&apos;,&apos;6&apos;,&apos;7&apos;,&apos;8&apos;,&apos;9&apos;,&apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;D&apos;,&apos;E&apos;,&apos;F&apos;&#125;; try &#123; byte[] btInput = s.getBytes(); // get MessageDigest Object MessageDigest mdInst = MessageDigest.getInstance(&quot;MD5&quot;); mdInst.update(btInput); // get Ciphertext byte[] md = mdInst.digest(); // Ciphertext to byte int j = md.length; char str[] = new char[j * 2]; int k = 0; for (int i = 0; i &lt; j; i++) &#123; byte byte0 = md[i]; str[k++] = hexDigits[byte0 &gt;&gt;&gt; 4 &amp; 0xf]; str[k++] = hexDigits[byte0 &amp; 0xf]; &#125; return new String(str); &#125; catch (Exception e) &#123; e.printStackTrace(); return &quot;0&quot;; &#125; 监听锁屏开屏IntentFilter filter = new IntentFilter(); filter.addAction(Intent.ACTION_SCREEN_ON);//屏幕打开 filter.addAction(Intent.ACTION_SCREEN_OFF);//屏幕关闭 filter.addAction(Intent.ACTION_USER_PRESENT);//解锁 context.registerReceiver(receiver, filter); 直接判断屏幕是否关闭PowerManager pm = (PowerManager)context.getSystemService(Context.POWER_SERVICE);boolean isScreenOn = pm.isInteractive(); 设置StatusBar颜色if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) &#123; Window window = activity.getWindow(); window.addFlags(WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS); window.setStatusBarColor(ContextCompat.getColor(activity,colorId)); &#125; 设置StatusBar透明if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) &#123; activity.getWindow().addFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS); ((ViewGroup)activity.getWindow().getDecorView().findViewById(android.R.id.content)).getChildAt(0).setPadding(0, DeviceUtil.getStatusBarHeight(activity), 0, 0); &#125; 设置MIUI状态栏主题boolean result = false; if (window != null) &#123; Class clazz = window.getClass(); try &#123; int darkModeFlag = 0; Class layoutParams = Class.forName(&quot;android.view.MiuiWindowManager$LayoutParams&quot;); Field field = layoutParams.getField(&quot;EXTRA_FLAG_STATUS_BAR_DARK_MODE&quot;); darkModeFlag = field.getInt(layoutParams); Method extraFlagField = clazz.getMethod(&quot;setExtraFlags&quot;, int.class, int.class); if(dark)&#123; extraFlagField.invoke(window,darkModeFlag,darkModeFlag);//状态栏透明且黑色字体 &#125;else&#123; extraFlagField.invoke(window, 0, darkModeFlag);//清除黑色字体 &#125; result=true; &#125;catch (Exception e)&#123; &#125; &#125; return result; 设置Flyme状态栏主题boolean result = false; if (window != null) &#123; try &#123; WindowManager.LayoutParams lp = window.getAttributes(); Field darkFlag = WindowManager.LayoutParams.class .getDeclaredField(&quot;MEIZU_FLAG_DARK_STATUS_BAR_ICON&quot;); Field meizuFlags = WindowManager.LayoutParams.class .getDeclaredField(&quot;meizuFlags&quot;); darkFlag.setAccessible(true); meizuFlags.setAccessible(true); int bit = darkFlag.getInt(null); int value = meizuFlags.getInt(lp); if (dark) &#123; value |= bit; &#125; else &#123; value &amp;= ~bit; &#125; meizuFlags.setInt(lp, value); window.setAttributes(lp); result = true; &#125; catch (Exception e) &#123; &#125; &#125; return result; 时间Long类型转固定格式SimpleDateFormat simpleDateFormat=new SimpleDateFormat(style, Locale.getDefault());return simpleDateFormat.format(new Date(time));","categories":[{"name":"tips和坑","slug":"tips和坑","permalink":"https://earthwo.github.io/categories/tips和坑/"}],"tags":[{"name":"tips和坑","slug":"tips和坑","permalink":"https://earthwo.github.io/tags/tips和坑/"}]},{"title":"《Android进阶之光》读书笔记（三）","slug":"《Android进阶之光》读书笔记（三）","date":"2017-07-18T02:11:32.000Z","updated":"2019-03-11T07:35:22.329Z","comments":true,"path":"2017/07/18/《Android进阶之光》读书笔记（三）/","link":"","permalink":"https://earthwo.github.io/2017/07/18/《Android进阶之光》读书笔记（三）/","excerpt":"","text":"多线程线程基础继承是操作系统结构的基础，是程序在一个数据集合上运行的过程，是系统进行资源分配和调度的基本单位。进程可以被看做程序的实体，同样，它也是线程的容器。 线程是操作系统调度的最小单元，也叫做轻量级进程。 使用多线程的原因：使用多线程可以减少程序的响应时间；与进程相比，线程的创建和切换开销更小，同时在数据共享方面效率更高；多cpu或者多核计算机本身就支持多线程，多进程可以提高CPU的使用率;多线程可以简化程序的结构，使程序便于理解和维护。 线程的状态：New(新创建状态，刚创建为调用start方法)；Runnable(可运行状态，调用start方法)；Blocked(阻塞状态，线程被锁阻塞，暂时不活动)；Waiting(等待状态)；Timed waiting(超时等待状态，可以在指定的时间自行返回)；Terminated(终止状态，执行完毕退出或者捕获异常退出) 创建线程的方法：继承Thread类，重写run方法；实现Runnable接口，并实现run方法；实现Callable接口，重写call方法。call方法可以返回一个返回值，也可以抛出异常，同时Callable可以拿到一个Future,来监视目标线程的call方法，但是调用Future的get方法获取结果时，线程会堵塞，知道call方法返回结果。ExecutorService s=ExecutorService.newSingleThreadPool();Future f=s.submin(callable);f.get(); 三种方法中，推荐使用Runnable，因为没有加强和修改的情况下没有必要使用继承。 使用Lock的lock方法可以对方法中的代码块进行加锁，在通过unlock进行解锁。除此以外，可以通过newCondition方法获取条件对象，调用await方法阻塞当前线程，并放弃锁，等待其他线程调用Condition的signalAll()方法唤醒。 volatile修饰变量之后，当一个线程修改了变量的值时，该变量对其他线程会立刻可见。 volatile无法保证对变量的操作是原子性的，但是它保证是有序性的，即在volatile变量之前的语句不会到之后去执行。 使用volatile的条件：对变量的操作不依赖当前值（如自增，因为其不保证原子性）；没有包含在其他不等式中； volatile的使用场景：状态标志；双重检查模式 阻塞队列阻塞队列场景：当队列中没有数据的情况下，消费者端的所有线程都会被自动阻塞（挂起），直到有数据放入队列。当队列中填满数据的情况下，生产者端的所有线程都会被自动阻塞（挂起），直到有空的位置。 核心方法：offer(onject):表示如果可以的话，将object对象添加到BlockingQueue中，成功返回true，失败返回false，该方法不阻塞队列。offer(E 0,long timeout,TimeUnit unit):设定等待时间添加对象，如果时间到了还没有添加，则返回失败。put(object):添加对象，如果没有空间，则线程被阻塞。 poll(time):取走排在首位的对象，没有则等待相应的时间，取不到则返回nullpoll(long time,TimeUnit unit):取走排在首位的对象，没有则等待相应的时间，取不到则返回falsetake():取走排在首位的对象，没有则阻塞drainTo():一次性取走所有可用的数据对象 阻塞队列种类：1.ArrayBlockingQueue:使用数组实现有限的阻塞队列，并按照先进先出原则对元素进行排列。默认不保证线程公平（即先阻塞的先用）。保证公平原则的可以如下使用：ArrayBlockingQueue queue=new ArrayBlockingQueue(200,true); 2.LinkedBlockingQueue:使用链表的阻塞队列，按照先进先出原则对元素排列，内部有一个数据缓冲队列。当生产者往里面添加一个数据时会立即返回，数据会添加到队列中，直到队列满时才会阻塞。内部生产者和消费者采用独立的锁来控制数据同步。如果构造它时不指定其容量的大小，那么会产生一个近似于无限大的队列，会无限往里面添加时会消耗掉内存。3.PriorityBlockingQueue:支持优先级的无界队列，默认采取自然升序排列。可以自定义实现compareTo方法指定元素排序规则，也可以构造时传入Comparator来对元素进行排列。4.DelayQueue:支持延时获取元素的无界阻塞队列，里面使用PriorityBlockingQueue实现。队列中的元素必须实现Delayed接口来指定元素到期的时间，到期后才能被取走。5.SynchronousQueue:不存储元素的阻塞队列。即每一插入的操作必须要等待另一个取走操作，反过来也一样。6.LinkedTransferQueue:由链表结构组成的TransferQueue队列，其中实现了一个重要的接口TransferQueue,里面有3个重要的方法：(1)transfer(E e):若当前存在一个正在等待获取的消费者线程，则立即将元素给消费者，否则会将元素插入到队列尾部，并且等待进入阻塞状态，直到被取走。(2)tryTransfer(E e):若当前存在一个正在等待获取的消费者线程，则立即将元素给消费者,否则返回false，这个不是一个阻塞操作。(3)tryTransfer(E e，long timeout,TimeUnit unit):若当前存在一个正在等待获取的消费者线程，则立即将元素给消费者，否则会将元素插入到队列尾部，并且等待进入阻塞状态，直到被取走。若超时则返回false，不超时返回true。7.LinkedBlockingQueue:由链表组成的双向阻塞队列，可以从两端插入移出元素，所以多了addFirst、addLast、offerFirst、offerLast等方法。 线程池 ThreadPoolExecutor核心参数：corePoolSize:核心线程数。maximumPoolSize:最大线程数。keepAliveTime:非核心线程闲置超时时间。TimeUnit:参数时间单位。workQueue:任务队列。ThreadFactory:线程工厂，一般无需设置。RejectExecutionHandler:饱和策略。（CallerRunsPolicy:用调用者所在线程来处理任务；DiscardPolicy:不能执行任务，并将任务删除；DiscardOldestPolicy:丢弃队列最近任务，并执行当前任务）","categories":[{"name":"Android进阶之光","slug":"Android进阶之光","permalink":"https://earthwo.github.io/categories/Android进阶之光/"},{"name":"读书笔记","slug":"Android进阶之光/读书笔记","permalink":"https://earthwo.github.io/categories/Android进阶之光/读书笔记/"}],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://earthwo.github.io/tags/读书笔记/"},{"name":"Android进阶之光","slug":"Android进阶之光","permalink":"https://earthwo.github.io/tags/Android进阶之光/"}]},{"title":"《Android进阶之光》读书笔记(二)","slug":"《Android进阶之光》读书笔记（二）","date":"2017-07-17T01:54:05.000Z","updated":"2019-03-11T07:35:22.329Z","comments":true,"path":"2017/07/17/《Android进阶之光》读书笔记（二）/","link":"","permalink":"https://earthwo.github.io/2017/07/17/《Android进阶之光》读书笔记（二）/","excerpt":"","text":"View体系和自定义View点击事件坐标系getX():获取点击事件距离控件左边的距离，即视图坐标getY():获取点击事件距离控件左边的距离，即视图坐标getRawX():获取点击事件距离整个屏幕左边的距离，即绝对坐标getRawY():获取点击事件距离整个屏幕顶边的距离，即绝对坐标 View的滑动Android View移动的6中方法：layout()，offsetLeftAndRight()和offsetTopAndBottom()，LayoutParams，动画，scrollTo，scrollBy，scroller。offsetLeftAndRight()和offsetTopAndBottom()里面传递的是偏移量。 动画完成后，会回到原来的位置，我们可以在xml中加上fillAfter=&quot;true&quot;，使动画保持在最后一个状态。但是即使这样，view的实际位置依旧在原来的地方，view动画不能改变view的属性。 scrollTo和scrollBy移动的是View的内容，他们的移动可以看做是手机的移动。 Scroller本生不能实现View的滑动，需要跟View的computeScroll方法配合才能实现滑动效果。 Scroller在执行startScroll时 只是设置一些参数，同时调用View的onDraw方法，onDraw()方法会调用computeScroll方法。在computeScroll方法中，我们一般会调用computeScrollOffset()方法。这个方法会判断是否已经滑动完毕，如果未完毕，则根据时间和差值器获取当前滑动的位置。 View动画有一个大的缺陷，就是不具有交互性，所以View动画只能做普通的动画效果，要避免交互操作，但是优点是效率高，使用方便。属性动画可用的动画类型：translationX和translationY(延X或Y轴移动)，rotation、rotationX和rotationY(围绕支点进行旋转)，PrivotX和PrivotY(控制支点位置)，alpha(透明度)，x和y(View的最终位置)。 可以通过添加get和set方法添加属性动画的类型，在set方法中使用requestLayout()重新显示View。ValueAnimator不提供任何动画效果，它是一个数值发生器，用来产生一定的规律的数字，从而控制动画实现。 在使用组合动画AnimatorSet动画时，需要先用到AnimatorSet的play方法，该方法builder，builder使用建造者模式构建，当中包括4个方法：after(Animator animator):将现有动画插入到传入的动画之后执行after(long delay):将现有动画延迟指定时间执行before(Animator anim):将现有动画插入到指定动画前执行with(Animator anim):将现有动画和传入动画同时执行 组合动画除了使用AnimatorSet，还可以使用PropertyValuesHolder，当然，我们得结合OnjectAnimator.ofPropertyValuesHolder方法来使用，当然，这种方法动画只能同时进行。代码如下:PropertyValuesHolder holder1=PropertyValuesHolder.ofFloat(&quot;scaleX&quot;,1.0f,1,5f);...ObjectAnimator animator=ObjectAnimator.ofPropertyValuesHolder(view,holder1,holder2,holder3); 除此之外，还可以使用xml来进行动画，并通过AnimatorInflater.loadAnimator方法来加载动画。 View事件分发一个Activity对象包含一个Window对象，这个对象由PhoneWindow来实现。PhoneWindow将DecorView作为整个应用窗口的根View，而这个DecorView又将屏幕分为两个区域，一个是TitleView，另一个是ContentView，而我们的布局都展示在ContentView中。 事件分发的重要3个方法：dispatchTouchEvent(MotionEvent ev)————用来进行事件的分发onInterceptTouchEvent(MotionEvent ev)————用来进行事件的拦截（dispatchTouchEvent 方法中执行，在View中不存在，在Viewgroup中）onTouchEvent(MotionEvent ev)————用来处理点击事件 分发机制具体的流程：点击事件产生后，事件先会传递给当前的Activity，这会调用Activity的dispatchTouchEvent方法，具体的工作会交由PhoneWindow来完成。然后PhoneWindow再把工作交由DecorView，之后再有DecorView把事件处理交由根ViewGroup。 ViewGroup的dispatchTouchEvent方法中，首先要先判断事件是否是DOWN事件，如果是，则进行初始化。因为任何一个动作的开始都是由DOWN开始，所以要先初始化。接下来要判断是否这个ViewGroup是否拦截了这个事件，即mFirstTouchTarget是否为null，拦截了就为null，如果既不是DOWN事件，有拦截了（mFirstTouchTarget==null）那么intercept就直接为true，表示拦截了当次事件。当拦截的情况下。则调用onInterceptTouchEvent方法判断是否依旧拦截。子View可以通过requestDisallowInterceptTouchEvent来设置是否禁止拦截器拦截除了DOWN以外的事件。ViewGroup在传递子View的事件时，view的顺序是从上往下传递的，即最新添加的最先执行。同时，View的onTouchListener事件比onTouchEvent有更高的优先级，如果onTouchListener返回true，说明已经消费掉事件，那么onTouchEvent不再执行。 Activity显示的流程：当我们在调用startActivity时，会调用ActivityThread的hanldeLaunchActivity来创建activity。创建时会调用到oncreate方法，从而完成DecorView的创建。然后会执行handleResumeActivity方法，在这个方法里面，会调用Activity的onResume方法。随后会得到DecorView、WindowManager、ViewManager，并且调用其实现类WindowManagerImpl的addView。在WindowManagerImpl的addView方法中，调用WindowManagerGlobal的addView方法，而在这个方法中创建ViewRootImpl实例，并且调用setView()方法，将DecorView加载到Window中。同时，ViewRootImpl还会调用PerformTraveals方法，使ViewTree开始View的工作流程。该方法会依次执行performMeasure、performLayout、performDraw方法。 MeasureSpec代表了32位的int值，其中高2位是SpecMode(测量模式)，低30位是SpecSize(测量尺寸)。SpecMode的3种模式:UNSPECIFIED:未指定模式，View想多大就多大，不会受父容器限制。AT_MOST:最大模式，对应于wrap_content属性，子View的最终大小是父View指定的SpecSize，并且最大不能大于这个值。EXACTLY :精确模式，对应于match_content属性，父容器测量出View所需要的大小，就是SpecSize的值。","categories":[{"name":"Android进阶之光","slug":"Android进阶之光","permalink":"https://earthwo.github.io/categories/Android进阶之光/"},{"name":"读书笔记","slug":"Android进阶之光/读书笔记","permalink":"https://earthwo.github.io/categories/Android进阶之光/读书笔记/"}],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://earthwo.github.io/tags/读书笔记/"},{"name":"Android进阶之光","slug":"Android进阶之光","permalink":"https://earthwo.github.io/tags/Android进阶之光/"}]},{"title":"《Android进阶之光》读书笔记（一）","slug":"Android《进阶之光》读书笔记（一）","date":"2017-07-14T06:20:07.000Z","updated":"2019-03-11T07:35:22.314Z","comments":true,"path":"2017/07/14/Android《进阶之光》读书笔记（一）/","link":"","permalink":"https://earthwo.github.io/2017/07/14/Android《进阶之光》读书笔记（一）/","excerpt":"","text":"最近买了一本《Android进阶之光》，看了之后确实有很多之前不了解或是不熟悉的知识，所以记个笔记，以便之后更好的巩固和复习。 Android5.0新特性RecyclerView分割线RecyclerView在设置分割线的时候需要自定义（我之前在使用时一般都是直接在布局文件中放根线）。自定义RecyclerView的分割线时，需要创建一个class并且继承RecyclerView.ItemDecoration。继承该类之后需要重写onDraw方法。在该方法中，可以根据recyclerView排列情况，使用canvas绘制分割线。 折叠式和悬浮式Notification可以通过创建RemoteViews，在设置notification.bigContentView=remoteView;设置可折叠的通知。这类通知在外表看起来与普通的通知完全一样，滑动时，可将折叠部分展示出来。 如果直接将折叠的view设置到普通的content中：notification.contentView=remoteView;，那通知会显示一个被裁剪掉的view。可以通过设置PendingIntent pendingIntent=PendingIntent.getActivity (this,0,intent,PendingIntent.FLAG_CANCEL_CURRENT); builder.setFullScreenIntent (pendingIntent,true)显示悬浮式的notification。 Notification显示等级Notification有3个显示等级：VISIBILITY_PUBLIC:在任何情况下都能显示VISIBILITY_PRIVATE:只有在没有锁屏时显示通知VISIBILITY_SECRET:在pin和password等安全锁和没有锁屏的情况下才能够显示的通知。 palette取色器可以使用Palette来获取bitmap的色调，从而是界面色调一致。要使用Palette之前，要先引入包：compile &#39;com.android.support:palette-v7:25.0.0&#39;使用方法：Bitmap bitmap= BitmapFactory.decodeResource(getResources(),R.mipmap.image); Palette palette=Palette.from(bitmap).generate(); imageView.setImageDrawable(new ColorDrawable(palette.getVibrantSwatch().getRgb())); 其中generate方法有两个，一个同步，一个异步。 Android6.0新特性应用权限管理在之前的Android版本中，应用的权限会在应用安装时授予，而6.0以后，系统不会在安装时授予应用权限，所以应用不得不在需要使用这些权限时，逐个向用户请求。对于targetSdkVersion&lt;23的应用，系统依旧会授予所申请的权限，这也就保证了之前开发的应用不会在运行时因为权限问题崩溃（想偷懒的话可以这么干）。 Normal Permission与Danger PermissionAndroid6.0以后的版本中，权限分两钟，一种是Normal Permission，这类权限一般不涉及到用户隐私，比如网络权限、震动权限，系统会直接授予；另一种是Danger Permission，这种权限一般涉及到用户隐私。这类权限是以分组的形式给出，有如下分组：android.permission.group.CALENDAR (日历权限，包含读取日历和改写日历)android.permission.group.CAMERA (相机权限)android.permission.group.CONTACTS (联系人权限 包含读、写联系人)android.permission.group.LOCATION (位置权限 包含精确、粗略位置)android.permission.group.MICROPHONE (话筒权限）android.permission.group.PHONE (电话权限)android.permission.group.SENSORS (传感器权限)android.permission.group.SMS (短信权限)android.permission.group.STORAGE (存储权限 包含读、写sd卡)这些权限组中，只要一个被授予了，那么整组都会被授予。 我们可以通过ActivityCompat.checkSelfPermission或ContextCompat.checkSelfPermission来检查权限：if(ContextCompat.checkSelfPermission(context, Manifest.permission.WRITE_EXTERNAL_STORAGE) == PackageManager.PERMISSION_GRANTED)&#123; //do &#125;else&#123; //申请权限 ActivityCompat.requestPermissions(activity, new String[]&#123;Manifest.permission.WRITE_EXTERNAL_STORAGE&#125;, 0); &#125; 同时在Activity中重写onRequestPermissionsResult方法，当requestCode返回为1时，说明权限申请成功。 Android7.0新特性多窗口模式当长按菜单键时，应用进入多窗口模式。activity的生命周期如下:onPause-&gt;onStop-&gt;onDestory-&gt;onCreate-&gt;onStart-&gt;onPause，当我们点击该窗口时，会进入onResume，这里可以看到，开启多窗口时，activity会先销毁，在创建。当我们推出多窗口模式时也一样，一用会先销毁，再创建，但是会直接进入到onResume中。 我们可以在Application中设置android:resizeableActivity=&quot;false&quot;禁止多窗口模式。但是当targetSdkVersion&lt;24时，该设置会无效，在这种情况下，我们可以这只activity android:screenOrientation=&quot;portrait&quot;禁止屏幕旋转，来达到禁止多窗口模式的效果。 Material DesignMaterial Design相关控件SnakeBar可以通过setAction来添加操作，同时，make方法中的view参数是Snake的父控件，可以确保其显示在正确的位置（不过我试了发现不管传什么view其都显示在最下面）。 TextInputLayout里面有且只有一个edittext,它可以使edittext在点击后依旧在输入框上面显示hint内容。除此之外，更加友好的提示错误信息：textInputLayout.setErrorEnable(true);textInputLayout.setError(“错误信息”); 这样可以在输入框下面显示错误提示hint的颜色可以通过修改colorAccent修改。 TabLayout可以设置app:tabMode=&quot;scrollable&quot;来使其可以滑动，当不设置或者设置为app:tabMode=&quot;fixed时，所有的item都会挤在一个页面宽度中。 NaviationView实现侧滑菜单功能，它主要是与DrawerLayout同用。它可以通过设置app:headerLayout=&quot;&quot;引入头文件，app:menu=&quot;&quot;引入菜单文件，菜单文件中可以通过设置group来设置分组，group可以设置”android:checkableBehavior=&quot;single&quot;来设置只能选一个。 Coordinatorlayout可以是toolbar随着滑动消失，toolbar需要设置app:layout_scrollFlags=&quot;scroll|enterAlways&quot;(toolbar要包含在AppBarLayout中)。Coordinatorlayout配合CollapsingToolbarLayout可以使Toolbar折叠，代码如下：&lt;android.support.design.widget.CoordinatorLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:orientation=&quot;vertical&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;android.support.design.widget.AppBarLayout android:id=&quot;@+id/app_bar&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;200dp&quot; android:fitsSystemWindows=&quot;true&quot; android:theme=&quot;@style/AppTheme.AppBarOverlay&quot;&gt; &lt;android.support.design.widget.CollapsingToolbarLayout android:id=&quot;@+id/toolbar_layout&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:fitsSystemWindows=&quot;true&quot; app:contentScrim=&quot;#f24242&quot; android:minHeight=&quot;100dp&quot; app:layout_scrollFlags=&quot;scroll|exitUntilCollapsed&quot;&gt; &lt;LinearLayout ... &lt;/LinearLayout&gt; &lt;android.support.v7.widget.Toolbar android:id=&quot;@+id/toolbar&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;50dp&quot; app:layout_collapseMode=&quot;pin&quot; app:popupTheme=&quot;@style/AppTheme.PopupOverlay&quot; /&gt; &lt;/android.support.design.widget.CollapsingToolbarLayout&gt; &lt;/android.support.design.widget.AppBarLayout&gt; &lt;android.support.v7.widget.RecyclerView android:id=&quot;@+id/recycle&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; app:layout_behavior=&quot;@string/appbar_scrolling_view_behavior&quot;&gt;&lt;/android.support.v7.widget.RecyclerView&gt; 解释几个CollapsingToolbarLayout关键的参数：app:contentScrim=&quot;#f24242&quot;设置收缩后的顶部颜色app:expandedTitleGravity=&quot;center&quot;表示展开后文字的位置，默认是left|bottomapp:layout_scrollFlags= &quot;scroll|exitUntilCollapsed&quot;表示既随着滑动收缩，又保留在顶部，如果设置为app:layout_scrollFlags= &quot;scroll|enterAlwaysCollapsed&quot;或app:layout_scrollFlags= &quot;scroll|enterAlways&quot;，则表示既收缩，但是不保留，最终会划走。 自定义Behavior自定义Behavior需要继承CollapsingToolbarLayout.Behavior&lt;View类，实现方法主要分两种，一种是view监听CollapsingToolbarLayout状态，这种情况时我们需要重写onStartNestedScroll、和onNestedPreScroll方法；另一种是监听另一个view的变化，这种情况时需要重写layoutDependsOn方法和onDependentViewChange方法。public boolean onStartNestedScroll(CoordinatorLayout coordinatorLayout, View child, View directTargetChild, View target, int nestedScrollAxes) &#123; return false; &#125; public void onNestedPreScroll(CoordinatorLayout coordinatorLayout, View child, View target, int dx, int dy, int[] consumed) &#123; // Do nothing &#125; onStartNestedScroll方法的返回值表示这次滑动我们是否关心，而onNestedScrollAccepted表示滑动时的变化。 onNestedScrollAccepted方法的child表示设置了当前Behavior的view，dx,dy表示滑动的距离。public boolean layoutDependsOn(CoordinatorLayout parent, View child, View dependency) &#123; return false; &#125; public boolean onDependentViewChanged(CoordinatorLayout parent, View child, View dependency) &#123; return false; &#125; layoutDependsOn返回我们是否需要对本次滑动关心，而onDependentViewChanged表示滑动时的变化。layoutDependsOn和onDependentViewChanged方法中的child表示设置Behavior的view，dependency表示我们关心的view","categories":[{"name":"Android进阶之光","slug":"Android进阶之光","permalink":"https://earthwo.github.io/categories/Android进阶之光/"},{"name":"读书笔记","slug":"Android进阶之光/读书笔记","permalink":"https://earthwo.github.io/categories/Android进阶之光/读书笔记/"}],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://earthwo.github.io/tags/读书笔记/"},{"name":"Android进阶之光","slug":"Android进阶之光","permalink":"https://earthwo.github.io/tags/Android进阶之光/"}]},{"title":"android开发小tip与踩过的坑（持续更新）","slug":"android开发小tip与踩过的坑（持续更新）","date":"2017-07-11T03:19:28.000Z","updated":"2019-03-11T07:35:22.323Z","comments":true,"path":"2017/07/11/android开发小tip与踩过的坑（持续更新）/","link":"","permalink":"https://earthwo.github.io/2017/07/11/android开发小tip与踩过的坑（持续更新）/","excerpt":"","text":"这篇文章主要是记录自己在开发过程中遇到的一些小tip，别看这些东西很细微，有时候可以解决大麻烦，有些对于开发非常重要。还有就是自己曾经踩过的坑，我觉得都有必要记录下来。这些坑虽然不是每个人都会踩(有些确实是自己太笨了才踩的)，但是既然我踩了，那可能还会有人踩，这样既惊醒自己，也可帮助他人。文章内容持续更新，也没有具体的分类，遇到一个添加一个。 greendao 生成代码很多人都用过greendao，集成greendao时，会自动生成DaoMaster和DaoSession等文件，这些文件至关重要。但是前段时间我在集成后竟然无法生成这些文件，找了半天也不知道原因。后来才知道原因：在配置完greendao之后，必须有实体作为greendao的数据实体，如果一个实体都没有，它是不会生成DaoMaster等文件的；同时，greendao目前好像还不支持kotlin，无法将kotlin的数据类作为实体，还是要将实体卸载java文件中。 greendao 主键自增长greendao可以设置主键自增长，但是我在用时就在想，如果没有没有主键，那么long类型不是为0吗，那还是有值呀。后来在使用时果然出现问题。实际上greendao在使用主键自增长是，主键类型必须是Long,而不是long，这种主键就可以为null了。 service启动activity当在Service中启动activity时，需要添加it.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); 因为在service中启动的activity是没有栈的，启动时会程序判断当前是否是在service中启动且包含FLAG_ACTIVITY_NEW_TASK。这样启动的activity相当是singleInstance模式。但是如果你在activity中配置了singleTask模式，就会依旧在task中启动一个。 synchronized使用synchronized在锁代码块时其实锁的是对象，所以如果你在锁之前完全没有使用该对象，就白锁了。 位运算&lt;&lt; : 左移运算符，num &lt;&lt; 1,相当于num乘以2(&lt;&lt; 2 相当于乘以4)&gt;&gt; : 右移运算符，num &gt;&gt; 1,相当于num除以2&gt;&gt;&gt; : 无符号右移，忽略符号位，空位都以0补齐 位运算比普通的运算块 ImageView scaleTypecenter:图片居中，不缩放，不放大，超过了就截取中间的，不超过就空着。centerInside:图片居中，可缩放，不放大，超过了就缩小放置在中间，不超过就空着。centerCrop:图片居中,可缩放，可放大，超过了就将缩小到有一边与ImageView边相等，不超过放大到最小边与ImageView边相等，保证图片完全充满ImageViewfitCenter:图片居中，可缩放，可放大，缩小放大到自己有一边到ImageView边界为止。fitXY:可放大，可缩放，将自己完全充满ImageView，可以变形。fitStart:可放大，可缩放，缩小放大到自己有一边到ImageView边界为止，同时靠左靠上。fitEnd:可放大，可缩放，缩小放大到自己有一边到ImageView边界为止，同时靠右靠下。 FragmentPagerAdapter和FragmentStatePagerAdapterFragmentPagerAdapter在滑动时，destroyItem只会将那些不可见的Fragment做detach处理，即只是从屏幕上移除，并不会销毁。同时即使使用notifyDataSetChanged，并且Fragment的数量减少，原来已有的Fragment也不会重新创建。所以这种方法适合item少量的情况。 FragmentStatePagerAdapter在执行destroyItem时，会将那些不可见的Fragment销毁，同时会保存其状态。在再次需要显示的时候回重新创建，并且传入之前的状态。所以这种方式适合item数量比较大时的情况，可以减少fragment的内存，但是在创建和销毁时会有所消耗。 ViewPager+Fragment禁止预加载延迟当ViewPager.setOffscreenPageLimit(0);当设置预加载的page&lt;1时，程序还是会设置默认的预加载页面为1，所以该方法不可行。在FragmentPagerAdapter、FragmentStatePagerAdapter的instantiateItem方法中，都有将未显示的fragment设置为不可见状态：fragment.setUserVisibleHint(false);将可见的fragment设置为可见状态：fragment.setUserVisibleHint(true);所以我们只需要在fragment中重写setUserVisibleHint方法，可见时才加载布局。甚至可以使用ViewStub，在可见时初始化整个布局。 ViewPaper直接跳转到后面item写一个Scroller类继承Scroller，重写其startScroll方法，将其滑动的时间设置为0。@Override public void startScroll(int startX, int startY, int dx, int dy, int duration) &#123; super.startScroll(startX, startY, dx, dy, 0); &#125; 使用反射的方法，将ViewPager的Scroller替换掉：Class c=viewPager.getClass();Field field=c.getDeclaredField(&quot;mScroller&quot;);field.setAccessible(true);field.set(viewPager,scroll); 这种方式会使普通的滑动的时间也为0，所以在具体使用时，可以通过滑动的具体情况，在跳转多页时才将时间设置0。 ProGuard的常用语法-optimizationpasses 5 代码优化次数，android一般为5，理论上越多越好，到时多了混淆时间就长了，而且优化到无法再优化时就停止了，因此不一定是写着的次数-libraryjars class_path 避免混淆应用的依赖包，如android-support-v4-keep [,modifier,…] class_specification 不混淆某些类。例子：-keep public class javax.**-keep enum com.facebook.**-keep class com.baidu.** &#123; *; &#125; -keepclassmembers [,modifier,…] class_specification 不混淆类的成员。例子：-keepclassmembers class * extends android.app.Activity&#123; public void *(android.view.View); //保持activity类里面的void方法，参数为View的不混淆&#125; -keepclasseswithmembers [,modifier,…] class_specification 不混淆类及其成员。例子：-keepclasseswithmembers class * &#123; //不混淆有该init方法和该类 public &lt;init&gt;(android.content.Context); &#125; -keepnames class_specification 不混淆类及其成员名。例子：-keepnames class * implements java.io.Serializable //不混淆实现Serializable接口的类# parcelable 不被混淆 -keep class * implements android.os.Parcelable &#123;//不混淆实现Parcelable接口的类 public static finalandroid.os.ParcelableCreator *; &#125; -keepattributes {attribute_name,…} 不混淆给定的可选属性。例子：-keepattributes *Annotation*//不混淆注解-keepattributes Signature//不混淆泛型-keepattributes SourceFile,LineNumberTable//不混淆异常时的代码行 -keepclassmembernames class_specification 不混淆类的成员名。-keepclasseswithmembernames class_specification 不混淆类及其成员名-keepclasseswithmembernames class * &#123; //不混淆自定义View之类的类 public &lt;init&gt;(android.content.Context, android.util.AttributeSet); &#125; assumenosideeffects class_specification 假设调用不产生任何影响，在proguard代码优化时会将该调用remove掉。如Log等等 -dontwarn [class_filter] 不提示warnning-dontusemixedcaseclassnames //混淆时不产生混合大小写的类名-dontskipnonpubliclibraryclasses //指定不去忽略非公共的库类-dontpreverify //不预校验-verbose //显示混淆的log，帮助排错-optimizations !code/simplification/arithmetic,!field/,!class/merging/ //代码混淆采用的算法，一般不改变，使用谷歌默认算法即可 Jobscheduler使用在Jobscheduler使用过程中，设置延时setMinimumLatency和设置最大延时setOverrideDeadline，不同手机延时时间可能会出现偏差。比如测试一台sony手机时，延时最小为5s，同时，一旦设置了最大延时则普通的延时时间无效，而如果单设置延时，延时时间也不一定准，而这些在模拟器上则完全没有出现。一旦设置了这两个延时，则无法再设置重复时间，不然会报错，一旦设置了重启设备任务继续时setPersisted，需要配置系统开机事件的权限。当onStopJob返回true，或者jobFinished(params, true)时，系统会在满足条件是重新调用onStartJob，可以设置setBackoffCriteria设置等待时间和时间策略，默认等待时间是30s，策略是指数增长。 BroadCast权限问题1.自定义权限时，名字不是任意命名的，最好是包名.名字的形式（经测试，a.b.名字也是可以的，但是直接名字不行）。2.定义权限时，需要在发送方和接收方都定义权限和申请权限。&lt;uses-permission android:name=&quot;c.a.SEND_MESSAGE&quot; /&gt;&lt;permission android:name=&quot;c.a.SEND_MESSAGE&quot; /&gt; 3.发送带权限的Broadcast时，说明应用要有该权限才能发出这条通知，但是任何普通的receiver都能接收。4.Receiver配置权限后，说明只有有该权限的其他应用的通知，它才能接收到，但是自己的通知还是可以不传权限收到。Broadcast其他tip：静态注册的Receiver，要不是单独一个文件的，要不是public static的；StickyBroadcast已经被废弃。 Service进程service启动时可以设置进程android:process=&quot;:web&quot;。当在其他进程启动Service时，如果该Service没有单独设置进程，那么该Service依旧在主进程中。","categories":[{"name":"tips和坑","slug":"tips和坑","permalink":"https://earthwo.github.io/categories/tips和坑/"}],"tags":[{"name":"tips和坑","slug":"tips和坑","permalink":"https://earthwo.github.io/tags/tips和坑/"}]},{"title":"BottomNavigationView分析","slug":"BottomNavigationView分析","date":"2017-07-03T06:27:51.000Z","updated":"2019-03-11T07:35:22.314Z","comments":true,"path":"2017/07/03/BottomNavigationView分析/","link":"","permalink":"https://earthwo.github.io/2017/07/03/BottomNavigationView分析/","excerpt":"","text":"Bottom-Navigation是谷歌官方发布的android底部状态栏，它的动画效果非常的漂亮，看起来非常的让人赏心悦目。为了能够拥有相同的用户体验，google对它有着严格的设计标准，具体的要求和实例请看：官方文档。同时，谷歌还推出了BottomNavigationView来实现这种设计。那下面就来看看BottomNavigationView是如何实现的。 简单使用通过BottomNavigationView的官方文档，我们可以看到，BottomNavigationView是在version 25.0.0以后被添加进来的，所以在此之前的版本，要使用就需要添加的包：compile &#39;com.android.support:design:25.0.0&#39;。同时，官方还给出了简单的使用实例，这里就不在介绍了。&lt;android.support.design.widget.BottomNavigationView xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:id=&quot;@+id/navigation&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;56dp&quot; android:layout_gravity=&quot;start&quot; app:menu=&quot;@menu/my_navigation_items&quot; /&gt; res/menu/my_navigation_items.xml: &lt;menu xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;item android:id=&quot;@+id/action_search&quot; android:title=&quot;@string/menu_search&quot; android:icon=&quot;@drawable/ic_search&quot; /&gt; &lt;item android:id=&quot;@+id/action_settings&quot; android:title=&quot;@string/menu_settings&quot; android:icon=&quot;@drawable/ic_add&quot; /&gt; &lt;item android:id=&quot;@+id/action_navigation&quot; android:title=&quot;@string/menu_navigation&quot; android:icon=&quot;@drawable/ic_action_navigation_menu&quot; /&gt; &lt;/menu&gt; 这里我们看到，BottomNavigationView的高度被限定在56dp，这个值是在官方的设计文档中明确要求的，因此当你使用大于56dp的高度时，就会有一部分空白区域流出来，同时也完全不建议使用过小的高度，这样，内部的图标或文字都可能会被裁剪掉部分。 实现原理BottomNavigationView分析通过阅读BottomNavigationView源码，我们看到BottomNavigationView直接通过继承FrameLayout实现。它里面最重要的有3个对象:MenuBuilder，BottomNavigationMenuView，BottomNavigationPresenter。从他们的命名上，我们就可以知道，MenuBuilder主要是创建一个menu，通过xml文件，创建menu后，再讲其中的item的title、icon、id等信息传递给BottomNavigationMenuView去创建最终我们看到的view，同时，也将view的点击事件通过menu的回调传回到BottomNavigationMenuView；BottomNavigationPresenter则主要是进行一些逻辑的操作，比如初始化BottomNavigationMenuView，更新BottomNavigationMenuView等；BottomNavigationMenuView则是具体我们所看到的view，它通过MenuBuilder来创建item，同时根据click来进行样式的变化。除了这三个之外，BottomNavigationView其他部分都是一些参数的设置和初始化，这边就不再介绍了。 BottomNavigationMenuView分析通过上面我们可以看到，所有的一切都是围绕BottomNavigationMenuView所展开，所以我们重点通过BottomNavigationMenuView来了解整个流程。 初始化在BottomNavigationView的构造方法里，程序在创建完这3个对象后，首先对MenuBuilder进行初始化：public void inflateMenu(int resId) &#123; mPresenter.setUpdateSuspended(true); getMenuInflater().inflate(resId, mMenu);//初始化menu mPresenter.initForMenu(getContext(), mMenu); mPresenter.setUpdateSuspended(false); mPresenter.updateMenuView(true); &#125; 在初始化menu前，先对BottomNavigationPresenter进行暂停，同样的事情还出现在BottomNavigationMenuView初始化各个item和每次进行动画时。这样做可以避免在初始化和动画时同时在进行更新动画而冲突。初始化MenuBuilder后，再通过BottomNavigationPresenter对BottomNavigationMenuView进行初始化：@Override public void initForMenu(Context context, MenuBuilder menu) &#123; mMenuView.initialize(mMenu); mMenu = menu; &#125; 同时进行界面创建：@Override public void updateMenuView(boolean cleared) &#123; if (mUpdateSuspended) return; if (cleared) &#123; mMenuView.buildMenuView(); &#125; else &#123; mMenuView.updateMenuView(); &#125; &#125; 具体界面创建的方法：public void buildMenuView() &#123; if (mButtons != null) &#123; for (BottomNavigationItemView item : mButtons) &#123; sItemPool.release(item); &#125; &#125; removeAllViews(); mButtons = new BottomNavigationItemView[mMenu.size()]; mShiftingMode = mMenu.size() &gt; 3; for (int i = 0; i &lt; mMenu.size(); i++) &#123; mPresenter.setUpdateSuspended(true); mMenu.getItem(i).setCheckable(true); mPresenter.setUpdateSuspended(false); BottomNavigationItemView child = getNewItem(); mButtons[i] = child; child.setIconTintList(mItemIconTint); child.setTextColor(mItemTextColor); child.setItemBackground(mItemBackgroundRes); child.setShiftingMode(mShiftingMode); child.initialize((MenuItemImpl) mMenu.getItem(i), 0); child.setItemPosition(i); child.setOnClickListener(mOnClickListener); addView(child); &#125; &#125; 这里我们看到有一个池sItemPool，当界面重构时，会把原来已有的BottomNavigationItemView放到池中，再次创建新界面时又从池中取出，这样做可以减少对象的创建数量。同时，程序会根据menu的item数量创建BottomNavigationItemView数组，而BottomNavigationItemView就是显示的每一个菜单按钮。里面有3个控件：LayoutInflater.from(context).inflate(R.layout.design_bottom_navigation_item, this, true); setBackgroundResource(R.drawable.design_bottom_navigation_item_background); mIcon = (ImageView) findViewById(R.id.icon); mSmallLabel = (TextView) findViewById(R.id.smallLabel); mLargeLabel = (TextView) findViewById(R.id.largeLabel); 这些就是一个item所显示的内容。 onMeasure和onLayout在BottomNavigationMenuView初始化完成之后，就要对里面的控件进行测量和排列。在onMeasure方法中，做的主要是两件是：1是对里面每一个BottomNavigationItemView都进行宽高的测量；2是设置整个BottomNavigationMenuView的宽高。第一步的测量还分两种情况，当item的数量大于3个时，mShiftingMode=true。在这种情况下，选中的item和其他的items的宽度是不一样的，所以程序要先计算出选中的item的宽度，然后根据它计算其他items的宽度；第二种情况是当items的数量&lt;=3个时，每个item的宽度是一样的，所以只需要根据总宽度/items的数量就可以计算出item的宽度。第二步在测量整个view的宽度时，程序将先前的所有可见的items的宽度加起来作为整个BottomNavigationMenuView的宽度（目前也没有发现有什么可能会使item不可见）。onLayout方法就比较简单，它根据之前计算好的每一个item的宽高，从左往右或从右往左放置每一个item的位置。@Override protected void onLayout(boolean changed, int left, int top, int right, int bottom) &#123; final int count = getChildCount(); final int width = right - left; final int height = bottom - top; int used = 0; for (int i = 0; i &lt; count; i++) &#123; final View child = getChildAt(i); if (child.getVisibility() == GONE) &#123; continue; &#125; if (ViewCompat.getLayoutDirection(this) == ViewCompat.LAYOUT_DIRECTION_RTL) &#123; child.layout(width - used - child.getMeasuredWidth(), 0, width - used, height); &#125; else &#123; child.layout(used, 0, child.getMeasuredWidth() + used, height); &#125; used += child.getMeasuredWidth(); &#125; &#125; 点击动画和回调在初始化BottomNavigationMenuView时，每一个BottomNavigationItemView都会添加onClickListener:mOnClickListener = new OnClickListener() &#123; @Override public void onClick(View v) &#123; final BottomNavigationItemView itemView = (BottomNavigationItemView) v; final int itemPosition = itemView.getItemPosition(); activateNewButton(itemPosition); mMenu.performItemAction(itemView.getItemData(), mPresenter, 0); &#125; &#125;; 关键的代码是后面两句，其中一句是执行点击的动画，最后一句是执行menu点击的回调。那我们分别来看一下。private void activateNewButton(int newButton) &#123; if (mActiveButton == newButton) return; mAnimationHelper.beginDelayedTransition(this); mPresenter.setUpdateSuspended(true); mButtons[mActiveButton].setChecked(false); mButtons[newButton].setChecked(true); mPresenter.setUpdateSuspended(false); mActiveButton = newButton; &#125; 在这里我们看到，主要的操作就是将原来的BottomNavigationItemViewcheck设置为false，将点击的设置为true，那我们来看BottomNavigationItemView的setCheck方法里又做了什么。setCheck方法也是整个BottomNavigationItemView最核心的方法。mItemData.setChecked(checked); ViewCompat.setPivotX(mLargeLabel, mLargeLabel.getWidth() / 2); ViewCompat.setPivotY(mLargeLabel, mLargeLabel.getBaseline()); ViewCompat.setPivotX(mSmallLabel, mSmallLabel.getWidth() / 2); ViewCompat.setPivotY(mSmallLabel, mSmallLabel.getBaseline()); 首先，它将设置menu的item是否为点击；设置两个文本的动画原点。if (checked) &#123; LayoutParams iconParams = (LayoutParams) mIcon.getLayoutParams(); iconParams.gravity = Gravity.CENTER_HORIZONTAL | Gravity.TOP; iconParams.topMargin = mDefaultMargin; mIcon.setLayoutParams(iconParams); mLargeLabel.setVisibility(VISIBLE); ViewCompat.setScaleX(mLargeLabel, 1f); ViewCompat.setScaleY(mLargeLabel, 1f); &#125; else &#123; LayoutParams iconParams = (LayoutParams) mIcon.getLayoutParams(); iconParams.gravity = Gravity.CENTER; iconParams.topMargin = mDefaultMargin; mIcon.setLayoutParams(iconParams); mLargeLabel.setVisibility(INVISIBLE); ViewCompat.setScaleX(mLargeLabel, 0.5f); ViewCompat.setScaleY(mLargeLabel, 0.5f); &#125; mSmallLabel.setVisibility(INVISIBLE); 在有移动的情况下，对选中和非选中都进行动画操作，同时，大文本显示，小文本隐藏。if (checked) &#123; LayoutParams iconParams = (LayoutParams) mIcon.getLayoutParams(); iconParams.gravity = Gravity.CENTER_HORIZONTAL | Gravity.TOP; iconParams.topMargin = mDefaultMargin + mShiftAmount; mIcon.setLayoutParams(iconParams); mLargeLabel.setVisibility(VISIBLE); mSmallLabel.setVisibility(INVISIBLE); ViewCompat.setScaleX(mLargeLabel, 1f); ViewCompat.setScaleY(mLargeLabel, 1f); ViewCompat.setScaleX(mSmallLabel, mScaleUpFactor); ViewCompat.setScaleY(mSmallLabel, mScaleUpFactor); &#125; else &#123; LayoutParams iconParams = (LayoutParams) mIcon.getLayoutParams(); iconParams.gravity = Gravity.CENTER_HORIZONTAL | Gravity.TOP; iconParams.topMargin = mDefaultMargin; mIcon.setLayoutParams(iconParams); mLargeLabel.setVisibility(INVISIBLE); mSmallLabel.setVisibility(VISIBLE); ViewCompat.setScaleX(mLargeLabel, mScaleDownFactor); ViewCompat.setScaleY(mLargeLabel, mScaleDownFactor); ViewCompat.setScaleX(mSmallLabel, 1f); ViewCompat.setScaleY(mSmallLabel, 1f); &#125; 在不移动情况下，对icon的上距进行变化，同时选中时小文本变大，不选择时大文本变小文本。在点击回调时，执行mMenu.performItemAction (itemView.getItemData(), mPresenter, 0);代码，该代码会调用MenuItemImplinvoke方法，并且最终调用callback回调。","categories":[{"name":"源码阅读","slug":"源码阅读","permalink":"https://earthwo.github.io/categories/源码阅读/"}],"tags":[{"name":"源码阅读","slug":"源码阅读","permalink":"https://earthwo.github.io/tags/源码阅读/"}]},{"title":"okhttp源码分析（一）","slug":"Okhttp源码分析","date":"2017-06-22T06:09:09.000Z","updated":"2019-03-11T07:35:22.320Z","comments":true,"path":"2017/06/22/Okhttp源码分析/","link":"","permalink":"https://earthwo.github.io/2017/06/22/Okhttp源码分析/","excerpt":"","text":"OkHttp是一款优秀的HTTP框架，它支持get请求和post请求，支持基于Http的文件上传和下载，支持加载图片，支持下载文件透明的GZIP压缩，支持响应缓存避免重复的网络请求，支持使用连接池来降低响应延迟问题。 基本用例首先看一下它的基本使用：(具体的使用方法请看官方文档)OkHttpClient client = new OkHttpClient(); Request request = new Request.Builder() .url(&quot;https://www.baidu.com&quot;) .build(); Response response = client.newCall(request).execute(); OkHttpClient解析通过上面的代码我们可以看到，基本的步骤为：创建OkHttpClient对象-&gt;创建请求Request-&gt;创建新的Call并通过它请求网络。那我们先来看看第一步创建的OkHttpClient。OkHttpClient看起来可以通过构造函数直接创建，但是通过源码你可以发现，其实它是由构造模式Builder创建的。public OkHttpClient() &#123; this(new Builder());&#125; 那继续看这个Builder。Builder在创建时默认设置一大堆与网络请求相关的参数：public Builder() &#123; dispatcher = new Dispatcher();//分发器 protocols = DEFAULT_PROTOCOLS; //协议 connectionSpecs = DEFAULT_CONNECTION_SPECS;//传输层版本和连接协议 eventListenerFactory = EventListener.factory(EventListener.NONE);//event工厂 proxySelector = ProxySelector.getDefault();//代理选择 cookieJar = CookieJar.NO_COOKIES;//代理选择 socketFactory = SocketFactory.getDefault();//socket 工厂 hostnameVerifier = OkHostnameVerifier.INSTANCE;// 主机名字确认 certificatePinner = CertificatePinner.DEFAULT; // 验证确认响应证书 适用 HTTPS 请求连接的主机名。 proxyAuthenticator = Authenticator.NONE;//代理身份验证 authenticator = Authenticator.NONE;// 本地身份验证 connectionPool = new ConnectionPool(); //连接池,复用连接 dns = Dns.SYSTEM;//dns followSslRedirects = true;//安全套接层重定向 followRedirects = true;//本地重定向 retryOnConnectionFailure = true;//重试连接失败 connectTimeout = 10_000;//连接超时 readTimeout = 10_000;//read超时 writeTimeout = 10_000;//write超时 pingInterval = 0;// &#125; 这里的各种参数，可以根据请求要求在请求发起前对builder进行设置，这里就不展开介绍。 Request解析Request类主要是封装了请求的相关参数，比如url，header，请求参数body，请求类型等等，这些都可以通过Request.Builder设置，这里就不多介绍了。 Http请求在设置完相关的参数之后，就可以发起Http请求了。OkHttpClient实现了Call.Factory，并且实现其中的方法newCall(Request request)，该方法返回一个RealCall对象，这个对象就是可以随时执行的http请求。执行请求有两种，同步请求和一步请求，那我们先来看看同步请求。 同步网络请求我们先来看看RealCall中的execute方法。@Override public Response execute() throws IOException &#123; synchronized (this) &#123; if (executed) throw new IllegalStateException(&quot;Already Executed&quot;); executed = true; &#125; captureCallStackTrace(); try &#123; client.dispatcher().executed(this); Response result = getResponseWithInterceptorChain(); if (result == null) throw new IOException(&quot;Canceled&quot;); return result; &#125; finally &#123; client.dispatcher().finished(this); &#125;&#125; 这里首先要保证一个Call只能执行一次，当多次执行时会抛出异常，其次还会去设置捕获Call的异常，然后调用OkHttpClient的dispatcher，设置当前请求的执行状态。因为在同步请求中dispatcher只标记请求状态，比如开始请求和请求完成，所以在这里就不多介绍，dispatcher更多的用在异步请求中。最后是执行getResponseWithInterceptorChain方法。Response getResponseWithInterceptorChain() throws IOException &#123; // Build a full stack of interceptors. List&lt;Interceptor&gt; interceptors = new ArrayList&lt;&gt;(); interceptors.addAll(client.interceptors()); interceptors.add(retryAndFollowUpInterceptor); interceptors.add(new BridgeInterceptor(client.cookieJar())); interceptors.add(new CacheInterceptor(client.internalCache())); interceptors.add(new ConnectInterceptor(client)); if (!forWebSocket) &#123; interceptors.addAll(client.networkInterceptors()); &#125; interceptors.add(new CallServerInterceptor(forWebSocket)); Interceptor.Chain chain = new RealInterceptorChain( interceptors, null, null, null, 0, originalRequest); return chain.proceed(originalRequest); &#125; 这里用到了很多的拦截器Interceptor。事实上，Interceptor是okhttp的核心。它把请求、缓存等所有的功能都统一了起来。每一个功能就是一个Interceptor。同时，这里也用到了责任链模式。所有的Interceptor都构成一个环，程序会一次执行每一个拦截器，知道最后处理完请求。那我们现在来看看这些拦截器。首先是client中的拦截器，这些拦截器有用户自己定义添加；其次是RetryAndFollowUpInterceptor，它主要负责失败时的重试和重定向；然后是BridgeInterceptor拦截器，它是负责把用户构造的请求转换为发送到服务器的请求、把服务器返回的响应转换为用户友好的响应；然后是CacheInterceptor，读取更新缓存；建立连接的ConnectInterceptor；client的networkInterceptors以及最后的CallServerInterceptor,它负责请求数据和读取返回数据。拦截器的功能决定其位置，比如RetryAndFollowUpInterceptor拦截器在所有的非自定义拦截器之前，保证后面任何一个拦截器出现异常其都能捕获处理，CacheInterceptor在连接服务器之前，可以使其在连接网络之前就能读取缓存，最后是发送读取数据的CallServerInterceptor，做完所有的事情后它才来发送具体的请求。同时，又通过RealInterceptorChain类，去一次调用各个Interceptor。其中与HTTP请求直接相关的是ConnectInterceptor和CallServerInterceptor，那我们再来看看这两个拦截器是怎么实现的。ConnectInterceptor:@Override public Response intercept(Chain chain) throws IOException &#123; RealInterceptorChain realChain = (RealInterceptorChain) chain; Request request = realChain.request(); StreamAllocation streamAllocation = realChain.streamAllocation(); // We need the network to satisfy this request. Possibly for validating a conditional GET. boolean doExtensiveHealthChecks = !request.method().equals(&quot;GET&quot;); HttpCodec httpCodec = streamAllocation.newStream(client, doExtensiveHealthChecks); RealConnection connection = streamAllocation.connection(); return realChain.proceed(request, streamAllocation, httpCodec, connection);&#125; ConnectInterceptor主要是创建了一个HttpCodec对象，它有两个实现：Http1Codec 和 Http2Codec，它们分别对应HTTP/1.1和HTTP/2版本的实现。Http1Codec利用Okio对Socket的读写操作进行封装，Okio以后有机会再进行分析，现在让我们对它们保持一个简单地认识：它对java.io和java.nio进行了封装，让我们更便捷高效的进行IO操作。CallServerInterceptor：@Override public Response intercept(Chain chain) throws IOException &#123; RealInterceptorChain realChain = (RealInterceptorChain) chain; HttpCodec httpCodec = realChain.httpStream(); StreamAllocation streamAllocation = realChain.streamAllocation(); RealConnection connection = (RealConnection) realChain.connection(); Request request = realChain.request(); long sentRequestMillis = System.currentTimeMillis(); httpCodec.writeRequestHeaders(request); Response.Builder responseBuilder = null; if (HttpMethod.permitsRequestBody(request.method()) &amp;&amp; request.body() != null) &#123; if (&quot;100-continue&quot;.equalsIgnoreCase(request.header(&quot;Expect&quot;))) &#123; httpCodec.flushRequest(); responseBuilder = httpCodec.readResponseHeaders(true); &#125; if (responseBuilder == null) &#123; Sink requestBodyOut = httpCodec.createRequestBody(request, request.body().contentLength()); BufferedSink bufferedRequestBody = Okio.buffer(requestBodyOut); request.body().writeTo(bufferedRequestBody); bufferedRequestBody.close(); &#125; else if (!connection.isMultiplexed()) &#123; streamAllocation.noNewStreams(); &#125; &#125; httpCodec.finishRequest(); if (responseBuilder == null) &#123; responseBuilder = httpCodec.readResponseHeaders(false); &#125; Response response = responseBuilder .request(request) .handshake(streamAllocation.connection().handshake()) .sentRequestAtMillis(sentRequestMillis) .receivedResponseAtMillis(System.currentTimeMillis()) .build(); int code = response.code(); if (forWebSocket &amp;&amp; code == 101) &#123; response = response.newBuilder() .body(Util.EMPTY_RESPONSE) .build(); &#125; else &#123; response = response.newBuilder() .body(httpCodec.openResponseBody(response)) .build(); &#125; if (&quot;close&quot;.equalsIgnoreCase(response.request().header(&quot;Connection&quot;)) || &quot;close&quot;.equalsIgnoreCase(response.header(&quot;Connection&quot;))) &#123; streamAllocation.noNewStreams(); &#125; if ((code == 204 || code == 205) &amp;&amp; response.body().contentLength() &gt; 0) &#123; throw new ProtocolException( &quot;HTTP &quot; + code + &quot; had non-zero Content-Length: &quot; + response.body().contentLength()); &#125; return response; &#125; 这里有几个关键的地方：首先是httpCodec. writeRequestHeaders(request);,它是向服务器发送request header，然后是写入Request body:// Write the request body if the &quot;Expect: 100-continue&quot; expectation was met. Sink requestBodyOut = httpCodec.createRequestBody(request, request.body().contentLength()); BufferedSink bufferedRequestBody = Okio.buffer(requestBodyOut); request.body().writeTo(bufferedRequestBody); bufferedRequestBody.close(); httpCodec.finishRequest();//发送请求 然后是读取response header，并且构造Response,并且添加Response body。最终返回我们需要的Response。看到这里我们可以看到，核心工作是由HttpCodec完成的，而HttpCodec实际上利用的是Okio，而Okio实际上还是用的 Socket。 异步网络请求先来看一下如何调用：client.newCall(request).enqueue(new Callback() &#123; @Override public void onFailure(Call call, IOException e) &#123; &#125; @Override public void onResponse(Call call, Response response) throws IOException &#123; &#125;&#125;); 这里主要是涉及到enqueue方法，那再来看一下enqueue方法的具体实现：@Override public void enqueue(Callback responseCallback) &#123; synchronized (this) &#123; if (executed) throw new IllegalStateException(&quot;Already Executed&quot;); executed = true; &#125; captureCallStackTrace(); client.dispatcher().enqueue(new AsyncCall(responseCallback));&#125; enqueue方法前面与execute方法一样，但是在后面，它将传入进来的Callback回调构建成AsyncCall对象后传入dispatcher的enqueue方法。上文说过dispatcher在同步请求中主要是标识请求状态，那么在异步请求中它又有什么作用。synchronized void enqueue(AsyncCall call) &#123; if (runningAsyncCalls.size() &lt; maxRequests &amp;&amp; runningCallsForHost(call) &lt; maxRequestsPerHost) &#123; runningAsyncCalls.add(call); executorService().execute(call); &#125; else &#123; readyAsyncCalls.add(call); &#125; &#125; 通过源码我们可以看到，在请求数量未满之前，传入的AsyncCall会被加到运行请求runningAsyncCalls队列中，并且添加到线程池运行，而超过数量之后则会添加到等待队列中，等到有请求完成从运行队列中删除后再添加到运行队列中。这里的请求在AsyncCall对象中发送，那AsyncCall又是怎样实现的呢？final class AsyncCall extends NamedRunnable &#123; private final Callback responseCallback; AsyncCall(Callback responseCallback) &#123; super(&quot;OkHttp %s&quot;, redactedUrl()); this.responseCallback = responseCallback; &#125; String host() &#123; return originalRequest.url().host(); &#125; Request request() &#123; return originalRequest; &#125; RealCall get() &#123; return RealCall.this; &#125; @Override protected void execute() &#123; boolean signalledCallback = false; try &#123; Response response = getResponseWithInterceptorChain(); if (retryAndFollowUpInterceptor.isCanceled()) &#123; signalledCallback = true; responseCallback.onFailure(RealCall.this, new IOException(&quot;Canceled&quot;)); &#125; else &#123; signalledCallback = true; responseCallback.onResponse(RealCall.this, response); &#125; &#125; catch (IOException e) &#123; if (signalledCallback) &#123; // Do not signal the callback twice! Platform.get().log(INFO, &quot;Callback failure for &quot; + toLoggableString(), e); &#125; else &#123; responseCallback.onFailure(RealCall.this, e); &#125; &#125; finally &#123; client.dispatcher().finished(this); &#125; &#125;&#125; 通过源码我们可以看到，AsyncCall类是RealCall的内部类，同时，它还继承了NamedRunnable类，而NamedRunnable类则实现了Runnable接口，而 NamedRunnable的run方法主要就是运行execute方法。而AsyncCall的execute方法最重要的代码其实就一句：Response response = getResponseWithInterceptorChain();。接下来一切都与同步请求一样了，这里就不再复述了。 总结最后再来看一下整个流程图:(图片来源于拆轮子系列：拆 OkHttp)这里还有很多东西没有展开讲，有些甚至我也没有完全理通，希望后面有机会可以继续深入分析。 参考资料:拆轮子系列：拆 OkHttpOKHttp源码解析","categories":[{"name":"okhttp","slug":"okhttp","permalink":"https://earthwo.github.io/categories/okhttp/"},{"name":"源码阅读","slug":"okhttp/源码阅读","permalink":"https://earthwo.github.io/categories/okhttp/源码阅读/"}],"tags":[{"name":"源码阅读","slug":"源码阅读","permalink":"https://earthwo.github.io/tags/源码阅读/"},{"name":"okhttp","slug":"okhttp","permalink":"https://earthwo.github.io/tags/okhttp/"}]},{"title":"设计模式之责任链模式","slug":"责任链模式","date":"2017-06-21T08:27:50.000Z","updated":"2019-03-11T07:35:22.331Z","comments":true,"path":"2017/06/21/责任链模式/","link":"","permalink":"https://earthwo.github.io/2017/06/21/责任链模式/","excerpt":"","text":"责任链模式是一种对象的行为模式。通俗的说，就是多个处理者对象链成一条链，请求在这条链上传递，知道某个对象处理此请求。 一个简单的实现示例如下：处理方法：public abstract class ConcreteHandler &#123; public abstract void handlerRequest(Handler handler);&#125; 定义处理者：public class ConcreteHandler1 extends ConcreteHandler&#123; int p=1; @Override public void handlerRequest(Handler handler) &#123; if(handler.i!=p)&#123; handler.handlerRequest(); &#125;else&#123; Log.d(&quot;handler&quot;,&quot;处理事件&quot;); &#125; &#125;&#125;public class ConcreteHandler2 extends ConcreteHandler&#123; int p=2; @Override public void handlerRequest(Handler handler) &#123; if(handler.i!=p)&#123; handler.handlerRequest(); &#125;else&#123; Log.d(&quot;handler&quot;,&quot;处理事件&quot;); &#125; &#125;&#125;public class Handler &#123; int i; int position; List&lt;ConcreteHandler&gt; list; public void handlerRequest()&#123; if(list.size()&lt;position)&#123; position++; list.get(position-1).handlerRequest(this); &#125;else&#123; Log.d(&quot;handler&quot;,&quot;无法处理请求&quot;); &#125; &#125;&#125; 具体的执行代码如下：List&lt;ConcreteHandler&gt; list=new ArrayList&lt;&gt;(); list.add(new ConcreteHandler1()); list.add(new ConcreteHandler2()); Handler handler=new Handler(); handler.i=2; handler.list=list; handler.handlerRequest(); 首先是要创建和添加整个处理者链条，添加处理条件，再根据情况依次进行处理。一个纯的责任链模式要求一个具体的处理者要不能够处理请求，要不把请求传给下个处理者，不允许出现处理者处理了一部分请求后又把请求传给下位的情况，同时，请求也必须能被某个处理者处理，不允许出现请求无法处理的情况。但是在实际的情况中纯的责任链很难找到。 参考文章：《JAVA与模式》之责任链模式","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://earthwo.github.io/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://earthwo.github.io/tags/设计模式/"}]},{"title":"Kotlin基础语法(三)","slug":"Kotlin基础语法（三）","date":"2017-06-07T07:36:43.000Z","updated":"2019-03-11T07:35:22.318Z","comments":true,"path":"2017/06/07/Kotlin基础语法（三）/","link":"","permalink":"https://earthwo.github.io/2017/06/07/Kotlin基础语法（三）/","excerpt":"","text":"继承在 Kotlin 中所有类都有一个共同的超类Any，这对于没有超类型声明的类是默认超类，Any与java中的Object不同，它只有equals()、hashCode()和toString()三个方法。要声明一个显式的超类型，我们把类型放到类头的冒号之后：open class Base(p: Int)class Derived(p: Int) : Base(p) 基类在声明时必须要有open修饰，表示该类可以被继承。同时如果类有主构造函数，那么其基类必须用主构造函数参数实例化，如果没有主构造函数，那么每个次构造函数必须用super关键字实例化基类。如：class MyView : View &#123; constructor(ctx: Context) : super(ctx) constructor(ctx: Context, attrs: AttributeSet) : super(ctx, attrs)&#125; 覆盖方法和属性Kotlin 需要显式 标注可覆盖的成员（我们称之为开放）和覆盖后的成员：open class Base &#123; open val x: Int =3 open fun v() &#123;&#125; fun nv() &#123;&#125;&#125;class Derived() : Base() &#123; override val x: Int=7 override fun v() &#123;&#125;&#125; 基类可以覆盖的方法属性必须有open，子类覆盖的方法属性必须有override。同时你也可以用一个var属性覆盖一个val属性，但反之则不行。这是允许的，因为一个val属性本质上声明了一个getter方法，而将其覆盖为var只是在子类中额外声明一个setter方法。 抽象类类和其中的某些成员可以声明为abstract。抽象成员在本类中可以不用实现。需要注意的是，我们并不需要用open标注一个抽象类或者函数，因为抽象类本来就是让人继承的。open class Base &#123; open fun f() &#123;&#125;&#125;abstract class Derived : Base() &#123; override abstract fun f()&#125; 接口Kotlin的接口与Java 8类似，既包含抽象方法的声明，也可以包含实现。与抽象类不同的是，接口无法保存状态。它可以有属性但必须声明为抽象或提供访问器实现。interface MyInterface &#123; fun bar() fun foo() &#123; &#125;&#125; 实现接口：class Child : MyInterface &#123; override fun bar() &#123; // 方法体 &#125;&#125; 与抽象类一样，接口中无需open修饰，因为本来就是让其他类去实现的。接口中属性的使用：interface MyInterface &#123; val prop: Int // 抽象的 val propertyWithImplementation: String get() = &quot;foo&quot; fun foo() &#123; print(prop) &#125;&#125;class Child : MyInterface &#123; override val prop: Int = 29&#125; 可见性修饰符在 Kotlin 中有这四个可见性修饰符：private、protected、internal和public。如果没有显式指定修饰符的话，默认可见性是public。private、protected和public的作用于在java中基本一样，internal表示它会在相同模块内随处可见。那什么是相同的模块呢？具体地说， 一个模块是编译在一起的一套 Kotlin 文件，比如一个 IntelliJ IDEA 模块；一个 Maven 或者 Gradle 项目或一次 ＜kotlinc＞ Ant 任务执行所编译的一套文件。 扩展在Kotlin中能够扩展一个类的新功能而无需继承该类或使用像装饰者这样的任何类型的设计模式，就叫做扩展。Kotlin支持扩展函数和扩展属性。声明一个扩展函数，我们需要用一个 接收者类型 也就是被扩展的类型来作为他的前缀，如：class Exprfun Expr.r()&#123; Log.d(&quot;&quot;,&quot;&quot;)&#125; 这里就扩展了Expr类。扩展函数是静态分发的，即他们不是根据接收者类型的虚方法。 这意味着调用的扩展函数是由函数调用所在的表达式的类型来决定的， 而不是由表达式运行时求值结果决定的。例如:open class Cclass D: C()fun C.foo() = &quot;c&quot;fun D.foo() = &quot;d&quot;fun printFoo(c: C) &#123; println(c.foo())&#125;printFoo(D()) 这个例子会输出 “c”，因为调用的扩展函数只取决于参数 c 的声明类型，该类型是 C 类。同时，当扩展函数和成员函数相同时，调用会调用成员函数，除非两者出现重载。和函数类似，Kotlin 支持扩展属性：val &lt;T&gt; List&lt;T&gt;.lastIndex: Int get() = size - 1 扩展属性不能有初始化器。他们的行为只能由显式提供的 getters/setters 定义。如果一个类定义有一个伴生对象 ，你也可以为伴生对象定义扩展函数和属性：class MyClass &#123; companion object &#123; &#125; // 将被称为 &quot;Companion&quot;&#125;fun MyClass.Companion.foo() &#123; // ……&#125; 调用时：MyClass.foo()在一个类内部你可以为另一个类声明扩展。在这样的扩展内部，有多个隐式接收者—— 其中的对象成员可以无需通过限定符访问。扩展声明所在的类的实例称为分发接收者（声明拓展的部分），扩展方法调用所在的接收者类型的实例称为扩展接收者(拓展部分)。class D &#123; fun bar() &#123; …… &#125;//扩展接收者&#125;class C &#123;//分发接收者 fun baz() &#123; …… &#125; fun D.foo() &#123; bar() // 调用 D.bar baz() // 调用 C.baz &#125; fun caller(d: D) &#123; d.foo() // 调用扩展函数 &#125;&#125; 对于分发接收者和扩展接收者的成员名字冲突的情况，扩展接收者优先。 解构声明Kotlin可以把一个变量解构成多个变量，如：var a=A()var(x,userName) = a//x和userName可以随意命名Log.d(&quot;显示&quot;,&quot;&quot;+x) 一个解构声明会被编译成以下代码：val x = person.component1()val userName = person.component2() 所以在A中需要添加如下代码:operator fun component1(): Any? &#123; return userName &#125; operator fun component2(): Any? &#123; return userName &#125; 请注意，componentN() 函数需要用 operator 关键字标记，以允许在解构声明中使用它们，同时数据类自动声明 componentN() 函数。 集合Kotlin 区分可变集合和不可变集合（lists、sets、maps 等）。Kotlin 的List&lt;out T&gt;类型是一个提供只读操作如size、get等的接口，要想编辑需要使用MutableList&lt;T&gt;。同样的这也适用于Set&lt;out T&gt;/MutableSet&lt;T&gt;及Map&lt;K, out V&gt;/MutableMap&lt;K, V&gt;。val numbers: MutableList&lt;Int&gt; = mutableListOf(1, 2, 3)val readOnlyView: List&lt;Int&gt; = numbersprintln(numbers) // 输出 &quot;[1, 2, 3]&quot;numbers.add(4)println(readOnlyView) // 输出 &quot;[1, 2, 3, 4]&quot;readOnlyView.clear() //不存在这个方法 Kotlin 没有专门的语法结构创建 list 或 set。 要用标准库的方法，如 listOf()、 mutableListOf()、 setOf()、 mutableSetOf()。 在非性能关键代码中创建 map 可以用一个简单的惯用法来完成：mapOf(a to b, c to d)。 区间区间表达式由具有操作符形式 .. 的rangeTo函数辅以 in 和 !in 形成。如：if (i in 1..10) &#123; // 等同于 1 &lt;= i &amp;&amp; i &lt;= 10 println(i)&#125; 这里需要注意的是1..10是不能倒过来的，即如果写成10..1，那么就表明是 10 &lt;= i &amp;&amp; i &lt;= 1，这样程序是不会执行的。所以如果要使用倒序，则需要使用downTo函数：for (i in 10 downTo 1) print(i) 除此以外，还有几个函数也非常有用：for (i in 1..10 step 2) print(i)//输出 13579 step函数表示执行的步长度。step 2说明每部执行2个数（即执行一步，跳一步）。for (i in 1 until 10) &#123; // i in [1, 10) 排除了 10 println(i)&#125; until函数表示不包含某数。for (i in (1..10).reversed())&#123;//10,9,8,7,6,5,4,3,2,1 println(i) &#125; reversed能返回函数返回数据反转后的数列。 类型的检查与转换我们可以使用is操作符或其否定形式!is来检查对象是否是给定类型。if (obj is String) &#123; print(obj.length)&#125; 在多数情况下，不需要使用显式转换操作符，因为编译器会跟踪is和!is检查，并在需要时自动插入转换：fun demo(x: Any) &#123; if (x is String) &#123; print(x.length) // x 自动转换为字符串 &#125;&#125; if (x !is String) return print(x.length) // x 自动转换为字符串 这中智能转换也一样适用于when表达式。当变量不能保证检查和使用时不可变时，不会进行智能转换，所以智能转换的使用范围:val 局部变量——总是可以；val 属性——如果属性是 private 或 internal，或者该检查在声明属性的同一模块中执行。智能转换不适用于 open 的属性或者具有自定义 getter 的属性；var 局部变量——如果变量在检查和使用之间没有修改、并且没有在会修改它的 lambda 中捕获；var 属性——决不可能（因为该变量可以随时被其他代码修改）。Kotlin中的可以使用操作符as对类型进行强制转换：val x: String = y as String 当y为null时，上述代码会报错，所以我们必须在在转换左右都有可空类型： val x: String? = y as String? this作用域要访问来自外部作用域的this，我们使用this@label，其中 @label 是一个代指 this 来源的标签：class A &#123; // 隐式标签 @A inner class B &#123; // 隐式标签 @B fun Int.foo() &#123; // 隐式标签 @foo val a = this@A // A 的 this val b = this@B // B 的 this val c = this // foo() 的接收者，一个 Int val c1 = this@foo // foo() 的接收者，一个 Int &#125; &#125;&#125; 空安全在Kotlin中，类型系统会区分一个引用是否可以容纳null:var a: String = &quot;abc&quot;a = null // 编译错误 当类型允许为空，但依旧被调用时：var b: String? = &quot;abc&quot;val l = b.length//编译错误 这种情况时会编译错误，这时，我们可以对它进行空判断：var b: String? = &quot;abc&quot;if(b!=null)&#123; val l = b.length&#125; 除此以外，我们还可以使用安全调用符，?.val l = b?.length 它表示当b为null时，返回null，不为null时，返回b.length。除此之外，我们还可以使用Elvis操作符，写作?:：val l = b?.length ?: -1 它表示当左边的表达式非空时执行左边的表达式，为空时执行右边的表达式。第三中方式是使用!! 操作符：val l = b!!.length 当b为空时，程序会抛出NPE异常。","categories":[{"name":"Kotlin","slug":"Kotlin","permalink":"https://earthwo.github.io/categories/Kotlin/"}],"tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"https://earthwo.github.io/tags/Kotlin/"}]},{"title":"Kotlin基础语法（二）","slug":"Kotlin基础语法（二）","date":"2017-06-06T08:39:37.000Z","updated":"2019-03-11T07:35:22.318Z","comments":true,"path":"2017/06/06/Kotlin基础语法（二）/","link":"","permalink":"https://earthwo.github.io/2017/06/06/Kotlin基础语法（二）/","excerpt":"","text":"类和对象类在Kotlin中，类依旧使用class定义，用大括号包裹，不过当类里面没有任何代码时，大括号可以省略。 构造函数Kotlin中可以有一个主构造函数和多个二级构造函数，如下：class A constructor(name: String)&#123;&#125; 其中的constructor关键字可以省略。但是如果构造函数有其他声明获取注解，如：private，那么constructor就不能省略。在主构造函数中不能有任何代码，所以初始化代码需要写在init代码块中，或者在参数声明时定义:class A (name: String)&#123; init &#123; print(name) &#125;&#125;class A (name: String)&#123; var userName=name&#125; 属性声明可以主构造函数中直接声明：class A (var userName: String)&#123;&#125; 二级构造函数声明在类体内，但是必须有constructor关键字，如下：class A &#123; constructor(name: String)&#123; &#125;&#125; 如果类已经有了一级构造函数，那么二级构造函数在声明时必须代理主构造函数，并且使用关键字this：class A (var name: String)&#123; constructor(name: String,age: Int) : this(name)&#123; &#125;&#125; 两个构造函数在使用时没有区别，所以在声明时参数数量或类型需要不同。在创建类的实例时，不需要关键字new，可以直接创建。val a=A(&quot;tim&quot;) 属性和字段类中的属性用var声明时可变的，用val声明是只读的。使用属性时只要直接用名称使用它即可，如：a.userName。声明属性的示例：var userName: String?=nullvar age=1 在确定了属性的类型后，必须要指定其默认值。 get和set方法除了在声明属性时指定默认值以外，还可以在get方法中设置值。Kotlin中get和set方法都是默认的，但是我们也可以自定义get和set方法。var userName: String? get() = &quot;tom&quot; 这里userName开始没有默认值，但是在get方法中设置了值。var userName: String?=null set(value) &#123; userName=value+&quot;.&quot;&#125; 这里userName传入的值后面添加一个.如果你需要改变一个访问器的可见性或者对其注解，但是不需要改变默认的实现， 你可以定义访问器而不定义其实现:var userName: String?=null private set(value) &#123;&#125; 数据类我们经常创建一些只保存数据的类。在这些类中，一些标准函数往往是从 数据机械推导而来的。在 Kotlin 中，这叫做数据类并标记为data：data class User(val name: String, val age: Int) 编译器自动从主构造函数中声明的所有属性导出以下成员：equals()/hashCode() 对，toString() 格式是 “User(name=John, age=42)”，componentN() 函数 按声明顺序对应于所有属性，copy()函数。对于上面的数据类，程序会自动生成copy函数:fun copy(name: String = this.name, age: Int = this.age) = User(name, age) copy方法使用如下：val jack = User(name = &quot;Jack&quot;, age = 1)val olderJack = jack.copy(age = 2) 密封类密封类用来表示受限的类继承结构：当一个值为有限集中的类型、而不能有任何其他类型时(所有的子类都必须在密封类的内部，继承子类的类可以在其他文件)。sealed class Exprdata class Const(val number: Double) : Expr()data class Sum(val e1: Expr, val e2: Expr) : Expr()object NotANumber : Expr() 使用密封类的关键好处在于使用 when 表达式 的时候，如果能够验证语句覆盖了所有情况，就不需要为该语句再添加一个 else 子句了。 嵌套类类可以嵌套在其他类中class Outer &#123; private val bar: Int = 1 class Nested &#123; fun foo() = 2 &#125;&#125; 内部类类可以标记为inner以便能够访问外部类的成员，这个类就是内部类。内部类会带有一个对外部类的对象的引用：class Outer &#123; private val bar: Int = 1 class Nested &#123; fun foo() = bar &#125;&#125; 匿名内部类对象表达式创建匿名内部类：window.addMouseListener(object: MouseAdapter() &#123; override fun mouseClicked(e: MouseEvent) &#123; &#125; override fun mouseEntered(e: MouseEvent) &#123; &#125;&#125;) 函数Kotlin 中的函数使用 fun 关键字声明fun setName(name: String) : Int&#123; return 1 &#125; 后面的: Int表示返回值为Int,如果不返回任何值，则使用Unit，如：fun setName(name: String) : Unit&#123; this.userName=name &#125; 函数在声明时可以直接设置默认参数，如：fun setName(name: String=&quot;tim&quot;) : Unit&#123; this.userName=name &#125; 覆盖方法总是使用与基类型方法相同的默认参数值。 当覆盖一个带有默认参数值的方法时，必须从签名中省略默认参数值。可以在调用函数时使用命名的函数参数。当一个函数有大量的参数或默认参数时这会非常方便。如：fun setName(name: String=&quot;tim&quot;,a: Boolean=false,b: Boolean=false,c: String) : Unit&#123; this.userName=name &#125; 使用命名参数，增加可读性,同时也可以省略部分参数，如：a.setName(&quot;ddd&quot;,c=&quot;d&quot;) 当函数返回单个表达式时，可以省略花括号并且在 = 符号之后指定代码体即可，如：fun double(x: Int): Int = x * 2 函数的参数还可以使用Varargs来表示可变数量的参数，如：fun &lt;T&gt; asList(vararg ts: T): List&lt;T&gt; &#123; val result = ArrayList&lt;T&gt;() for (t in ts) // ts is an Array result.add(t) return result&#125;val list = asList(1, 2, 3) 在 Kotlin 中函数可以在文件顶层声明，所有你不需要用类来保存一个函数。此外 除了顶层函数，Kotlin 中函数也可以声明在局部作用域、作为成员函数以及扩展函数。而顶层函数在调用时不需要实例就可以直接调用。Kotlin 支持局部函数，即一个函数在另一个函数内部。如：fun dfs(graph: Graph) &#123; fun dfs(current: Vertex, visited: Set&lt;Vertex&gt;) &#123; if (!visited.add(current)) return for (v in current.neighbors) dfs(v, visited) &#125; dfs(graph.vertices[0], HashSet())&#125; 参考资料","categories":[{"name":"Kotlin","slug":"Kotlin","permalink":"https://earthwo.github.io/categories/Kotlin/"}],"tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"https://earthwo.github.io/tags/Kotlin/"}]},{"title":"kotlin基础语法（一）","slug":"kotlin基础语法（一）","date":"2017-05-31T07:08:43.000Z","updated":"2019-03-11T07:35:22.326Z","comments":true,"path":"2017/05/31/kotlin基础语法（一）/","link":"","permalink":"https://earthwo.github.io/2017/05/31/kotlin基础语法（一）/","excerpt":"","text":"自从今年google在开发者大会上宣布，将Kotlin作为Android开发的主要语言后，越来越多的开发者开始关注Kotlin，那么我们就来学习一下Kotlin的基础语法。 基本类型数值类型kotlin提供了6种内建数值类型，具体的类型和位宽如下（括号里为位宽）：Int(32)，Float(32)，Double(64)，Long(64)，Short(16)，Byte(8)。这里需要注意的是没有字符类型，而且与java不同的是每个类型的首字母都是大写的。 数值常量数值的常量与java一样，比如Long类型在末尾加L，Float类型在末尾加F或f。在定义数值常量时与java有所不同，Kotlin使用了一个关键字val:val a = 1000 val a: Int = 10000。上面的两句赋值语句实际上是一样的，只是第一句需要程序自动去推断出Int类型，而第二句则直接将类型指定为Int类型。这里有个地方需要注意，第二句中的冒号的位置，在冒号区分类型和父类型中要有空格，在实例和类型之间是没有空格的。 数值常量中添加下划线分割(1.1版本新特性)在1.1新版中，可以在常量中添加下划线，以增加可阅读性。如：val oneMillion = 1_000_000val socialSecurityNumber = 999_99_9999L 使用可空的值并检测 null当数值可空时必须明确地加以标记，如：val a: Int?null = null。而当数值做可空标识时，指数值将会被装箱，比如说上面的语句就相当于a被装箱为java的Integer,所以就有了如下的情况：val a: Int = 10000print (a === a ) // 打印 &apos;true&apos;val boxedA: Int? =aval anotherBoxedA: Int? = aprint(boxedA === anotherBoxedA ) // 对象比较，打印falseprint(boxedA == anotherBoxedA ) // 对象的值比较，打印true 数值之间的转换数值转换和java一样，有显示转换和隐式转换。隐式转换就是我们使用了上下文推断出类型，并且算术运算会为合适的转换进行重载。每个数值类型都支持如下的显示转换：toByte(): BytetoShort(): ShorttoInt(): InttoLong(): LongtoFloat(): FloattoDouble(): DoubletoChar(): Char 在这里也有一点需要注意，当我们在定义数值时如果用了可空标识，那么在转换的时候就需要做判空操作。 布尔值布尔值与数值基本一样，如：var v:Boolean=false 字符和字符串字符类型用Char表示，但是它不能当数值来使用，但是可以通过显示转换转换为数值类型。字符串用String表示，它与字符在声明略有不同，如var a=&#39;e&#39; var b=&quot;e&quot;，前者是字符，后者是字符串，字符用的是单引号，字符串是双引号。字符串可以直接通过索引读取，比如：val a=&quot;hello&quot;print(&quot;\\$a=$&#123;a[3]&#125;&quot;)//打印l 也可以通过for循环读取，比如：for (c in a) &#123;//将依次打印a字符串 println(c)&#125; 字符串可以包含模板表达式，即可求值的代码片段，并将其结果连接到字符串中。一个模板表达式由一个 $ 开始并包含另一个简单的名称：val a=&quot;s&quot;print(&quot;\\$a=$a&quot;) 获取是带一个大括号的表达式print(&quot;\\$a=$&#123;a[0]&#125;&quot;) 数组在Kotlin中，数组用Array表示。它有get和set方法读取和存储，也可以直接使用[]调用。创建数组的方法有很多。首先，我们可以用arrayof()来创建Array： var v= arrayOf(1,2,3)我们也可以通过arrayOfNulls来创建指定大小的空Array： var v= arrayOfNulls&lt;Int&gt;(12)或者通过工厂函数通过索引来创建：var v=Array(5,{i-&gt;{i}}) //创建的Array 为[1,2,3,4,5]Kotlin 有专门的类来表示原始类型从而避免过度装箱： ByteArray, ShortArray, IntArray 等等。这些类与 Array 没有继承关系，但它们有一样的方法与属性。每个都有对应的库函数：val x: IntArray = intArrayOf(1, 2, 3) 运算符Kotlin支持标准的算术运算表达，同时还提供了可以叫中缀形式的方法（只能用于Int和Long）。如下shl(bits) – 有符号左移 (相当于 Java中的 &lt;&lt;) shr(bits) – 有符号右移 (相当于 Java中的 &gt;&gt;) ushr(bits) – 无符号右移 (相当于 Java中的 &gt;&gt;&gt;) and(bits) – 按位与 or(bits) – 按位或 xor(bits) – 按位异或 inv(bits) – 按位翻转 控制语句if表达式在Kotlin中，if语句和java基本一致，但是没有三元运算符(condition ? then : else)。但是if可以直接返回值，所以三元运算符可以直接通过if else表示。val max = if (a &gt; b) a else b when表达式when语句相当于java中的switch，它的基本用法如下：when (x) &#123; 1 -&gt; print(&quot;x == 1&quot;) 2 -&gt; print(&quot;x == 2&quot;) else -&gt; &#123; print(&quot;x is neither 1 nor 2&quot;) &#125;&#125; 原来java中的：变成了-&gt;，default变成了else，同时也不用再用break了。而当多个条件同时执行一条语句时：when (x) &#123; 1,2 -&gt; print(&quot;x == 1 or 2&quot;) else -&gt; &#123; print(&quot;x is neither 1 nor 2&quot;) &#125;&#125; 同时，条件还可以用表达式来代替：when (x) &#123; parseInt(s) -&gt; print(&quot;s encode x&quot;) else -&gt; print(&quot;s does not encode x&quot;)&#125; 还可以使用in和!in来判断是否在范围中：when (x) &#123; in 1..10 -&gt; print(&quot;在1-10中间&quot;) else -&gt; print(&quot;不在1-10中间&quot;)&#125; 可以使用is来判断是否是摸个类型，同时可以直接返回值val hasPrefix = when (x) &#123; is String -&gt; x.startsWith(&quot;prefix&quot;) else -&gt; false&#125; 当when没有相应的参数提供时，分支条件就是简单的布尔表达式，当条件满足时就执行相应的分支：when { x==4 -&gt; print(“x is 4”) x==5 -&gt; print(“x is 5”) else -&gt; print(“x不是4，5”)} for语句for 循环通过任何提供的迭代器进行迭代。for (item in collection) print(item) 也可以指定类型for (item:Int in collection) print(item) while语句与java完全一样就不在介绍了。 跳出循环kotlin有3种跳出循环的方式：return、break、continue，这3个的用途基本与java相同，但是写法稍有不同。在 Kotlin 中表达式可以通过 @ 结尾来表示标签，所有退出标签可以这样写：loop@ for (i in 1..100) &#123; for (j in i..100) &#123; if (...) break@loop &#125;&#125; 同时也适用于return:fun foo() &#123; ints.forEach lit@ &#123; if (it ==0) return＠lit print(it) &#125;&#125; 这样它只是从forEach方法中返回，它甚至可以这样写：fun foo() &#123; ints.forEach &#123; if (it == 0) return@forEach print(it) &#125;&#125; 参考资料","categories":[{"name":"kotlin","slug":"kotlin","permalink":"https://earthwo.github.io/categories/kotlin/"}],"tags":[{"name":"kotlin","slug":"kotlin","permalink":"https://earthwo.github.io/tags/kotlin/"}]},{"title":"Retrofit源码分析","slug":"Retrofit源码分析","date":"2017-05-17T08:08:29.000Z","updated":"2019-03-11T07:35:22.321Z","comments":true,"path":"2017/05/17/Retrofit源码分析/","link":"","permalink":"https://earthwo.github.io/2017/05/17/Retrofit源码分析/","excerpt":"","text":"Retrofit 是安卓上最流行的HTTP Client库之一，它因其出色的性能和简洁的实现广受开发者好评，那么现在就来看看它的实现原理。 使用方法具体的使用方法，我在这里不再赘述，大家可以直接看它的官方文档 Retrofit官方文档，里面讲的非常简洁具体。 实现原理在具体了解原理之前，我们先看看认真看完这一篇，不懂 Retrofit？不存在的（源码解析这篇文章中分享的Retrofit简易流程架构图：下面我们来看看具体的代码实现。Retrofit(okhttp3.Call.Factory callFactory, HttpUrl baseUrl, List&lt;Converter.Factory&gt; converterFactories, List&lt;CallAdapter.Factory&gt; adapterFactories, Executor callbackExecutor, boolean validateEagerly) &#123; this.callFactory = callFactory; this.baseUrl = baseUrl; this.converterFactories = unmodifiableList(converterFactories); // Defensive copy at call site. this.adapterFactories = unmodifiableList(adapterFactories); // Defensive copy at call site. this.callbackExecutor = callbackExecutor; this.validateEagerly = validateEagerly; &#125; 通过源码我发现，Retrofit的构造方法需要传入的参数较多，所以其采用了Builder模式来传入参数。 Retrofit Builder类Builder类在创建Retrofit实例的过程中，主要需要传入一下几个参数：baseUrl、client、addConverterFactory、addCallAdapterFactory。下面依次来讲一下这些参数的意义。baseUrl：这个顾名思义，就是请求的基础Url；client：这个是OkHttpClient的对象，也就是具体进行网络请求的对象。addConverterFactory：这个就是生产Converter的工厂类，也就是生产在请求过程中对请求数据和回调数据进行转换的转换器的工厂类，主要是处理 ResponseBody， RequestBody 和 String类型的转化；addCallAdapterFactory：这个是生产CallAdapter的工厂类。Call就是用来真正发起网络请求和接收回调的，而CallAdapter是将一个Call适配给另一个Call的适配器接口。对于后面两个工厂类可能还不是很清楚，这些会在后面讲具体实现中再讲它们是怎么用的。 Retrofit create方法create方法是整个Retrofit的门面，一切后续操作都是从这里起步，那我们就来具体看看它的实现。首先先看源码：@SuppressWarnings(&quot;unchecked&quot;) // Single-interface proxy creation guarded by parameter safety. public &lt;T&gt; T create(final Class&lt;T&gt; service) &#123; Utils.validateServiceInterface(service); if (validateEagerly) &#123; eagerlyValidateMethods(service); &#125; return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class&lt;?&gt;[] &#123; service &#125;, new InvocationHandler() &#123; private final Platform platform = Platform.get(); @Override public Object invoke(Object proxy, Method method, Object... args) throws Throwable &#123; // If the method is a method from Object then defer to normal invocation. if (method.getDeclaringClass() == Object.class) &#123; return method.invoke(this, args); &#125; if (platform.isDefaultMethod(method)) &#123; return platform.invokeDefaultMethod(method, service, proxy, args); &#125; ServiceMethod serviceMethod = loadServiceMethod(method); OkHttpCall okHttpCall = new OkHttpCall&lt;&gt;(serviceMethod, args); return serviceMethod.callAdapter.adapt(okHttpCall); &#125; &#125;); &#125; 开始的代码跟核心功能关系不大，先简单说说。首先是检查传入的是的是inteeface类。其次是根据需要创建所有接口的ServiceMethod，ServiceMethod是什么我们后面再说，而这个默认是关闭的，因为在创建ServiceMethod时是需要耗费时间和性能，所以一般不需要在一开始时就将所有请求的ServiceMethod就全部创建。接下来就是根据动态代理的方式来创建接口对象，这也是create方法的核心所在，那我们再来看看这里面做了什么。首先如果是Object的方法就不管，其次如果是default 方法也不管。这里的default方法是java 8的新特性，在这里不做介绍。然后就是最关键的3行代码，接下啦我们就重点看看这几行代码。loadServiceMethod(method)在之前其实遇到过，创建接口的ServiceMethod。那什么是ServiceMethod呢？ServiceMethod就是根据接口的注解、传入参数等信息来创建的类，这里面包含着请求接口的请求方式、参数、请求header、url等等信息。除了这些以外，还有几个变量值得关注。1.callFactory 它负责创建并执行Http请求。2.callAdapter 它主要是把请求数据retrofit2.Call&lt;T&gt;转化为相应的T，而我们发现，ServiceMethod中的callAdapter其实就来自于一开始我们在初始化Retrofit时addCallAdapterFactory所传入的工程类所创建。3.responseConverter 它负责把服务器返回的数据（JSON、XML、二进制或者其他格式，由 ResponseBody 封装）转化为 T 类型的对象，同样，它也是Retrofit初始化时addConverterFactory所传入的工程类所创建。同时，Retrofit还对ServiceMethod进行了缓存，方便同一个接口调用时可以更快速。然后是创建OkHttpCall。OkHttpCall是OkHttp的包装类，所有OkHttp所需要的参数都需要在创建时传入。最后是最关键的serviceMethod.callAdapter. adapt(okHttpCall)。这里我用的是RxJavaCallAdapterFactory这个工厂类，RxJavaCallAdapterFactory的getCallAdapter方法中对返回值的泛型类型进行了进一步检查，例如我们声明的返回值类型为Observable&lt;List&lt;Repo&gt;&gt;，泛型类型就是List&lt;Repo&gt;，这里对 retrofit2.Response和retrofit2.adapter.rxjava.Result进行了特殊处理，有单独的 adapter 负责进行转换，其他所有类型都由 SimpleCallAdapter 负责转换。所以CallAdapter就是SimpleCallAdapter，那就先来看看SimpleCallAdapter中的adapt方法。@Override public &lt;R&gt; Observable&lt;R&gt; adapt(Call&lt;R&gt; call) &#123; Observable&lt;R&gt; observable = Observable.create(new CallOnSubscribe&lt;&gt;(call)) // .lift(OperatorMapResponseToBodyOrError.&lt;R&gt;instance()); if (scheduler != null) &#123; return observable.subscribeOn(scheduler); &#125; return observable; &#125; &#125; 这里的实现方式也很简单，创建了一个Observable，并由CallOnSubscribe去实现逻辑，同时用OperatorMapResponseToBodyOrError将retrofit2.Response转化为声明的类型或者错误异常类型。@Override public void call(final Subscriber&lt;? super Response&lt;T&gt;&gt; subscriber) &#123; // Since Call is a one-shot type, clone it for each new subscriber. Call&lt;T&gt; call = originalCall.clone(); // Wrap the call in a helper which handles both unsubscription and backpressure. RequestArbiter&lt;T&gt; requestArbiter = new RequestArbiter&lt;&gt;(call, subscriber); subscriber.add(Subscriptions.create(requestArbiter)); subscriber.setProducer(requestArbiter); &#125; &#125; CallOnSubscribe中call的实现也很简洁，首先将okhttp3.Callclone,因为它只能使用一次，所以每次都是新的clone进行请求。然后创建了RequestArbiter，并将其设置给subscriber。在Subscriber设置Producer之后，Subscriber会通过Producer去请求数据，而Producer请求到数据之后，再根据请求的量给Subscriber发数据。@Override public void request(long n) &#123; if (n &lt; 0) throw new IllegalArgumentException(&quot;n &lt; 0: &quot; + n); if (n == 0) return; // Nothing to do when requesting 0. if (!compareAndSet(false, true)) return; // Request was already triggered. try &#123; Response&lt;T&gt; response = call.execute(); if (!subscriber.isUnsubscribed()) &#123; subscriber.onNext(response); &#125; &#125; catch (Throwable t) &#123; Exceptions.throwIfFatal(t); if (!subscriber.isUnsubscribed()) &#123; subscriber.onError(t); &#125; return; &#125; if (!subscriber.isUnsubscribed()) &#123; subscriber.onCompleted(); &#125; &#125; 在Producer的request方法中，最主要的就是call.execute(),并把值返回给下游。 总结Retrofit的分析就这些了，里面的代码确实非常漂亮，非常值得我们去学习。 推荐文章认真看完这一篇，不懂 Retrofit？不存在的（源码解析Retrofit分析-漂亮的解耦套路Retrofit分析-经典设计模式案例拆轮子系列：拆 Retrofit","categories":[{"name":"Retrofit","slug":"Retrofit","permalink":"https://earthwo.github.io/categories/Retrofit/"},{"name":"源码阅读","slug":"Retrofit/源码阅读","permalink":"https://earthwo.github.io/categories/Retrofit/源码阅读/"}],"tags":[{"name":"源码阅读","slug":"源码阅读","permalink":"https://earthwo.github.io/tags/源码阅读/"},{"name":"Retrofit","slug":"Retrofit","permalink":"https://earthwo.github.io/tags/Retrofit/"}]},{"title":"java动态代理","slug":"java动态代理","date":"2017-05-11T02:34:33.000Z","updated":"2019-03-11T07:35:22.325Z","comments":true,"path":"2017/05/11/java动态代理/","link":"","permalink":"https://earthwo.github.io/2017/05/11/java动态代理/","excerpt":"","text":"代理的概念首先，什么是代理？当我们不能或者不希望直接访问对象A，而是通过对象B去访问对象A，这种方式就叫做代理。而对象A的类就被称为委托类，对象B的类就被称为代理类。这样做有什么好处呢？第一，委托类被完全隐藏起来，其他类无法直接访问委托类；第二，在访问委托类之前，可以在代理类中做一些公共的操作，比如一些判断，可以帮助程序更好的解耦。代理可以分为静态代理和动态代理。 静态代理什么是静态代理？顾名思义,所有的委托类和代理类在编译前都已经写好或者通过编译器生成好。一般情况下，代理类和委托类都会继承同一个接口。 动态代理动态代理指的就是代理类在程序运行前并不存在，在程序运行过程中动态生成代理方法的方式。这样做的好处是可以对代理类的所有方法做统一处理，而不用对每个方法单一处理。 动态代理的实现第一步，实现委托类。public class OperateImpl implements Operate &#123; @Override public void operateMethod() &#123; Log.d(&quot;代理实现&quot;,&quot;代理实现&quot;); &#125;&#125; 这个类继承继承自Operate，并且实现了方法operateMethod。第二步，生成代理对象。final OperateImpl operateImpl=new OperateImpl(); Operate operate= (Operate) Proxy.newProxyInstance(OperateImpl.class.getClassLoader(), new Class[]&#123;Operate.class&#125;, new InvocationHandler() &#123; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; return method.invoke(operateImpl, args); &#125; &#125;);operate.operateMethod(); Proxy.newProxyInstance(…)新建了一个代理对象，并动态生成代理类。我们在调用代理对象的方法时就会调用到invoke方法。在newProxyInstance方法中需要3个参数，第一个是委托类的类构造器，第二个是委托类的接口，最后是InvocationHandler对象。那么InvocationHandler又是什么呢？每一个动态代理类都必须要实现InvocationHandler接口，并且每个代理类的实例都关联一个handler，当我们通过代理类调用方法时，这个方法都会被转化为在InvocationHandler的invoke方法中调用。invoke方法有3个参数，第一个表示该代理对象的实例，第二个表示调用的方法，第三个表示该方法的传入参数。在invoke方法中，我们就可以统一的对方法做相应的判断处理。","categories":[{"name":"动态代理","slug":"动态代理","permalink":"https://earthwo.github.io/categories/动态代理/"}],"tags":[{"name":"动态代理","slug":"动态代理","permalink":"https://earthwo.github.io/tags/动态代理/"}]},{"title":"C语言学习笔记(四)","slug":"C语言学习笔记-四","date":"2017-03-06T05:30:21.000Z","updated":"2019-03-11T07:35:22.316Z","comments":true,"path":"2017/03/06/C语言学习笔记-四/","link":"","permalink":"https://earthwo.github.io/2017/03/06/C语言学习笔记-四/","excerpt":"","text":"文件和内存管理 文件类型为FILE，typedef定义数据类型，使用时一般使用文件指针：FILE *pFile 文件打开：FILE *pFile;pFile=fopen(“文件名”,使用方式);使用方式有以下：r（只读文本文件），w（只写文本文件），a（追加文本文件，在末尾加内容），rb（只读二进制文件），wb（只写二进制文件），ab（追加二进制文件），r+（打开文件文本，可读可写），w+（打开或新建文本文件，可读可写），a+（打开文件文本，可读可在末尾写），rb+，wb+，ab+ 文件关闭fclose(文件指针)，关闭成功返回0，失败EOF fputc(字符，文件指针)，将字符写入文件；fgetc(文件指针)将文件内容读取一个一个读取；fputs(字符串，文件指针)，将字符写入文件；fgets(数组，长度n，文件指针)将文件内容n读取出来存到数组 fprintf(文件指针，格式字符串，输出列表)：fprintf(fp,”%d”,i)将i以规定格式写到文件；fscanf(文件指针，格式，输入列表)读入文件中的中值以该格式写到i fread(buffer,size,count,fp)意思是冲fp的文件中读取count次，每次读size字节，写到buffer的地址中；fwrite(buffer,size,count,fp)将buffer的size字节的数据写到fp文件中，写入count次 文件读取，写入例子FILE* file=fopen(&quot;a.txt&quot;,&quot;w+&quot;);if(file==NULL)&#123; puts(&quot;无法打开文件&quot;);&#125;fputs(&quot;1234567890&quot;,file);fclose(file);a文件的内容结果（会将原来的内容清掉）：1234567890FILE* file=fopen(&quot;a.txt&quot;,&quot;r+&quot;);char r[30];fgets(r, sizeof(r),file);printf(&quot;输出%s&quot;,r);fclose(file);结果：输出1234567890FILE* file=fopen(&quot;a.txt&quot;,&quot;w&quot;);fprintf(file,&quot;输入的数字%d&quot;,3);fclose(file);结果:a文件的内容是：输入的数字3(a里面内容是1234567890)int c;FILE* file=fopen(&quot;a.txt&quot;,&quot;r&quot;);fscanf(file,&quot;%c&quot;,&amp;c);putchar(c);fclose(file);结果：1int* c[8];FILE* file=fopen(&quot;a.txt&quot;,&quot;r&quot;);fread(&amp;c,10,2,file);printf(&quot;%s&quot;,c);fclose(file);结果：12345678char* c=&quot;123&quot;;FILE* file=fopen(&quot;a.txt&quot;,&quot;w&quot;);fwrite(c, strlen(c),1,file);fclose(file);结果：文件内容：123 程序被装载在计算机上时，会被组织成4个逻辑段：可执行代码，静态数据，动态数据（堆），栈（局部数据对象，函数的参数，调用函数和被调函数的关系 fseek(文件指针，位移量，起始点)，移动文件的指针位置（可以用来在文件中间读取修改内容）；fewind（文件指针），指针重新指到文件起始位置；ftell（文件指针）获取当前指针位置与文件开头位置的偏移量 char c[30];FILE* file=fopen(&quot;a.txt&quot;,&quot;r&quot;);fgets(&amp;c, 15,file);printf(&quot;%s\\n&quot;,c);fseek(file,1L,0);fgets(&amp;c, 15,file);printf(&quot;%s&quot;,c);fclose(file);结果：12323 动态管理（stdlib.h中）：*malloc(unsigned int size)，申请内存，返回指针；calloc(unsignedn,unsigned size)，申请n个size大小的连续内存数组，返回指针；realloc（void ptr,size_t size）将指针ptr的空间大小该为size，既可以变大，也可以变小；free（\\ptr）释放内存 内存丢失就是原来指向一个内存区域的指针指向了另一个内存区域，导致之前的内存区域无法释放管理，就是内存丢失。 网络嵌套字 使用socket TCP时，使用send和recv接受发送数据，UDP时，使用recvfrom和sendto接受发送数据。 WSAStartup函数，初始化套接字库（必须），WSAStartup（WORD,LPWSADATA），传入的数据window socket版本和WSADATA指针 socket(int af,int type,intprotocol) a af:表示一个地址家族，通常为AF_INET type:表示套接字类型，SOCK_STREAM表示创建面向连接的流式套接字；SOCK_DGRAM表示创建面向无连接的数据报套接字；SOCK_RAW表示创建原始套接字；protocol:表示套接口所用的协议，不确定设置0 调用成功返回SOCKET bind(SOCKET s,const structsockaddr FAR* name,int namelen):服务端要用。将套接字绑定在指定的端口和地址上。s：表示套接字；是一个sockaddr结构指针，当中包含了要结合的地址和端口号；namelen是name缓冲区域的长度；成功返回0，失败返回SOCKET_ERROR listen（SOCKET socket,intbacklog）：backlog表示等待连接的最大队列长度，如果设置为2，那个前两个连接时会放置在等待队列中，第三个客户端连接时会报错 accept(SOCKET s,struct sockaddFAR addr ,int FAR addrlen)addr: 是一个sockaddr结构指针，当中包含了要结合的地址和端口号；addrlen用于接收addr的长度，返回值表示已经接受的客户端连接，后续都用新的socket closesocket(SOCKET s)关闭socket connect(SOCKET s,const structsockaddr FAR* name,int namelen)，值与bind一样（子机） u_short Htons(u_short hostshort):将16位的无符号短整型数据由主机排列方式转换到网络排列方式。hostshort：一个主机排列方式的16位的无符号短整型数据；返回值：一个16位网络排列方式的数据 u_long Htonl(u_long hostlong);Htons一样，16位长整型数据 unsigned long iner_addr(constchar FAR* cp)：cp表示地址的字符串，返回32位无符号长整型 recv(SOCKET s,const char FARbuf,int len,int flags)：buf表示接收数据的缓存区，len表示buf的长度，flags表示函数的调用方式，如果是MSG_PEEK表示查看传来的数据，在序列前段的数据会被复制一份到返回缓冲区中，但是这个数据不会从序列中移走；如果是MSG_OOB，就说明是外带数据（一般传0） *send(SOCKET s,const char FARbuf,int len,int flags)，字段意思跟recv一样 *recvfrom(SOCKET s, char FARbuf, int len,int flags, struct socketaddr FAR from,int FAR* fromlen):前面跟之前的一样，from是一个指向地址结构的指针，用来接收发送方的地址信息；fromlen是缓冲区的长度 sendfrom(SOCKET s, char FARbuf, int len,int flags, struct socketaddr FAR to,int FAR* tolen)与recvfrom一样 WASCleanup()用来释放初始化时的资源","categories":[{"name":"C语言","slug":"C语言","permalink":"https://earthwo.github.io/categories/C语言/"}],"tags":[{"name":"C语言","slug":"C语言","permalink":"https://earthwo.github.io/tags/C语言/"}]},{"title":"C语言学习笔记(三)","slug":"C语言学习笔记-三","date":"2017-03-06T02:45:25.000Z","updated":"2019-03-11T07:35:22.315Z","comments":true,"path":"2017/03/06/C语言学习笔记-三/","link":"","permalink":"https://earthwo.github.io/2017/03/06/C语言学习笔记-三/","excerpt":"","text":"结构体和共同体 结构体，有点像java的类：struct 结构体名{成员列表} struct Man&#123; int age; int sex;&#125;;或者：struct Man&#123; int age; int sex;&#125;man; 使用结构体的成员变量时使用结构体名.成员名 初始化结构体时可以直接加括号；也可以直接定义结构体数组初始化结构体数组:; man[]=&#123;&#123;…&#125;,&#123;…&#125;&#125;struct Man&#123; int age; int sex;&#125;man=&#123;2,4&#125;;或者是:struct Man&#123; int age; int sex;&#125;函数中:struct Man man=&#123;2,4&#125;;或者是:structMan&#123; int age; int sex;&#125;man[3];struct Man man[3];man=&#123;&#123;&#125;,&#123;&#125;,&#123;&#125;&#125;; 结构体指针：结构体类型 指针名，使用其成员时：(\\pMan).age（一定要括起来），还有一种方法是pMan-&gt;成员名，同时结构体指针不能直接初始化 struct Man&#123; int age; int name;&#125;m=&#123;10,89&#125;; struct Man *man;man=&amp;m;printf(&quot;%d\\n&quot;,(*man).age//或者是printf(&quot;%d&quot;,man-&gt;age);结果是：1010 结构体作为函数参数时，要使用关键字struct：void a(struct Man man)。传递结构体时需要传递的数据较大，所以可以传递结构体的指针代替void a(struct Man *man) int printMan(struct Man *m)&#123; printf(&quot;%d&quot;,m-&gt;name); return 0;&#125;调用：printMan(&amp;m);结果：89 *malloc(unsigned int size)，在内存中动态分配一块size大小的内存空间，会返回一个指针，错误时返回NULL；*calloc(unsigned n,unsigned size)，该函数是在内存中动态分配n个长度为size的连续内存数组；free(void*ptr)该函数由指针指向内存去，使部分内存区能被其他变量使用 struct Man* man;man=(struct Man*)malloc(sizeof(struct Man)); //申请Man大小的空间，再将该空间的指针强行转为 //struct Man*指针free(man); //将man内存空间回收掉 共同体和结构体很像：union 共同体名{成员变量列表}变量列表；区别是结构体定义了多个数据组成的特殊类型，共同体是所有数据成员的共享的内存，所有共同体在同一时刻只能有一个值，属于某一个数据成员。所以共同体的内存大小为其成员中最大的内存大小 union Page&#123; int p; char *t[1];&#125;;printf(&quot;%d&quot;, sizeof(union Page));结果：8 union Man{int age;char name};union Man man;man.age=12;那么man.name也是12（12的ascii码）（测试多种情况，如字符串）；其初始化为：man={12}; union Page&#123; int p; char t[10]; char* m[10];&#125;;union Page page=&#123;13,19&#125;;printf(&quot;%d，%d&quot;,*page.m,*page.t);结果：13,13 枚举enum 例子如下：如果Red为1，Green就自动会加1。使用枚举直接使用Red enum Color( Rad, Green)；enum Color( Rad=1, Green) printf(&quot;%d，%d&quot;,Rad,Green); 结果：1，2 位运算和宏定义 位运算：&amp;与，|或，~取反，^按位异或（两个位相同为0，不同为1），&lt;&lt;左移，&gt;&gt;右移 循环位移，将数据左移，左边移除部分重新添加到右边(a&gt;&gt;(32-T))|(a&lt;T) 位段是特殊的结构类型，其所有的成员的长度均已二进制位为单位定义的，结构中的成员称为位段：结构机构名{类型变量名:长度; 类型变量名2:长度;}。如下：位段必须是int、unsigned和signed中的一种 struct status&#123; unsigned sign:1; unsigned zero:2;&#125;flags; 位段可以加入无名位段，使后面位段从后面空位置开始存储：unsigned :0;可以使用%d等输出位段 宏定义 #define 宏名数据（不需要分号）;使用#undef TEST终止宏定义（测试终止后继续使用，停止后再次使用，编译会出问题，比如在另一个方法中停止，经过测试稍微复杂一点程序就不能直接识别可以运行）;宏定义用于预处理，只做符号替换，不分配内存 printf(&quot;%d&quot;,TAG);#undef TAG;printf(&quot;%d&quot;,TAG); //编译不通过printf(&quot;%d\\n&quot;,TAG);undef();printf(&quot;%d&quot;,TAG);结果为1 1 带参数的宏定义：#define 名(参数表)字符串，使用时参数最好带括号，不然可能会错。如#define MIX(a,b)(a*b+b)，使用时如果是MIX(1,2),则正确，如实MIX(1,1+2),则会这样算11+2+1+2，结果错误，所以最好是((a)(b)+(b)),同时调用时最好也加括号，如5MIX(1,2)，会成为51*2+2，所以最好在最外面加括号 #define MIX(a,b)(a*b+b)printf(&quot;%d，%d&quot;,MIX(2,3),MIX(2+1,3));结果为：8，9 #include&lt;&gt;和#include””一样，引入的头文件一般是.h，一般会在该文件中放置宏定义、结构、联合、枚举、typedef声明、外部函数声明，全局变量声明 #if命令，含义是如果#if后面的表达式为真，则编译#if和#endif之间的代码，否则不编译：#if 表达式语句段 #endif，这个与if很像，#elif效果和else if一样，#else和else一样，最后都要#endif结尾 #ifdef，判断宏定义常量是否被定义，@ifdef 宏名语句段 #endif，其他用法与#if一样；#ifndef作用与#ifdef相反，用法一样 预宏定义名：__LINE__ 当前被编译的代码的行号；__FILE__当前源文件的名称；__DATA__当前源文件的创建日期； __TIME__ 当前源文件的创建时间；__STDC__判断当前编译器是否是标准C，若是1则是，否则不是 #line：改变行号和文件名 #line行号/文件名，该文件中输出行号和文件名会改变；#pragma：指定编译器状态 @pragma 参数，有一下几个参数：message：在输出窗口中输出信息；code_seg：设置程序中函数代码存放的代码段；once：保证头文件被编译一次 #line 12 &quot;main.c&quot;; //代表该行下面那行行号是12","categories":[{"name":"C语言","slug":"C语言","permalink":"https://earthwo.github.io/categories/C语言/"}],"tags":[{"name":"C语言","slug":"C语言","permalink":"https://earthwo.github.io/tags/C语言/"}]},{"title":"C语言学习笔记(二)","slug":"C语言学习笔记-二","date":"2017-03-06T01:27:45.000Z","updated":"2019-03-11T07:35:22.315Z","comments":true,"path":"2017/03/06/C语言学习笔记-二/","link":"","permalink":"https://earthwo.github.io/2017/03/06/C语言学习笔记-二/","excerpt":"","text":"函数和指针 处理字符串的方法(需要string.h)：strcpy(a,b)：把b复制给a；strcat(a,b)。在这里需要注意的是，a,b都是数组如int[]。；strcmp(a,b)：把b连到a后面；strcmp(a,b)：比较a，b是否相等（a、b既可以是数组，也可以是地址）；strupr(a)把字符串变大写，strlwr(a)把字符串变小写，这两个函数不是标准的函数，只能在vc里使用；strlen(a)获取字符串长度（测试sizeof(a),sizeof(a)会返回整个字符串空间的长度；time()获取时间，localtime换位当前时间，使用它时需要time.h char a[10]=&quot;123&quot;;char b[10]=&quot;abc&quot;;strcpy(a,b);printf(&quot;a的值为%s&quot;,a);结果：a的值为abcchar a[10]=&quot;123&quot;;char b[10]=&quot;abc&quot;;strcat(a,b);printf(&quot;a的值为%s&quot;,a);结果：a的值为123abcchar a[10]=&quot;123&quot;;char b[10]=&quot;abc&quot;;printf(&quot;值为%d&quot;,strcmp(a,b));结果：值为-46char a[40]=&quot;13&quot;;printf(&quot;a的长度为%d,a的size为%d&quot;,strlen(a), sizeof(a));结果：a的长度为2,a的size为40 time_t now; time(&amp;now); t=localtime(&amp;now); printf(&quot;%d-%d-%d&quot;,t-&gt;tm_year+1900,t-&gt;tm_mon+1,t-&gt;tm_mday); 结果：2017-3-6 C语言中方法叫函数。Main函数返回0表示执行完，返回char和int互通。 当把数据作为指针在函数中传过去时：如int a[10]；function(int* a);function(a)；这样相当于把a[10]的地址传过去，function可以操作a[1]等（测试传普通的int值时报错） int a[2]=&#123;1,4&#125;;function(a);printf(&quot;%d&quot;,a[1]);int function(int *a)&#123; a[1]=7; return 0;&#125;结果：7 内部函数就是static 修饰的函数，内部函数只能在该文件内部使用，外部函数为extern修饰的函数，外部函数可以被其他的文件调用，而不用引入其头文件，但需要在文件中先声明调用的外部函数：如：extern void a()；a在另一个文件中，但是也可以直接调用。（在例子中，如果main.c也有叫a的方法，编译报错） 文件a.c:extern int a()&#123; return 8;&#125;main.c:extern int a();int main() &#123; printf(&quot;%d&quot;,a());&#125;结果：8 数学函数（需要有头文件\\&lt;math.h&gt;）：abs(int a)， labs(long a)，fabs(double a)求绝对值，sin(doublea)，cos(double a)，tan(double a) 字符和字符串函数（ctype.h）：isalpha(int a)判断是否为字母（a-z/A-Z）,isdigit(int a)判断是否为数字，isalnum(int a)判断是否为字母和数字 char a=&apos;1&apos;;printf(&quot;%d&quot;,isalpha(a));char b=&apos;a&apos;;printf(&quot;%d&quot;,isalpha(b));结果：01 指针变量形式：类型说明 变量名；指针变量的赋值：&amp;a 如：int a=4;int p=&amp;a（int p;p=&amp;a）;表示把a的地址指给p(定义完指针后赋值不需要) int a=1;int *p=&amp;a;int *t=a;printf(&quot;%d\\n&quot;,p);printf(&quot;%d&quot;,t);结果：-450497048123 int指针，输入char类型scanf(“%c”,p)，输出时为char类型的值 int *t;scanf(&quot;%c&quot;,t);printf(&quot;%d&quot;,*t);结果：A65 *变量表示的是指针变量所指向的值，是取值，&amp;变量是表示变量的地址，&amp;是取地址，两者叠加则效果叠加，如&amp;则是先去取地址在去取值 指针加减表示地址加减，int类型地址+1，地址进4；当把数组a的首个元素赋值给指针时，就相当于把整个数组赋值给一样。数组赋值指针：int *p;int a[5];p=a(不需要&amp;);p+n表示数组的第n个元素；p++表示指针移到下个数据；p++表示指针的地址移到下个数据，这些都是数组时才行 int a[5]=&#123;1,2,3,4,5&#125;; int *p; p=a; printf(&quot;%d\\n&quot;,*(p+1)); p++; printf(&quot;%d\\n&quot;,p[0]); (*p)++; printf(&quot;%d\\n&quot;,p[0]); 结果： 2 2 3 指针是二维数组时，（p+n）+m，表示a[n][m]的数据的指针，数据则为((p+n)+m)，无论几维，*(p+n)等价于a[n] 指向指针的指针：类型标识符 指针变量名如:int a,等同于int (p) C语言中实参变量和形参变量之间的数据传递是单向的值传递，传递指针变量也是如此，但可以改变指针变量所指向的变量的值","categories":[{"name":"C语言","slug":"C语言","permalink":"https://earthwo.github.io/categories/C语言/"}],"tags":[{"name":"C语言","slug":"C语言","permalink":"https://earthwo.github.io/tags/C语言/"}]},{"title":"C语言学习笔记(一)","slug":"C语言学习笔记(一)","date":"2017-03-05T09:31:53.000Z","updated":"2019-03-11T07:35:22.315Z","comments":true,"path":"2017/03/05/C语言学习笔记(一)/","link":"","permalink":"https://earthwo.github.io/2017/03/05/C语言学习笔记(一)/","excerpt":"","text":"大学时期学过C语言，但是各种原因学的不是很完整，同时由于时间久远，很多内容也有点忘记了。所以找了点时间看了一本C语言的入门书籍，快速的把遗忘的和之前没学到的C语言的基础知识简单学习一下，写个笔记以便后面查询。 编程规范 代码缩进统一为4个字符，使用tab 常量名全部使用大写，成员变量用m_开始，普通变量，要在前面添加类型的首字母，且名称的首字母要大写如iAge，指针要加p，且首字母大写，如char* pName 函数名首字母大写，后面大小写混合# 数据类型 指针类型的值表示是某个内存地址 无符号短整型范围为0~65535，有符号时范围为-32768~32767，1000L表示长整型，1000U表示短整型（不分大小写） 在常数前加0表示8进制（数字0，如012）（8进制数据不能出现9）,0x表示16进制 Double类型的数据表示也为L，如100.89L putchar方法可以打印出char字符，printf方法可以打印出有格式的输出，包含整型、浮点、字符、字符串等 系统会在字符串结尾添加“\\0”，所以”H”的长度为2，字符串为定义一般为char*，需测试。如果定义char a[2]=”12345”,那么a的size就是2 char mm[]=&quot;a&quot;;char mn=&apos;a&apos;;printf(&quot;%d\\n&quot;, sizeof(mm));printf(&quot;%d&quot;, sizeof(mn));输出：21 浮点类型除了float和double外，还有长双精度类型long double 输出时用%f代替浮点型数据，%d代替整型，%c代替字符，%s代替字符串 输出是字符和int可以相互代替，如%c，输出int，会输出该int值的char值，同理%d C程序中可以选择变量的不同存储形式，有自动auto，静态static，寄存器register和外部extern，默认情况下就是auto 。如auto inta=3就是int a=3；Register能让程序员把某个局部变量存放在计算机的某个硬件寄存器中而不是内存中。这些不是很理解，据书上说作用不大；Extern声明了程序中将要用到但尚未定义的外部变量。如在a文件中声明extern int a;在b文件中赋值：int a=100；那么在a文件中输出a就是100。 main.c文件：extern int e;int main()&#123; printf(&quot;%d&quot;,e);&#125;a文件：int e=100;最后输出：100 运算符合表达式，输入输出 不同类型之间可以进行混合运算，int和char相加就是int和char的ASCII码相加 逗号表达式，多个表达式分别计算，用逗号隔开，值为第一个表达式，如果用括号括了起来，就是做后的值，逗号表达式不能在初始化时使用 int a=1+0,2+2; /* 编译器报错 */正确使用：int a;int b;a=1+0,2+2;b=(1+0,2+2);printf(&quot;a值%d,b值%d&quot;,a,b)结果：a值1,b值4 字符输出putchar，需要stdio库，只能输出单个字符，字符输入用getchar 字符串输出用puts，打印时如果字符串里面有\\0，会被截断，后面部分不会打印,输入用gets,char[]和字符串可以相互通用如:char a[10];gets(a); 格式输出printf(“格式”,内容)常用的可是有%d，%o（8进制），%x/%X(16进制，大写时输出也为大写)，%c，%s，%f，如果要输出%，则%% 输出时可以添加附加符号：比如%ld，表示输出长整型，%10s，表示输出10位字符串，如果超过则超过，不超过则前面不空格，%-10s，不足10位时右边补空格，%10.3s，不足10位前面补空格，取字符串的3位,如果是int之类的数据，%10.3d表示输出的除了前面补空格外，输出3位数，如4就输出004，%-10.3s，不足10位后面补空格，取3位。 int a=3;printf(&quot;a的值%10.3d&quot;,tt);结果：a的值 003 输入格式数据scanf(“%d%d”,&amp;a,&amp;b)，同样可以添加相应的附加符号如%ld，%hd（短类型）%3s，表示输入的取3位，(%d%d,a,b)表示输入不赋值。b的值不会变.%s表示输入的字符数组，如a[]，不能是地址\\p char a[10];scanf(&quot;%s&quot;,&amp;a);printf(&quot;输入的值为%s&quot;,a);结果为：12q输入的值为12q ​","categories":[{"name":"C语言","slug":"C语言","permalink":"https://earthwo.github.io/categories/C语言/"}],"tags":[{"name":"C语言","slug":"C语言","permalink":"https://earthwo.github.io/tags/C语言/"}]},{"title":"android自定义键盘","slug":"android自定义键盘","date":"2017-03-04T11:10:47.000Z","updated":"2019-03-11T07:35:22.323Z","comments":true,"path":"2017/03/04/android自定义键盘/","link":"","permalink":"https://earthwo.github.io/2017/03/04/android自定义键盘/","excerpt":"","text":"在某些安全性比较高的软件，如银行的相关软件中，输入密码等操作时往往会弹出自定义的软键盘。如果输入的只有数字，开发者往往会通过自定义View和TextView的方式实现，这种方式可以避免第三方键盘的调起。但是如果需要在editview中实现时，就需要实现自己的键盘。 实现自定义键盘主要有两个类：Keyboard和KeyboardView。 Keyboard类主要是用于监听虚拟键盘，它里面有内部类Key和Row，用以记录按键和行的相关信息。KeyBoardView则主要是根据Keyboard中按键的信息，绘制所有的key，同时根据触摸位置，计算出点击的Key，通过OnKeyboardActionListener回调进行事件和string值的传递。 定义KeyboardView首先要在layout文件夹中定义KeyboardView： &lt;android.inputmethodservice.KeyboardView android:id=&quot;@+id/keyboard&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; app:layout_constraintTop_toBottomOf=&quot;parent&quot; app:layout_constraintLeft_toLeftOf=&quot;parent&quot; app:layout_constraintRight_toRightOf=&quot;parent&quot; app:layout_constraintBottom_toBottomOf=&quot;parent&quot; android:keyBackground=&quot;@drawable/shape_key_background&quot; android:labelTextSize=&quot;15dp&quot; android:keyPreviewHeight=&quot;50dp&quot; android:popupLayout=&quot;@layout/layout_poplayout&quot; android:keyPreviewLayout=&quot;@layout/layout_key_preview&quot;/&gt; 这里有几个重要的定义，一个是keyBackground，这个是按键的背景，一个是 keyPreviewLayout，这个是按键之后的预览样式，还有一个是popupLayout，这个是长按之后的预览样式。同时，这里还有一个要注意的是，这边的KeyboardView的id和popupLayout里面的KeyboardView的id一定是android:id=&quot;@+id/keyboard&quot;，不然会无法找到KeyboardView。 自定义键盘的样式Keyboard定义好KeyboardView之后，需要定义里面具体键盘的样式。在res目录下xml文件夹，当中新建一个xml文件。 &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;Keyboard xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:keyWidth=&quot;20%p&quot; android:horizontalGap=&quot;1.5%p&quot; android:verticalGap=&quot;7dp&quot; android:keyHeight=&quot;60dp&quot; &gt; &lt;Row&gt; &lt;Key android:codes=&quot;45&quot; android:keyLabel=&quot;-&quot; android:keyWidth=&quot;15.5%p&quot;/&gt; &lt;Key android:codes=&quot;49&quot; android:keyLabel=&quot;1&quot;/&gt; &lt;Key android:codes=&quot;50&quot; android:keyLabel=&quot;2&quot;/&gt; &lt;Key android:codes=&quot;51&quot; android:keyLabel=&quot;3&quot;/&gt; &lt;Key android:codes=&quot;119&quot; android:keyLabel=&quot;w&quot; android:popupCharacters=&quot;@string/symbol_w&quot; android:popupKeyboard=&quot;@layout/layout_poplayout&quot;/&gt; &lt;Key android:codes=&quot;8&quot; android:keyIcon=&quot;@drawable/key_delete&quot; android:keyWidth=&quot;15.5%p&quot; android:isRepeatable=&quot;true&quot;/&gt; &lt;/Row&gt; ...&lt;/Keyboard&gt; 里面有KeyboardKeyboard作为根节点，定义了keyWidth，keyHeight和上下的偏移量。里面有row节点和key节点。key节点和Row节点都可以再次定义相应的行高和宽高，同时，还可以在key中定义其按下的值codes，key显示的值keylabel，key的图标keyIcon，长按的值popupCharacters和长按样式popupKeyboard等属性。里面有一个重要的属性isRepeatable，表示长按后是否有连续点击的效果，比如删除按钮就会有该效果。 定义InputMethodService定义好键盘的样式后，需要将键盘显示出来，这时就需要定义InputMethodService。 自定义一个类继承InputMethodService，并且实现OnKeyboardActionListener接口。 public class ZFIme extends InputMethodService implements KeyboardView.OnKeyboardActionListener &#123; @Override public View onCreateInputView() &#123; keyboardView = (KeyboardView) getLayoutInflater().inflate(R.layout.keyboard, null); mKeyboard = new Keyboard(this, R.xml.keys); keyboardView.setKeyboard(mKeyboard); keyboardView.setOnKeyboardActionListener(this); return keyboardView; &#125; @Override public void onPress(int primaryCode) &#123; &#125; @Override public void onRelease(int primaryCode) &#123; &#125; @Override public void onKey(int primaryCode, int[] keyCodes) &#123; getCurrentInputConnection().commitText(Character.toString((char) primaryCode),1); &#125; @Override public void onText(CharSequence text) &#123; &#125; @Override public void swipeLeft() &#123; &#125; @Override public void swipeRight() &#123; &#125; @Override public void swipeDown() &#123; &#125; @Override public void swipeUp() &#123; &#125;&#125; 在onCreateInputView方法中，获取刚才定义的KeyboardView，并且创建keyboard，传入定义好的键盘keys，将keyboard设置给KeyboardView，并且返回。 同时，在onkey方法中将按下的信息传递出去getCurrentInputConnection()方法返回一个InputConnection实例，可以通过它对调起键盘的edittext进行相应的操作，比如文字的输入、删除等。 注册服务将刚才定义的InputMethodService注册到AndroidManifest中 //首先要申请绑定输入的权限&lt;permission android:name=&quot;android.permission.BIND_INPUT_METHOD&quot;&gt;&lt;/permission&gt;//注册service &lt;service android:name=&quot;.ZFIme&quot; android:permission=&quot;android.permission.BIND_INPUT_METHOD&quot; &gt; &lt;meta-data android:name=&quot;android.view.im&quot; android:resource=&quot;@xml/method&quot;/&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.view.InputMethod&quot; /&gt; &lt;/intent-filter&gt; &lt;/service&gt; 在xml中定义： &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;input-method xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;subtype android:label=&quot;正风键盘&quot; android:imeSubtypeLocale=&quot;english&quot; android:imeSubtypeMode=&quot;keyboard&quot;&gt; &lt;/subtype&gt;&lt;/input-method&gt; 到这里为止，我们就可以在设置里面找到自己定义的键盘，在输入时切换到自己的键盘，实现很多自己的功能。但是，从上面的代码可以看到，这些是自定义键盘最基础的步骤，如果需要实现自己的功能，比如整个键盘的背景（系统默认为黑色），自定义的长按功能，多个字符同时在一个key上显示等功能，只是这些是远远不够的，需要定义KeyboardView和Keyboard，至于这些实现这些，请等待后续文章。","categories":[{"name":"自定义键盘","slug":"自定义键盘","permalink":"https://earthwo.github.io/categories/自定义键盘/"}],"tags":[{"name":"自定义键盘","slug":"自定义键盘","permalink":"https://earthwo.github.io/tags/自定义键盘/"}]},{"title":"NDK学习笔记(四)","slug":"NDK学习笔记-四","date":"2017-02-08T01:16:41.000Z","updated":"2019-03-11T07:35:22.319Z","comments":true,"path":"2017/02/08/NDK学习笔记-四/","link":"","permalink":"https://earthwo.github.io/2017/02/08/NDK学习笔记-四/","excerpt":"","text":"在开发NDK的过程中，我们会发现，一旦程序出现异常，程序会直接闪退，而且不会有相关的日志，只会留下类似这样的一句话： A/libc: Fatal signal 11 (SIGSEGV), code 1, fault addr 0x0 in tid 1656 (telife.jnistudy) 一旦遇到这样的错误信息，我们即找不到错误的原因，也找不到出错的地方，根本无从改起。 那要怎么办呢？ ndk-stackndk-stack 工具让您可以在堆叠追踪出现在 adb logcat 的输出中时过滤它们。 它还可以从源代码将共享库中的任意地址替换为对应的 &lt;source-file&gt;:&lt;line-number&gt; 值，从而更容易找出问题所在。 adb logcat |library/android-ndk-r14b/ndk-stack -sym $PROJECT_PATH/obj/local/armeabi 具体的错误信息： ********** Crash dump: **********Build fingerprint: &apos;PAX/CB03/CB03:5.1.1/LMY47V/CB03_CH_V4.70_S:user/test-keys&apos;pid: 3136, tid: 3136, name: telife.jnistudy &gt;&gt;&gt; win.whitelife.jnistudy &lt;&lt;&lt;signal 11 (SIGSEGV), code 1 (SEGV_MAPERR), fault addr 0x0Stack frame #00 pc 000009e8 /data/app/win.whitelife.jnistudy-1/lib/arm/libArray_test.so (_JNIEnv::GetIntArrayRegion(_jintArray*, int, int, int*)+31)Stack frame #01 pc 00000965 /data/app/win.whitelife.jnistudy-1/lib/arm/libArray_test.so (Java_win_whitelife_jnistudy_java_JavaHelper_setArray+64)Stack frame #02 pc 000a21b1 /system/lib/libart.so (art_quick_generic_jni_trampoline+32)Stack frame #03 pc 001d8ce9 /system/lib/libart.so (art::mirror::ArtMethod::Invoke(art::Thread*, unsigned int*, unsigned int, art::JValue*, char const*)+132) 这样，你就可以看到在源文件具体哪里出现了错误。 异常处理刚刚讲了如何在出现错误的时候将错误信息打印出来，那后面要讲如果是在调用java层代码时出现错误，该如何处理。我们知道，在java中调用出现错误时，程序会直接闪退。但是在native层调用java出现错误时，程序不会直接闪退，而是会走完整个函数。在java中我们可以通过try-catch来捕获异常进行处理，而在native中也有类似的方法来捕获异常。 ExceptionCheck异常判断，可以通过该方法，判断在调用java代码之后是否出现异常。 ExceptionDescribe打印错误信息，将错误信息打印到日志中。 ExceptionClear将扔出的错误信息清除，这样程序不会在抛出错误。 ThrowNew抛出java异常，将异常作为java异常抛出去。 if(env-&gt;ExceptionCheck())&#123; env-&gt;ExceptionDescribe();//打印异常 env-&gt;ExceptionClear();//清除异常 jclass c=env-&gt;FindClass(&quot;java/lang/Exception&quot;); env-&gt;ThrowNew(c,&quot;出错了&quot;);&#125;","categories":[{"name":"ndk","slug":"ndk","permalink":"https://earthwo.github.io/categories/ndk/"}],"tags":[{"name":"ndk","slug":"ndk","permalink":"https://earthwo.github.io/tags/ndk/"}]},{"title":"NDK学习笔记(三)","slug":"NDK学习笔记-三","date":"2017-01-07T01:31:38.000Z","updated":"2019-03-11T07:35:22.319Z","comments":true,"path":"2017/01/07/NDK学习笔记-三/","link":"","permalink":"https://earthwo.github.io/2017/01/07/NDK学习笔记-三/","excerpt":"","text":"在ndk开发中，很多时候并不需要我们实现全部的代码，往往可以通过NDK的API来实现相应的功能，那么ndk中要如何使用NDK的api呢？ 添加 NDK API在介绍如何使用NDK的api时，会以打印的log为例，该包可以实现将native层的信息打印到log中。 首先，我们需要在源文件中引入log的头文件： #include &lt;android/log.h&gt; 引入头文件后，我们需要在CmakeLists文件中做相应的配置： find_library( # 定义库名字(这个名字可以自定义) log-lib #定义库(这是log库) log )target_link_libraries( # 需要关联的库 String_test # 关联库 $&#123;log-lib&#125;) 配置完之后就可以在文件中使用了。 在log.h文件中，可以看到打印函数： int __android_log_print(int prio, const char* tag, const char* fmt, ...) 同时也可以看到不同的打印类型： typedef enum android_LogPriority &#123; ANDROID_LOG_UNKNOWN = 0, ANDROID_LOG_DEFAULT, /* only for SetMinPriority() */ ANDROID_LOG_VERBOSE, ANDROID_LOG_DEBUG, ANDROID_LOG_INFO, ANDROID_LOG_WARN, ANDROID_LOG_ERROR, ANDROID_LOG_FATAL, ANDROID_LOG_SILENT, /* only for SetMinPriority(); must be last */&#125; android_LogPriority; __android_log_print函数需要传入至少3个参数，一个是打印类型，一个tag标签，一个是具体的value值。但是我们可以看到，该方法名字较长，传入的参数也比较多，使用起来不是很方便。所以在这种情况下，我们一般会使用宏定义来方便调用。 #define TAG &quot;native打印&quot;#define LOGV(...) __android_log_print(ANDROID_LOG_DEBUG,TAG,__VA_ARGS__); 首先是要定义打印的标签，标签就是一个普通的字符串，后面用到了不定参数。 使用时： LOGV(&quot;%s&quot;,&quot;输出的值&quot;); 调用Java静态方法和静态变量调用静态方法和静态变量时主要有3步：首先，要获取到需要调用的类，获取到调用的类之后，要获取需要调用端静态变量或静态方法，最后调用相应的方法和变量。 获取类的示例： jclass clas=env-&gt;FindClass(&quot;win/whitelife/jnistudy/java/JavaHelper&quot;); 获取类需要用到FindClass函数，输入类的完整路径，中间的点由/代替，FindClass返回一个jclass，代表被调用的类。 然后需要得到调用的静态变量或方法的methodID或jfiedlID： //找到要调用的静态变量jfieldID _fieldId=env-&gt;GetStaticFieldID(clas,&quot;staticAge&quot;,&quot;I&quot;);//找到要调用的静态方法jmethodID _methodId=env-&gt;GetStaticMethodID(clas,&quot;getStaticName&quot;,&quot;(Ljava/lang/String;)Ljava/lang/String;&quot;); GetStaticFieldID和GetStaticMethodID函数主要需要3个参数，一个是之前获取到的jclass变量，另一个是调用的变量或调用的方法的名字，最后是该方法或变量的签名。 什么是签名呢？我们知道Java是有重载方法的，可以定义方法名相同，但参数不同的方法，正因为如此，在JNI中仅仅通过方法名是无法找到 Java中的具体方法的，JNI为了解决这一问题就将参数类型和返回值类型组合在一起作为方法签名。通过方法签名和方法名就可以找到对应的Java方法。 java类型 签名 所有对象 L+classname +; Class Ljava/lang/Class; String Ljava/lang/String; Throwable Ljava/lang/Throwable; byte B char C double D float F int I short S long J boolean Z 数组 [+类型 从上表可以看到，除了boolean和long类型，其他的基本类型都是首字母大写，而数组类型都是[+基本类型，如int[]则是[I；而对象都是L+完整的类路径。可是依旧记不住怎么办，可以通过命令直接生成签名。 通过这个签名，我们就可以定位到具体的java方法和变量了。 最后调用相应的方法和变量： env-&gt;SetStaticIntField(clas,_fieldId,111);//设置数据env-&gt;GetStaticIntField(clas,_fieldId);//获取数据jstring j=env-&gt;NewStringUTF(&quot;静态方法构建的名字&quot;);jstring o=(jstring)env-&gt;CallStaticObjectMethod(clas, _methodId, j); 调用实例方法和成员变量调用实例方法和成员变量与调用静态的差不多，区别是在获取到jclass之后，还需要调用其构造方法，产生实例。 jmethodID _consMethodId=env-&gt;GetMethodID(clas,&quot;&lt;init&gt;&quot;,&quot;(I)V&quot;); //获取构造方法的methodIDjobject ob=env-&gt;NewObject(clas,_consMethodId,612);//创建实例 在创建实例之后，就可以调用其方法或变量了： //找到要调用的静态方法jfieldID _fieldId=env-&gt;GetFieldID(clas,&quot;age&quot;,&quot;I&quot;); //获取数据env-&gt;SetIntField(ob,_fieldId,123); //设置数据","categories":[{"name":"ndk","slug":"ndk","permalink":"https://earthwo.github.io/categories/ndk/"}],"tags":[{"name":"ndk","slug":"ndk","permalink":"https://earthwo.github.io/tags/ndk/"}]},{"title":"NDK学习笔记(二)","slug":"NDK学习笔记-二","date":"2016-12-26T08:21:59.000Z","updated":"2019-03-11T07:35:22.319Z","comments":true,"path":"2016/12/26/NDK学习笔记-二/","link":"","permalink":"https://earthwo.github.io/2016/12/26/NDK学习笔记-二/","excerpt":"","text":"之前的文章中我详细的介绍了第一个NDK程序，后面要讲讲如何使用jni的接口，实现更多的功能。 jstring相关方法首先要讲讲jstring相关方法。 NewStringUTFNewStringUTF函数传入一个字符串，返回jstring对象。 char p[20]=&quot;hello&quot;;return env-&gt;NewStringUTF(p);或者char *p=&quot;hello&quot;;return env-&gt;NewStringUTF(p);或者std::string hello = &quot;hello&quot;;return env-&gt;NewStringUTF(hello.c_str());或者return env-&gt;NewStringUTF(&quot;hello&quot;); 以上4中方式在java层中返回的都是hello。 GetStringLength和GetStringUTFLengthGetStringLength函数顾名思义就是获取jstring的长度，它需要传入一个jstring对象，返回jstring的长度。 std::string hello=&quot;123456&quot;;jstring s=env-&gt;NewStringUTF(hello.c_str());return env-&gt;GetStringLength(s);//或return env-&gt;GetStringUTFLength(s); 两个方法的区别是GetStringUTFLength获取jstring的UTF-8编码字符串的长度，而GetStringLength函数是获取Unicode编码的jstring字符串长度。这里的jstring既可以通过内部创建，也可以通过外部java层传入进来，最后java层可以获取到6。 GetStringChars和ReleaseStringCharsGetStringChars函数能将jstring对象转为16位的jchar，而≈则能将内存释放。 jstring s=env-&gt;NewStringUTF(str); //创建jstring对象const jchar *p=env-&gt;GetStringChars(s,NULL); //将jstring转为16位jcharenv-&gt;ReleaseStringChars(s,p);//释放内存 GetStringUTFChars和ReleaseStringUTFCharsReleaseStringUTFChars则是将jstring数据转为字符串，而ReleaseStringUTFChars同样是是否内存 jstring s=env-&gt;NewStringUTF(&quot;hello&quot;);const char *p=env-&gt;GetStringUTFChars(s,NULL);env-&gt;ReleaseStringUTFChars(s,p); 最后字符串p的值就是hello GetStringUTFRegion和GetStringRegion这对函数会把源字符串复制到一个预先分配的缓冲区内，然后会获取Unicode和UTF-8编码字符串指定范围内的内容。 jstring s=env-&gt;NewStringUTF(&quot;hello&quot;);char p[30]=&quot;123&quot;;char *t=p+3;env-&gt;GetStringUTFRegion(s,0,3,t);return env-&gt;NewStringUTF(p); 这里有几点需要注意一下：首先它需要有一个预先分类号的缓冲区，所以需要先定义一个字符串内存区域，同时把指针指过去，然后在进行赋值，同时，如果这个函数还会做jstring越界检查，如果检查发现越界了，会抛出StringIndexOutOfBoundsException异常。而且由于它不会进行内存分配，所以不需要回收内存。 Array相关方法NewTypeArray创建固定容量的array数组，如NewIntArray，NewLongArray等。 jintArray array=env-&gt;NewIntArray(3);return array; java层能够获取到一个容量为3的int数组。 GetArrayLength获取array的长度 jintArray array=env-&gt;NewIntArray(3);return env-&gt;GetArrayLength(array); java层获取到长度3 GetTypeArrayElements将jTypeArray转化为jType *，从而可以操作里面的值。 jint *as=env-&gt;GetIntArrayElements(array,NULL);as[0]=20;return as[0];java层：public static int[] intarray=&#123;10,4,54&#125;;JavaHelper.createArray(JavaHelper.intarray);最后java层获取到的值为20 GetPrimitiveTypeArrayRegion将部分typearray数据复制到type数组 jint nativeArray[3];env-&gt;GetIntArrayRegion(array,0,3,nativeArray);for(int i=0;i&lt;3;i++)&#123; nativeArray[i]+=9;&#125;return nativeArray[0];java层传入&#123;1,2,3&#125;返回10 SetTypeArrayRegion将type数组转化为jtypeArray jint nativeArray[3];env-&gt;GetIntArrayRegion(array,0,3,nativeArray);for(int i=0;i&lt;3;i++)&#123; nativeArray[i]+=9;&#125;env-&gt;SetIntArrayRegion(array,0,3,nativeArray);return array;java层输入&#123;1,2,3,4,5&#125;，返回&#123;10,11,12,4,5&#125;","categories":[{"name":"ndk","slug":"ndk","permalink":"https://earthwo.github.io/categories/ndk/"}],"tags":[{"name":"ndk","slug":"ndk","permalink":"https://earthwo.github.io/tags/ndk/"}]},{"title":"NDK学习笔记(一)","slug":"jni学习笔记","date":"2016-12-24T13:19:08.000Z","updated":"2019-03-11T07:35:22.326Z","comments":true,"path":"2016/12/24/jni学习笔记/","link":"","permalink":"https://earthwo.github.io/2016/12/24/jni学习笔记/","excerpt":"","text":"在Android开发中，使用NDK开发越来越重要。如何在android studio中使用NDK开发，这里不再介绍，可以参考第一个ndk程序。在程序运行起来之后，接下来主要是要讲讲这个方法中相关代码的含义。 第一个程序分析首先是引入了jni.h和string.h的头文件，作为jni的程序，引入jni的相关内容是必须的，同时，因为里面还用到了string的内容，所以也引入了string的头文件。 #include &lt;jni.h&gt;#include &lt;string&gt; 接下来是extern &quot;C&quot;，这个表示该函数实现 C 和 C++ 的混合编程，用于 C++ 代码调用 C 的函数。 然后看看具体的函数： JNIEXPORT jstringJNICALLJava_library_whitelife_hellojni_JniUtil_getString( JNIEnv *env, jobject /* this */) &#123; std::string hello = &quot;哈哈哈哈&quot;; return env-&gt;NewStringUTF(hello.c_str());&#125; 首先是第一句JNIEXPORT jstring。JNIEXPORT是一个宏定义，表明该函数可被外部调用，不定义时，默认也可以被外部调用，同时调用后返回jstring。 jni里面一共有9中基本数据类型：jbyte、jchar、jshort、jint、jlong、jfloat、jdouble、jboolean、jstring，它们对应的java数据类型一目了然。 JNICALL也是一个宏定义，表示该函数是jni函数，当然，省略不写也没有影响。 然后看函数的名字：Java_library_whitelife_hellojni_JniUtil_getString。函数的名字很长，这是必须的。首先是表明该函数有java调用，调用的类第library_whitelife_hellojni_JniUtil，java类的完整路径，最后才是调用的natice方法名getstring，这些元素缺一不可。 再看传递的参数，一个是JNIEnv 指针，一个是jobject。JNIEnv是在jni.h中定义的结构体，表示jni环境，后续所有的jni接口都在里面，jobject是调用者的对象。同时这里可以看到，jobject后面没有具体的参数，这是一种省略的写法，后续如果要用到jobject，可以用this表示，当然你也可以自己补上jobject jo，然后操作jo。 看到这里，所有的jni方法都会有JNIEnv和jobject吗？不是。当java层中的native方法为static方法时，会传入JNIEnv和jclass，jcalss表示的是调用的类。同时由于该方法在调用时不带参数，如果携带相关参数的话，jni方法也会有相关的参数，当然参数类型为转为jni的类型。 然后看具体的代码： std::string hello = &quot;哈哈哈哈&quot;; std::是c++的命名空间，关于这方面的内容会在后续关于c++的文章中介绍。这个代码的意思相当于定义了一个string数据；然后调用了JNIEnv终端的函数env-&gt;NewStringUTF(hello.c_str());。NewStringUTF是jni的方法，它通过传入字符串返回一个jstring对象，而c_str()函数则将string对象变成字符串 查看JNI方法之前讲过，后续的jni方法基本都是通过JNIEnv来调用的，那么到底有哪些方法呢？首先你当然可以通过jni.h查看里面的源码，但是该文件很大，你可能很多的函数不一定能很快找到。最好的方式是通过java官网中的文档来查看相关的jni接口jni文档。里面包含了很多jni相关的概念，函数等相关内容。","categories":[{"name":"ndk","slug":"ndk","permalink":"https://earthwo.github.io/categories/ndk/"}],"tags":[{"name":"ndk","slug":"ndk","permalink":"https://earthwo.github.io/tags/ndk/"}]},{"title":"ThreadLocal解析","slug":"ThreadLocal解析","date":"2016-12-07T06:18:36.000Z","updated":"2019-03-11T07:35:22.321Z","comments":true,"path":"2016/12/07/ThreadLocal解析/","link":"","permalink":"https://earthwo.github.io/2016/12/07/ThreadLocal解析/","excerpt":"","text":"ThreadLocal是一个关于创建线程局部变量的类，为解决多线程程序的并发问题提供了一种新的思路。使用ThreadLocal创建的变量只能被当前线程访问，其他线程则无法访问和修改。那它内部是如何实现的呢？ThreadLocal对外提供三个方法：set、get和remove，那我们一次来看一下这几个方法。public void set(T value) &#123; Thread currentThread = Thread.currentThread(); Values values = values(currentThread); if (values == null) &#123; values = initializeValues(currentThread); &#125; values.put(this, value); &#125; Values values(Thread current) &#123; return current.localValues; &#125; Values initializeValues(Thread current) &#123; return current.localValues = new Values(); &#125; set方法很简洁，首先是获取当前的线程，再获取该线程的Values变量，如果线程的Values值为null，则创建新的Values给该Thread，然后将该ThreadLocal作为key，传入的值作为value，添加到Values中。那这个Values又是何方神圣呢。Values是ThreadLocald的静态类，同时又是Thread的成员变量，它内部主要维护了一个Object数组。看一下它的构造方法：Values() &#123; initializeTable(INITIAL_SIZE); this.size = 0; this.tombstones = 0; &#125; 这里有两个变量，一个是size，它表示的是数组中存储的values的数量，tombstones表示数组中无用值的数量，关于它，后面再说。接下来看initializeTable方法。private void initializeTable(int capacity) &#123; this.table = new Object[capacity * 2]; this.mask = table.length - 1; this.clean = 0; this.maximumLoad = capacity * 2 / 3; // 2/3 &#125; 首先，它会创建一个Size为传入数字的2倍的Object数组，记录数组的最大下标mask，设置清除的数组下标clean和最大的存储量maximumLoad。关于后面两个变量的用处，后面再说。接下栏看看它的put方法。void put(ThreadLocal&lt;?&gt; key, Object value) &#123; cleanUp(); // Keep track of first tombstone. That&apos;s where we want to go back // and add an entry if necessary. int firstTombstone = -1; for (int index = key.hash &amp; mask;; index = next(index)) &#123; Object k = table[index]; if (k == key.reference) &#123; // Replace existing entry. table[index + 1] = value; return; &#125; if (k == null) &#123; if (firstTombstone == -1) &#123; // Fill in null slot. table[index] = key.reference; table[index + 1] = value; size++; return; &#125; // Go back and replace first tombstone. table[firstTombstone] = key.reference; table[firstTombstone + 1] = value; tombstones--; size++; return; &#125; // Remember first tombstone. if (firstTombstone == -1 &amp;&amp; k == TOMBSTONE) &#123; firstTombstone = index; &#125; &#125; &#125; 首先是清除无用的values，这个我们后面再说。接下来是根据ThreadLocal的hash值和之前数组的最大下标mask值，计算当前threadlocal在数组中的位置。取出当前位置的值，如果值为null，且之前位置没有被占用过，则说明该threadlocal在之前完全没有存储过，就在该数组位置存储key，该位置+1存储value；如果已经存储过，就循环找到该位置更新数据；如果位置被已清除的数据占用，且其他位置没有该数据，那就在被占的位置上添加数据。从这里我们可以看到，threadlocal本身并不存储值，而是用Thread的values存储，threadlocal只是作为存储的key，而在数组存储的方式为两两并排存储，key在前，value在后。同时我们会发现几个问题，首先存储是threadlocal并不是直接将自己作为key存储，而是将自己的作为软引用来存储，其次，存储的可以会在什么时候被清除，那下面就来讲讲这两个问题。首先来讲讲为什么不直接使用强引用作为key。当我们将threadlocal作为强引用key时，当引用的threadlocal对象要被回收时，由于该Thread的Values还持有ThreadLocal的强引用，导致这个threadlocal对象就不会被回收，从而导致了内存泄漏。而如果使用软引用时，由于Values持有的是ThreadLocal的软引用，ThreadLocal会被直接回收，这时只要在将那些已经被回收的key的value清除，就不会再造成内存泄漏了。当然这种方式依旧会有泄漏的风险，因为Thread的Values的生命周期跟Thread一样长，当在一个长生命周期的Thread（如mainThread）中没有及时的remove对象，且ThreadLocal被回收了，又没有再次执行set、或get方法，那么依旧会造成内存泄漏。所以要彻底的避免泄漏，还是要及时的清除无用的threadlocal。上面说的，set和get方法会将那些已经被回收的threadlocal的值清除，那它又是怎么做的呢？这里有一个我们之前跳过的方法：cleanUp。那再来看看这个方法做了什么。private void cleanUp() &#123; if (rehash()) &#123; // If we rehashed, we needn&apos;t clean up (clean up happens as // a side effect). return; &#125; if (size == 0) &#123; // No live entries == nothing to clean. return; &#125; // Clean log(table.length) entries picking up where we left off // last time. int index = clean; Object[] table = this.table; for (int counter = table.length; counter &gt; 0; counter &gt;&gt;= 1, index = next(index)) &#123; Object k = table[index]; if (k == TOMBSTONE || k == null) &#123; continue; // on to next entry &#125; // The table can only contain null, tombstones and references. @SuppressWarnings(&quot;unchecked&quot;) Reference&lt;ThreadLocal&lt;?&gt;&gt; reference = (Reference&lt;ThreadLocal&lt;?&gt;&gt;) k; if (reference.get() == null) &#123; // This thread local was reclaimed by the garbage collector. table[index] = TOMBSTONE; table[index + 1] = null; tombstones++; size--; &#125; &#125; // Point cursor to next index. clean = index; &#125; 首先是判断数组是否需要重新设置，这个先放着。当数组的values数量不为空时，循环遍历数组。这里程序会记录之前检查过的下标为clean，这样可以减少循环次数。当位置上的key没有没有被清除掉，且key的引用被清除掉时，会将该key和其对应的值都清掉。接下来看看rehash方法，该方法用来判断是否需要扩大数组。private boolean rehash() &#123; if (tombstones + size &lt; maximumLoad) &#123; return false; &#125; int capacity = table.length &gt;&gt; 1; int newCapacity = capacity; if (size &gt; (capacity &gt;&gt; 1)) &#123; newCapacity = capacity * 2; &#125; Object[] oldTable = this.table; initializeTable(newCapacity); this.tombstones = 0; if (size == 0) &#123; return true; &#125; for (int i = oldTable.length - 2; i &gt;= 0; i -= 2) &#123; Object k = oldTable[i]; if (k == null || k == TOMBSTONE) &#123; continue; &#125; @SuppressWarnings(&quot;unchecked&quot;) Reference&lt;ThreadLocal&lt;?&gt;&gt; reference = (Reference&lt;ThreadLocal&lt;?&gt;&gt;) k; ThreadLocal&lt;?&gt; key = reference.get(); if (key != null) &#123; // Entry is still live. Move it over. add(key, oldTable[i + 1]); &#125; else &#123; // The key was reclaimed. size--; &#125; &#125; return true; &#125; 这里我们看到，当所有的值数量（被清除的值+正常的值）大于最大的数量时，或者正常的值数量到达数组范围的一半时，都会重新设置数组。更详细的说，当被清除的值数量过大时，会重新设置从序号0开始检查，并不再将那些清除的值添加到新数组；当正常的值size过大时，会将数组扩大一倍，再讲值重新添加到数组。然后我们再来看看get方法：public T get() &#123; // Optimized for the fast path. Thread currentThread = Thread.currentThread(); Values values = values(currentThread); if (values != null) &#123; Object[] table = values.table; int index = hash &amp; values.mask; if (this.reference == table[index]) &#123; return (T) table[index + 1]; &#125; &#125; else &#123; values = initializeValues(currentThread); &#125; return (T) values.getAfterMiss(this); &#125; 首先会根据threadlocal获取数据在数组位置，从线程中获取数据。如果没有数据的话，就执行getAfterMiss方法：Object getAfterMiss(ThreadLocal&lt;?&gt; key) &#123; Object[] table = this.table; int index = key.hash &amp; mask; // If the first slot is empty, the search is over. if (table[index] == null) &#123; //1 Object value = key.initialValue(); // If the table is still the same and the slot is still empty... if (this.table == table &amp;&amp; table[index] == null) &#123; table[index] = key.reference; table[index + 1] = value; size++; cleanUp(); return value; &#125; // The table changed during initialValue(). put(key, value); return value; &#125; // Keep track of first tombstone. That&apos;s where we want to go back // and add an entry if necessary. int firstTombstone = -1; // Continue search. for (index = next(index);; index = next(index)) &#123; Object reference = table[index]; if (reference == key.reference) &#123; //2 return table[index + 1]; &#125; // If no entry was found... if (reference == null) &#123; Object value = key.initialValue(); // If the table is still the same... if (this.table == table) &#123; // If we passed a tombstone and that slot still // contains a tombstone... if (firstTombstone &gt; -1 &amp;&amp; table[firstTombstone] == TOMBSTONE) &#123; table[firstTombstone] = key.reference; table[firstTombstone + 1] = value; tombstones--; size++; // No need to clean up here. We aren&apos;t filling // in a null slot. return value; &#125; // If this slot is still empty... if (table[index] == null) &#123; table[index] = key.reference; table[index + 1] = value; size++; cleanUp(); return value; &#125; &#125; // The table changed during initialValue(). put(key, value); return value; &#125; if (firstTombstone == -1 &amp;&amp; reference == TOMBSTONE) &#123; // Keep track of this tombstone so we can overwrite it. firstTombstone = index; &#125; &#125; &#125; 该方法比较长，但是核心就几处。首先是1处，当位置上的key为null时，说明之前没有数据存储过，那就返回null，同时将null作为值添加到数组；其次是2处，从原位置+2处开始遍历循环数组，如果位置上的数据为key的reference，那就直接返回值；如果如果位置上的数据为不是key的reference，这说明之前的key被回收清除了，那么就将null作为值添加到该清除位置同时返回null。最后再来看看remove方法：public void remove() &#123; Thread currentThread = Thread.currentThread(); Values values = values(currentThread); if (values != null) &#123; values.remove(this); &#125; &#125;... void remove(ThreadLocal&lt;?&gt; key) &#123; cleanUp(); for (int index = key.hash &amp; mask;; index = next(index)) &#123; Object reference = table[index]; if (reference == key.reference) &#123; // Success! table[index] = TOMBSTONE; table[index + 1] = null; tombstones++; size--; return; &#125; if (reference == null) &#123; // No entry found. return; &#125; &#125; &#125; remove方法就比较简单了，如果key还存在，就将key和它的值都清除掉。最后总结一下：首先ThreadLocal本身不存储任何值，它将自己作为key存储到线程的Values中；同时如果存储的位置已经有其他值，那它会增加序号到新的位置存储；如果存储的位置的值被清除了，且后面没有存储该值，那就会在该清除位置上储存。同时，每次get、set和remove方法，都会将那些已经被回收的key和值都清除掉。","categories":[{"name":"源码阅读","slug":"源码阅读","permalink":"https://earthwo.github.io/categories/源码阅读/"}],"tags":[{"name":"源码阅读","slug":"源码阅读","permalink":"https://earthwo.github.io/tags/源码阅读/"}]},{"title":"LocalBroadcastManager源码分析","slug":"LocalBroadcastManager源码分析","date":"2016-11-21T06:14:27.000Z","updated":"2019-03-11T07:35:22.318Z","comments":true,"path":"2016/11/21/LocalBroadcastManager源码分析/","link":"","permalink":"https://earthwo.github.io/2016/11/21/LocalBroadcastManager源码分析/","excerpt":"","text":"当我们在发送广播时，有时会遇到这样的问题，就是我不想让该广播被其他应用接收，或者我的广播接收器不想接收其他的应用的广播，这该怎么做呢？解决的方案有很多中，比如可以自定义广播的权限；比如可以给intent设置package等。但是这些方法，一旦应用被反编译，就完全无法保障其他应用再来发冒充我们的广播了。在Android系统中，有一个LocalBroadcastManager类，就是专门来解决广播只在应用内部流通的问题。LocalBroadcastManager是在android.support.v4包中，它能使发送的广播只在本应用中传递，同时自己的接收器也不会接受到其他应用的广播。那它内部是怎样实现的呢？LocalBroadcastManager使用了单例模式，其构造方法如下：public static LocalBroadcastManager getInstance(Context context) &#123; synchronized (mLock) &#123; if (mInstance == null) &#123; mInstance = new LocalBroadcastManager(context.getApplicationContext()); &#125; return mInstance; &#125; &#125; private LocalBroadcastManager(Context context) &#123; mAppContext = context; mHandler = new Handler(context.getMainLooper()) &#123; @Override public void handleMessage(Message msg) &#123; switch (msg.what) &#123; case MSG_EXEC_PENDING_BROADCASTS: executePendingBroadcasts(); break; default: super.handleMessage(msg); &#125; &#125; &#125;; &#125; 这里的mLock对象是一个空Object对象，只是单纯的在这里用来锁一下。同时，在构造方法找那个，实现了一个在主线程中的Handler，这个hander具体怎么样，后面再说。LocalBroadcastManager主要有三个方法，registerReceiver、unregisterReceiver和sendBroadcast。从名字就可以知道，一个用来注册接收器，一个用来注销接收器，还有一个用来发送广播，那我们一次来看看是怎么实现的。public void registerReceiver(BroadcastReceiver receiver, IntentFilter filter) &#123; synchronized (mReceivers) &#123; ReceiverRecord entry = new ReceiverRecord(filter, receiver); ArrayList&lt;IntentFilter&gt; filters = mReceivers.get(receiver); if (filters == null) &#123; filters = new ArrayList&lt;IntentFilter&gt;(1); mReceivers.put(receiver, filters); &#125; filters.add(filter); for (int i=0; i&lt;filter.countActions(); i++) &#123; String action = filter.getAction(i); ArrayList&lt;ReceiverRecord&gt; entries = mActions.get(action); if (entries == null) &#123; entries = new ArrayList&lt;ReceiverRecord&gt;(1); mActions.put(action, entries); &#125; entries.add(entry); &#125; &#125; &#125; private static class ReceiverRecord &#123; final IntentFilter filter; final BroadcastReceiver receiver; boolean broadcasting; ReceiverRecord(IntentFilter _filter, BroadcastReceiver _receiver) &#123; filter = _filter; receiver = _receiver; &#125; ... &#125; 首先是registerReceiver，首先先将BroadcastReceiver和IntentFilter封装成一个ReceiverRecord，再判断是否存有相同的BroadcastReceiver，如果没有，则以BroadcastReceiver为key，ArrayList为值，添加到列表，同时在ArrayList添加传入的IntentFilter；同样，又以IntentFilter的action为key，将ReceiverRecord存入到列表。发送广播：public boolean sendBroadcast(Intent intent) &#123; synchronized (mReceivers) &#123; final String action = intent.getAction(); final String type = intent.resolveTypeIfNeeded( mAppContext.getContentResolver()); final Uri data = intent.getData(); final String scheme = intent.getScheme(); final Set&lt;String&gt; categories = intent.getCategories(); final boolean debug = DEBUG || ((intent.getFlags() &amp; Intent.FLAG_DEBUG_LOG_RESOLUTION) != 0); if (debug) Log.v( TAG, &quot;Resolving type &quot; + type + &quot; scheme &quot; + scheme + &quot; of intent &quot; + intent); ArrayList&lt;ReceiverRecord&gt; entries = mActions.get(intent.getAction()); if (entries != null) &#123; if (debug) Log.v(TAG, &quot;Action list: &quot; + entries); ArrayList&lt;ReceiverRecord&gt; receivers = null; for (int i=0; i&lt;entries.size(); i++) &#123; ReceiverRecord receiver = entries.get(i); if (debug) Log.v(TAG, &quot;Matching against filter &quot; + receiver.filter); if (receiver.broadcasting) &#123; if (debug) &#123; Log.v(TAG, &quot; Filter&apos;s target already added&quot;); &#125; continue; &#125; int match = receiver.filter.match(action, type, scheme, data, categories, &quot;LocalBroadcastManager&quot;); if (match &gt;= 0) &#123; if (debug) Log.v(TAG, &quot; Filter matched! match=0x&quot; + Integer.toHexString(match)); if (receivers == null) &#123; receivers = new ArrayList&lt;ReceiverRecord&gt;(); &#125; receivers.add(receiver); receiver.broadcasting = true; &#125; else &#123; if (debug) &#123; String reason; switch (match) &#123; case IntentFilter.NO_MATCH_ACTION: reason = &quot;action&quot;; break; case IntentFilter.NO_MATCH_CATEGORY: reason = &quot;category&quot;; break; case IntentFilter.NO_MATCH_DATA: reason = &quot;data&quot;; break; case IntentFilter.NO_MATCH_TYPE: reason = &quot;type&quot;; break; default: reason = &quot;unknown reason&quot;; break; &#125; Log.v(TAG, &quot; Filter did not match: &quot; + reason); &#125; &#125; &#125; if (receivers != null) &#123; for (int i=0; i&lt;receivers.size(); i++) &#123; receivers.get(i).broadcasting = false; &#125; mPendingBroadcasts.add(new BroadcastRecord(intent, receivers)); if (!mHandler.hasMessages(MSG_EXEC_PENDING_BROADCASTS)) &#123; mHandler.sendEmptyMessage(MSG_EXEC_PENDING_BROADCASTS); &#125; return true; &#125; &#125; &#125; return false; &#125; 简单分析一下：首先是根据传入intent的action，遍历所有该action的ReceiverRecord，同时通过IntentFilter的match方法匹配传入intent的各项数据是否符合ReceiverRecord中的IntentFilter，如果匹配，则保存该ReceiverRecord，同时将该ReceiverRecord的状态设置为发送中。最后将这些ReceiverRecord的状态通信置为为发送，将这些ReceiverRecord和intent保存成BroadcastRecord,添加到BroadcastRecord列表，再使用handler在主线程中发送广播。private static class BroadcastRecord &#123; final Intent intent; final ArrayList&lt;ReceiverRecord&gt; receivers; BroadcastRecord(Intent _intent, ArrayList&lt;ReceiverRecord&gt; _receivers) &#123; intent = _intent; receivers = _receivers; &#125; &#125; 具体发送代码：private void executePendingBroadcasts() &#123; while (true) &#123; BroadcastRecord[] brs = null; synchronized (mReceivers) &#123; final int N = mPendingBroadcasts.size(); if (N &lt;= 0) &#123; return; &#125; brs = new BroadcastRecord[N]; mPendingBroadcasts.toArray(brs); mPendingBroadcasts.clear(); &#125; for (int i=0; i&lt;brs.length; i++) &#123; BroadcastRecord br = brs[i]; for (int j=0; j&lt;br.receivers.size(); j++) &#123; br.receivers.get(j).receiver.onReceive(mAppContext, br.intent); &#125; &#125; &#125; &#125; 将BroadcastRecord列表转成数组后，循环遍历每个intent 的ReceiverRecord，直接调用里面的BroadcastReceiver的onReceive方法，完成广播的发送。最后再来看看注销广播：public void unregisterReceiver(BroadcastReceiver receiver) &#123; synchronized (mReceivers) &#123; ArrayList&lt;IntentFilter&gt; filters = mReceivers.remove(receiver); if (filters == null) &#123; return; &#125; for (int i=0; i&lt;filters.size(); i++) &#123; IntentFilter filter = filters.get(i); for (int j=0; j&lt;filter.countActions(); j++) &#123; String action = filter.getAction(j); ArrayList&lt;ReceiverRecord&gt; receivers = mActions.get(action); if (receivers != null) &#123; for (int k=0; k&lt;receivers.size(); k++) &#123; if (receivers.get(k).receiver == receiver) &#123; receivers.remove(k); k--; &#125; &#125; if (receivers.size() &lt;= 0) &#123; mActions.remove(action); &#125; &#125; &#125; &#125; &#125; &#125; 注销广播无非也就是根据receive，将ReceiverRecord列表和actions列表中的数据移除。这里我们看到了，避免外部广播的方式其实就是广播的发送不通过系统的进程间通信，而是直接在内部直接调用的方式，从而完成广播的传递。","categories":[{"name":"源码阅读","slug":"源码阅读","permalink":"https://earthwo.github.io/categories/源码阅读/"}],"tags":[{"name":"源码阅读","slug":"源码阅读","permalink":"https://earthwo.github.io/tags/源码阅读/"}]},{"title":"Effective java读书笔记(3)","slug":"Effective-java读书笔记(3)","date":"2016-11-07T10:36:45.000Z","updated":"2019-03-11T07:35:22.317Z","comments":true,"path":"2016/11/07/Effective-java读书笔记(3)/","link":"","permalink":"https://earthwo.github.io/2016/11/07/Effective-java读书笔记(3)/","excerpt":"","text":"尽量不要使用原生态类型首先，我们要知道什么是原生态类型。每一个泛型都定义一个原生态类型，比如List它的原生态类型就是List。那为什么又尽量不要使用呢？因为使用它可能会照成类型不安全。比如：public void add(List list,String string)&#123; list.add(string);&#125; 如果调用方法时是new Person().add(new ArrayList&lt;Person&gt;(),&quot;ddd&quot;);这样，那么程序在运行时会报类型错误。而代替的方法主要有几个：使用无限制通配符类型List&lt;?&gt;，这样你可以传入任何非null元素。当然这样无法根本消除问题。其次是使用泛型方法或者有限制的通配符类型List&lt;? extends String&gt; 列表优先于数组数组和泛型的区别：数组是协变的，泛型是不可变的。什么意思呢？Type1是Type2的父类，则Type1[]同样是Type2[]的父类，而List和List则没有关系，这样就可以数组在使用时的错误类型转换。比如：Object[]os=new Long[1];os[0]=&quot;dd&quot;; 这个代码在编译时不会报错，但在运行时会报错，而类似的代码在使用泛型时会在编译时就报错。泛型和数组不能混用，即禁止创建泛型数组。","categories":[{"name":"Effective Java","slug":"Effective-Java","permalink":"https://earthwo.github.io/categories/Effective-Java/"},{"name":"读书笔记","slug":"Effective-Java/读书笔记","permalink":"https://earthwo.github.io/categories/Effective-Java/读书笔记/"}],"tags":[{"name":"Effective Java","slug":"Effective-Java","permalink":"https://earthwo.github.io/tags/Effective-Java/"},{"name":"读书笔记","slug":"读书笔记","permalink":"https://earthwo.github.io/tags/读书笔记/"}]},{"title":"Effective Java读书笔记(2)","slug":"Effective-Java读书笔记(2)","date":"2016-11-07T02:27:31.000Z","updated":"2019-03-11T07:35:22.316Z","comments":true,"path":"2016/11/07/Effective-Java读书笔记(2)/","link":"","permalink":"https://earthwo.github.io/2016/11/07/Effective-Java读书笔记(2)/","excerpt":"","text":"覆盖equals方法时的通用约定1.自反性：对于任何非null的对象x，x.equals(x)一定是true2.对称性：对于任何非null对象x，y，x.equals(y)为true时，y.equals(x)也一定为true3.传递性：x.equals(y)等于true，y.equals(z)也为true，那么x.equals(z)也一定为true4.一致性：在没有修改两个对象信息的情况下，多次调用equals方法会一致的返回true或false5.非空性：对于任何非空对象x，x.equals(null)一定是false这些约定看似简单，在覆盖equals方法时一定要注意。 覆盖equals方法时要重写hashcode方法hashcode通用约定：1.程序执行期间，hashcode多次调用时返回的是同一个值，多次执行过程中可以不一样。2.如果两个对象根据equals方法判断相等，那么它们的hashcode也应该相等。3.两个对象不相等，hashcode可能不相等，也可能相等，但是不相等可以提高效率。 覆盖toString自定义类时最好要重写toString方法。toString方法返回的值最好有固定的格式，并且有文档详细说明。即使没有固定的格式，也要有文档加以说明已增强可读性。 考虑实现Comparable接口类可以实现Comparable接口来对对象进行排序。实现Comparable接口后会重写一个CompareTo方法，返回int值。返回0时说明两者顺序相等，返回1说明比较对象比本对象顺序靠前，返回-1说明靠后。 使类和成员的可访问性最小化一个模块对于其他的外部模块而言，要尽可能的隐藏其内部的数据结构和实现细节，这个概念被称为封装。好处：可以有效的接触各个模块之间的耦合关系，使这些模块能够独立的开发、测试、优化和修改。规则：1.尽可能的使每个类或成员不被外界访问，就是说在不影响功能的情况下，能包私有就不公有，能私有就不包私有。 2.实例域决不能是公有的。 3.静态域也不能是公有的。 在公有类中使用访问方法代替公有域将域的可访问性设置为private，使用相关的public set和get方法去访问类。 类可变性最小化不可变类是指实例的所有信息在其创建时就提供，之后再也无法改变。这种类比普通的类更加容易设计、实现和使用，而且更加安全。将类的可变性最小化规则：1.不提供任何可以修改对象的状态的方法2.使类不能被扩展（final修饰）3.所有的域都是私有的4.所有的域都是final的5.确保对于任何可变组件的互斥访问 复合优先于继承继承打破了程序的封装性。当超类中的实现随着版本的更新而变化时，子类可能会遭到破坏，所以子类也只能变化。所以继承只能在子类和超类确实存在子类型关系时使用才是合适的。而复用除了能获得更好的健壮性之外，还能带来更好的灵活性。 要么为继承而设计，并提供文档，要么就禁止继承鉴于上面继承所可能带来的问题，类在使用继承的过程中，必须要有文档。那有怎样写文档呢？一般情况下，api文档应该描述方法做了什么工作，但是在这里，你必须详细的描述方法是怎样工作的。这相当于将类内部的实现原理暴露出去。因此在设计类的时候，你就必须要考虑要暴露哪些方法或域。 接口优于抽象类1.现有类容易实现新的接口 比如现在A类实现B接口，现在又需要A实现C接口的方法，只需要A再继承C接口即可。而如果A继承B，如果又要有C的方法，那就只能将B继承C，这样会使B也有C方法，会伤害类层次而且B也不需要C的方法。2.接口可以继承多个接口从而实现非层次接口的类型框架 接口只用于定义类型常量接口没有任何方法，只有静态final域，这种模式是对接口的不良使用，","categories":[{"name":"Effective Java","slug":"Effective-Java","permalink":"https://earthwo.github.io/categories/Effective-Java/"},{"name":"读书笔记","slug":"Effective-Java/读书笔记","permalink":"https://earthwo.github.io/categories/Effective-Java/读书笔记/"}],"tags":[{"name":"Effective Java","slug":"Effective-Java","permalink":"https://earthwo.github.io/tags/Effective-Java/"},{"name":"读书笔记","slug":"读书笔记","permalink":"https://earthwo.github.io/tags/读书笔记/"}]},{"title":"Effective Java读书笔记(1)","slug":"Effective-Java读书笔记(1)","date":"2016-11-04T08:59:26.000Z","updated":"2019-03-11T07:35:22.316Z","comments":true,"path":"2016/11/04/Effective-Java读书笔记(1)/","link":"","permalink":"https://earthwo.github.io/2016/11/04/Effective-Java读书笔记(1)/","excerpt":"","text":"用静态工厂方法代替构造器优势：1.静态工厂方法有名字，可以增强阅读性，可以强化与其他静态工厂方法的区别。2.静态工厂方法在返回对象时可以返回静态对象，不需要每次都创建新对象。3.静态工厂方法可以返回原对象类型的子类型对象。缺点：类如果没有公有的或者受保护的构造器，就不能被子类化。 遇到多个构造参数是用构建器优势：1.代码的可读性更高（看起来更高级）2.可以有多个可变参数示例：FileDownloadThread fileDownloadThread =new FileDownloadThread.Builder(i) .filePath(filePath) .start(mFileSize*i) .build(); public class FileDownloadThread &#123; private String filePath; private int start; public static class Builder&#123; private int start; private String filePath; public Builder()&#123;&#125; public Builder start(int start)&#123; this.start=start; return this; &#125; public Builder filePath(String filePath)&#123; this.filePath=filePath; return this; &#125; public FileDownloadThread build()&#123; return new FileDownloadThread(this); &#125; &#125; private FileDownloadThread(Builder builder)&#123; if(builder!=null)&#123; this.start=builder.start; this.filePath=builder.filePath; &#125; &#125; &#125; 通过私有构造器强化不可实例化能力某些不需要实例化的工具类，用户往往没有写显示的构造器，但是编译器会自动提供一个公有的、无参数的构造器。所以用户可以写一个显式的私有的构造器来强制使类不可实例化，但是这么做的缺点就是该类无法被子类化。 减少不必要的对象创建1.尽量使用基本数据类型而不是装箱基本类型，比如long 对 Long2.在类中会重用的部分尽量使用静态代码块 尽可能避免使用终结方法finalizer1.finalizer方法可以释放对象资源，但是java中这个方法的执行时间是不定的，设置是否执行也是不定的，所以在finalizer中的程序不能保证是否被执行和执行的时间。2.添加finalizer方法会极大的损耗性能。3.对于一些使用完需要关闭的对象，可以使用显示方法关闭，比如InputStream。finalizer的用处：1.在显示终结方法未被调用的情况下做最后的终结操作。2.终结一些不是很重要的资源。","categories":[{"name":"Effective Java","slug":"Effective-Java","permalink":"https://earthwo.github.io/categories/Effective-Java/"},{"name":"读书笔记","slug":"Effective-Java/读书笔记","permalink":"https://earthwo.github.io/categories/Effective-Java/读书笔记/"}],"tags":[{"name":"Effective Java","slug":"Effective-Java","permalink":"https://earthwo.github.io/tags/Effective-Java/"},{"name":"读书笔记","slug":"读书笔记","permalink":"https://earthwo.github.io/tags/读书笔记/"}]},{"title":"Executor 框架与线程池","slug":"ExecutorsExecutor 框架与线程池的使用","date":"2016-11-04T02:34:09.000Z","updated":"2019-03-11T07:35:22.317Z","comments":true,"path":"2016/11/04/ExecutorsExecutor 框架与线程池的使用/","link":"","permalink":"https://earthwo.github.io/2016/11/04/ExecutorsExecutor 框架与线程池的使用/","excerpt":"","text":"Executor 框架是 Java 5 中引入的，其内部使用了线程池机制，通过该框架来控制线程的启动、执行和关闭，可以简化并发编程的操作。通过 Executor 来启动线程比使用 Thread 的 start 方法更好。首先是能够降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。其次能够提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。最后还能提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。Executor 接口中之定义了一个方法 execute（Runnable command），该方法接收一个 Runable 实例，它用来执行一个任务，任务即一个实现了 Runnable 接口的类。ExecutorService 接口继承自 Executor 接口，它提供了更丰富的实现多线程的方法。ExecutorService 的生命周期包括三种状态：运行、关闭、终止。创建后便进入运行状态，当调用了 shutdown（）方法时，便进入关闭状态，此时意味着 ExecutorService 不再接受新的任务，但它还在执行已经提交了的任务，当素有已经提交了的任务执行完后，便到达终止状态。Executors 提供了一系列工厂方法用于创先线程池，返回的线程池都实现了 ExecutorService 接口，我们可以使用它来创建ExecutorService实例。提供的方法主要有以下几个： public static ExecutorService newCachedThreadPool()创建一个可缓存的线程池。调用execute时将重用以前构造的可用的线程。如果现有线程没有可用的，则创建一个新线程并添加到池中。在缓存中如果有60s都未被使用的线程将会被移除，它最多可以Integer.MAX_VALUE个线程。 public static ExecutorService newFixedThreadPool(int nThreads)创建固定数目线程的线程池。它与newCachedThreadPool差不多，但是它最多只能有nThreads个线程，所以它不能随时创建新的线程，当线程池满时，需要创建新的线程时会在队列中等待，知道有线程执行完成并且从池中移除。 public static ExecutorService newSingleThreadExecutor()创建一个单线程化的Executor，其在任何时候线程池中都只有一个线程，执行完之后会移除。 public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize)创建一个支持定时及周期性的任务执行的线程池，多数情况下可用来替代Timer类。 Executor 运行 Runnable 任务在获取上述的几个实例后，我们就可以调用实例的execute方法运行runnable方法。示例：ExecutorService executor= Executors.newCachedThreadPool(); executor.execute(new Runnable() &#123; @Override public void run() &#123; while(true) &#123; num1++; Log.d(&quot;num1&quot;, num1 + &quot;&quot;); &#125; &#125; &#125;); Executor 运行 Callable 任务在使用线程的过程中，我们经常会遇到由于没有返回值而带来的问题。而在使用ExecutorService的时候，我们就可以运行Callable接口来获得返回值。Callable 的 call()方法可以通过 ExecutorService 的 submit(Callable task) 方法来执行，并且返回一个 Future，同样，将 Runnable 的对象传递给 ExecutorService 的 submit 方法，则该 run 方法自动在一个线程上执行，并且会返回执行结果 Future 对象，但是在该 Future 对象上调用 get 方法，将返回 null。示例：Callable&lt;String&gt;s=new Callable&lt;String&gt;() &#123; @Override public String call() throws Exception &#123; for(int i=0;i&lt;100000;i++)&#123; num1++; &#125; return num1+10+&quot;&quot;; &#125; &#125;; Future&lt;String&gt;f= executor.submit(s); try &#123; Log.d(&quot;最后的结果&quot;,f.get()); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (ExecutionException e) &#123; e.printStackTrace(); &#125; 自定义线程池除了使用自带的线程池，我们也可以自定义线程池来执行任务。自定义线程池主要是使用ThreadPoolExecutor类创建。其构造方法如下：public ThreadPoolExecutor (int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit,BlockingQueue&lt;Runnable&gt; workQueue) 当中参数的含义如下：corePoolSize 线程池中的最少线程数，当添加新任务时，当池中的线程少于corePoolSize，即使有空闲线程，也会新建线程添加到池中。maximumPoolSize 线程池中最大的线程数。keepAliveTime 空闲线程的保持时间unit 时间单位（秒/分…）workQueue 任务执行前保存任务的队列 所以当有新任务要处理时，先看线程数是否大于corePoolSize，再看缓冲队列是否满，最后看线程数是否大于最大maximumPoolSize。 不同缓冲队列的区别SynchronousQueue：它将任务直接提交给线程处理，当不存在空闲线程时会创建新线程，所以maximumPoolSizes应设置为Integer.MAX_VALUE，已避免提交任务失败，newCachedThreadPool就是采取这种队列。LinkedBlockingQueue：队列的容量是无限的，所以线程中最大线程数不会超过corePoolSize，newFixedThreadPool就是采用这种队列。ArrayBlockingQueue：有界队列，队列中的任务数量有限，这样可以防止资源过度消耗。示例：ThreadPoolExecutor r=new ThreadPoolExecutor(3,5,50, TimeUnit.SECONDS,new ArrayBlockingQueue&lt;Runnable&gt;(20)); r.execute(new Runnable() &#123; @Override public void run() &#123; num1++; Log.d(&quot;num1&quot;, num1 + &quot;&quot;); &#125; &#125;);","categories":[{"name":"Executors","slug":"Executors","permalink":"https://earthwo.github.io/categories/Executors/"},{"name":"线程池","slug":"Executors/线程池","permalink":"https://earthwo.github.io/categories/Executors/线程池/"}],"tags":[{"name":"Executors","slug":"Executors","permalink":"https://earthwo.github.io/tags/Executors/"},{"name":"线程池","slug":"线程池","permalink":"https://earthwo.github.io/tags/线程池/"}]},{"title":"http断点下载","slug":"http断点下载","date":"2016-10-27T08:15:11.000Z","updated":"2019-03-11T07:35:22.324Z","comments":true,"path":"2016/10/27/http断点下载/","link":"","permalink":"https://earthwo.github.io/2016/10/27/http断点下载/","excerpt":"","text":"断点续传，就是从文件已经下载的地方继续下载。这在下载比较大的文件时是一个非常有用的功能，实现断点下载的主要技术点有两个：一是多线程下载数据后，实时记录各个线程下载的数据量，二是从网络上分段下载数据。下面我就简单的讲讲文件断点下载的简单思路：首先，需要先使用HttpURLConnection，连接链接，获取文件的大小。HttpURLConnection conn= (HttpURLConnection) url.openConnection();conn.connect();if(conn.getResponseCode()==200)&#123; int size=conn.getContentLength();&#125; 在获取文件的大小之后，需要以下几件事：在没有下载过文件的情况下，创建与实际文件等大小的文件。在这个过程的时间会根据创建文件的大小而变化，你可以先创建多个文件，写入数据完成后将所有数据再写到同一个文件中，这里就不在做此操作。RandomAccessFile raf = new RandomAccessFile(file, &quot;rw&quot;);//file是需要保存的文件raf.setLength(size);raf.close(); 获取各个线程已经下载的数据量(第一次时数据为0)，获取不同线程需要下载的数据量(最后一个需要将剩余的数据全部下载),创建线程并且设置相应的参数。for(int i=0;i&lt;threadCount;i++)&#123; int end=(i+1)*mFileSize; if(i==threadCount-1)&#123; end=size; &#125;int ds= DbUtil.getInteger(filePath+&quot;thread&quot;+i);FileDownloadThread fileDownloadThread =new FileDownloadThread.Builder(i) .filePath(filePath) .start(mFileSize*i) .httpUrl(httpUrl) .end(end) .downloadSize(ds) .downListener(downloadManager) .build();downloadManagerList.add(fileDownloadThread);fileDownloadThread.startDownload(); 在每个下载线程中，我们需要从不同从不同的位置下载数据(未下完时)。URL url = new URL(httpUrl);HttpURLConnection conn= (HttpURLConnection) url.openConnection();conn.setRequestProperty(&quot;Range&quot;,&quot;bytes=&quot;+(start+downloadSize)+&quot;-&quot;+end);conn.setRequestProperty(&quot;Connection&quot;,&quot;Keep-Alive&quot;);//使用长连接conn.connect(); 然后将数据写到文件的不同位置，同时需要将已经下载的数据量写入，以便下次打开时继续从原文件下载。//得到输入流 InputStream inputStream = conn.getInputStream();//获取自己数组 byte[] getData = new byte[1024]; File saveDir = new File(filePath); RandomAccessFile raf = new RandomAccessFile(saveDir, &quot;rwd&quot;); raf.seek(downloadSize+start); int offset=0; while((offset=inputStream.read(getData,0,1024))!=-1)&#123; raf.write(getData,0,offset); downloadSize+=offset; DbUtil.saveInteger(filePath+&quot;thread&quot;+id,downloadSize); &#125; if (raf != null) &#123; raf.close(); &#125; if (inputStream != null) &#123; inputStream.close();&#125; 以上这些就是java断点下载最核心的代码，在具体实现中还有很多的细节和功能的优化。","categories":[{"name":"http","slug":"http","permalink":"https://earthwo.github.io/categories/http/"}],"tags":[{"name":"http","slug":"http","permalink":"https://earthwo.github.io/tags/http/"}]},{"title":"java正则表达式语法大全","slug":"java正则表达式使用","date":"2016-10-25T07:41:25.000Z","updated":"2019-03-11T07:35:22.325Z","comments":true,"path":"2016/10/25/java正则表达式使用/","link":"","permalink":"https://earthwo.github.io/2016/10/25/java正则表达式使用/","excerpt":"","text":"正则表达式是一种专门的语法模式来匹配或找到其他字符串或字符串集，可以用来搜索编辑或是操纵文本和数据。java中要使用它主要需要用到以下两个类：Pattern类:一个 Pattern 对象是正则表达式编译表示。 Pattern 类没有提供公共的构造函数。要创建一个 Pattern 对象，你必须首先调用他的公用静态编译方法来获得 Pattern 对象。这些方法的第一个参数是正则表达式。Matcher类:一个 Matcher 对象是用来解释模式和执行与输入字符串相匹配的操作。和 Pattern 类一样 Matcher 类也是没有构造方法的，你需要通过调用 Pattern 对象的 matcher 方法来获得 Matcher 对象。这两个类的使用实例：Pattern pattern=Pattern.compile(&quot;^[0-9]+\\\\.&#123;0,1&#125;[0-9]&#123;0,2&#125;$&quot;);Matcher matcher=pattern.matcher(&quot;0.33&quot;);textView.setText(matcher.matches()+&quot;&quot;); 返回的结果是true。这里我们可以看到这两个类使用还是挺简单的，关键是正则表达式的语句的书写。那语句应该怎么写呢？下面是正则表达式所有元字符语法： 子表达式 匹配对应 ^ 匹配一行的开头 $ 匹配一行的结尾 . 匹配除了换行符的任何单个字符，也可以利用 m 选项允许它匹配换行符 […] 匹配括号内的任意单个字符。 [^…] 匹配不在括号内的任意单个字符。 \\A 整个字符串的开始 \\z 整个字符串的结束 \\Z 整个字符串的结束，除了最后一行的结束符 re* 匹配0或者更多的前表达事件 re+ 匹配1个或更多的之前的事件 re? 匹配0或者1件前表达事件 re{ n} 匹配特定的n个前表达事件 re{ n,} 匹配n或者更多的前表达事件 re{ n, m} 匹配至少n最多m件前表达事件 a或b 匹配a或者b (re) 正则表达式组匹配文本记忆 (?: re) 没有匹配文本记忆的正则表达式组 (?&gt; re) 匹配无回溯的独立的模式 \\w 匹配单词字符 \\W 匹配非单词字符 \\s 匹配空格。等价于 [\\t\\n\\r\\f] \\S 匹配非空格 \\d 匹配数字. 等价于 [0-9] \\D 匹配非数字 \\A 匹配字符串的开始 \\Z 匹配字符串的末尾，如果存在新的一行，则匹配新的一行之前 \\z 匹配字符串的末尾 \\G 匹配上一次匹配结束的地方 \\n 返回参考捕获组号“N” \\b 不在括号里时匹配单词边界。在括号里时匹配退格键\\B |匹配非词边界\\n, \\t, etc. |匹配换行符，回车符，制表符，等\\Q |引用字符的初始，结束于\\E\\E |结束由\\Q开始的引用 这么多的字符，你肯定看晕了，也一定记不住。没关系，下面有一些正则表达式的例子，我们就通过实际的例子来加深记忆和理解。整数或者两位小数：^[0-9]+\\.{0,1}[0-9]{0,2}$ 解释：以0-9的数字开始，数字大于等于1个，然后有小数点，点的数量为0-1个，然后0-9的数字0-2个，结束纯数字：^[0-9]*$ 解释：以0-9数字开始，数字0个以上，结束n位的数字：^\\d{n}$&quot; 解释：数字开始，数字n个，结束至少n位的数字：^\\d{n,}$ 解释：数字开始，数字n个以上，结束m~n位的数字：^\\d{m,n}$ 解释：数字开始，数字m-n位，结束零和非零开头的数字：^(0|[1-9][0-9]*)$ 解释：0或者以1-9开头，0-9数字0或0以上个 结束两位小数的正实数：^[0-9]+(.[0-9]{2})?$ 解释：0-9数字一个以上，小数点，0-9数字2个，小数点加数字0或者1个1~3位小数的正实数：^[0-9]+(.[0-9]{1,3})?$非零的正整数:^+?[1-9][0-9]*$非零的负整数:-[1-9][0-9]*$长度为3的字符：^.{3}$26个英文字母组成的字符串:^[A-Za-z]+$26个大写英文字母组成的字符串:^[A-Z]+$26个小写英文字母组成的字符串:^[a-z]+$数字和26个英文字母组成的字符串:^[A-Za-z0-9]+$数字、26个英文字母或者下划线组成的字符串：^\\w+$ 解释：\\w表示数字、字符和下划线是否含有^%&amp;’,;=?$\\”等字符：[^%&amp;&#39;,;=?$\\x22]+汉字:^[\\u4e00-\\u9fa5]{0,}$ 解释：0个以上汉字Email地址：^\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*$ 解释：多个字符开头，中间有0-1个[+-.]，再有多个字符，加@，再加多个字符，中间有0-1个[-.],加多个字符，这样循环多次，加.，再加多个字符，再加0-1个[-.],加多个字符，多次循环验证http链接：^http://([\\w-]+\\.)+[\\w-]+(/[\\w-./?%&amp;=]*)?$ 根据不同的要求可以有无数种正则表达式，这里不可能一一列举，但是无论怎样，只要弄清楚规则，就都可以写出来。","categories":[{"name":"正则表达式","slug":"正则表达式","permalink":"https://earthwo.github.io/categories/正则表达式/"}],"tags":[{"name":"正则表达式","slug":"正则表达式","permalink":"https://earthwo.github.io/tags/正则表达式/"}]},{"title":"java注解的使用","slug":"java注解的使用","date":"2016-10-23T08:43:37.000Z","updated":"2019-03-11T07:35:22.325Z","comments":true,"path":"2016/10/23/java注解的使用/","link":"","permalink":"https://earthwo.github.io/2016/10/23/java注解的使用/","excerpt":"","text":"java注解是JDK1.5及以后版本引入的一个特性，与类、接口、枚举是在同一个层次。它可以声明在包、类、字段、方法、局部变量、方法参数等的前面，用来对这些元素进行说明，注释。java注解可用于创建文档，跟踪代码中的依赖性，甚至执行基本编译时检查。注解是以‘@注解名’在代码中存在的，根据注解参数的个数，注解可以分为：标记注解、单值注解、完整注解三类。它们都不会直接影响到程序的语义，只是作为注解（标识）存在，我们可以通过反射实现对这些注解的访问。另外，也可以在编译时选择代码里的注解是否只存在于源代码级，或者它也能在class文件、或者运行时中出现。 基本内置注解@Override这个注解比较常见，它是对覆盖超类中方法的方法进行标记，如果被标记的方法并没有实际覆盖超类中的方法，则编译器会发出错误警告。@Deprecated这个注解表示方法过时，建议使用其他方法代替。@SuppressWarnings这个注解表示压制警告，对方法中的警告进行屏蔽，它可以带参数，具体的参数有： deprecation，使用了过时的类或方法时的警告unchecked，执行了未检查的转换时的警告fallthrough，当 switch 程序块直接通往下一种情况而没有 break 时的警告path，在类路径、源文件路径等中有不存在的路径时的警告serial，当在可序列化的类上缺少serialVersionUID 定义时的警告finally ，任何 finally 子句不能正常完成时的警告all，关于以上所有情况的警告 自定义注解我们除了使用内置的注解外，更多情况下我们会使用自定义注解。首先来看一下如何创建自定义注解：@Documented@Target(ElementType.METHOD)@Inherited@Retention(RetentionPolicy.RUNTIME)public @interface DefaultName&#123; String name() default &quot;tony&quot;;&#125; 创建自定义注解与编写接口很相似，它的接口关键字前有个@符号。同时，我们也会使用元注解对其进行相应的设置。这里我们可以看到四个元注解，现在我们先来看看这四个元注解的用法：@Documented@Documented用于描述其它类型的annotation应该被作为被标注的程序成员的公共API，因此可以被例如javadoc此类的工具文档化。@Inherited@Inherited阐述了某个被标注的类型是被继承的。如果一个使用了@Inherited修饰的annotation类型被用于一个class，则这个annotation将被用于class的子类。@Target@Target说明了Annotation所修饰的对象范围：Annotation可被用于 packages、types（类、接口、枚举、Annotation类型）、类型成员（方法、构造方法、成员变量、枚举值）、方法参数和本地变量（如循环变量、catch参数）。ElementType.CONSTRUCTOR 作用于构造器ElementType.FIELD 作用于域/属性ElementType.LOCAL_VARIABLE 用于描述局部变量ElementType.METHOD 作用于方法ElementType.PACKAGE 用于描述包ElementType.PARAMETER 用于描述参数ElementType.TYPE 用于描述类、接口(包括注解类型) 或enum声明。多个声明是使用实例：@Target({ ElementType.TYPE, ElementType.METHOD})Retention定义了该Annotation被保留的时间长短：某些Annotation仅出现在源代码中，而被编译器丢弃；而另一些却被编译在class文件中；编译在class文件中的Annotation可能会被虚拟机忽略，而另一些在class被装载时将被读取（请注意并不影响class的执行，因为Annotation与class在使用上是被分离的）。使用这个meta-Annotation可以对 Annotation的“生命周期”限制。RetentionPolicy.RUNTIME 注解会在class字节码文件中存在，在运行时可以通过反射获取到RetentionPolicy.CLASS 默认的保留策略，注解会在class字节码文件中存在，但运行时无法获得RetentionPolicy.SOURCE 注解仅存在于源码中，在class字节码文件中不包含 而在使用注解时，还有几点要注意：首先注解方法不能有参数但是可以有默认值；其次，注解方法的返回类型局限于原始类型，字符串，枚举，注解，或以上类型构成的数组。最后在使用注解时：@DefaultName(name=&quot;lee&quot;) private void setName(String name)&#123; this.name=name; &#125; 获取注解获取注解需要使用Java反射机制，同时注解保持性策略应该是RUNTIME，否则它的信息在运行期无效，我们也不能从中获取任何数据。具体的代码为：Annotation annotation=method.getAnnotation(DefaultName.class);textView.setText(((DefaultName)annotation).name());//方法注解的默认值 这个一部分在java反射部分做详细的介绍。","categories":[{"name":"java注解","slug":"java注解","permalink":"https://earthwo.github.io/categories/java注解/"}],"tags":[{"name":"java注解","slug":"java注解","permalink":"https://earthwo.github.io/tags/java注解/"}]},{"title":"java反射机制","slug":"java反射机制","date":"2016-10-23T08:40:02.000Z","updated":"2019-03-11T07:35:22.325Z","comments":true,"path":"2016/10/23/java反射机制/","link":"","permalink":"https://earthwo.github.io/2016/10/23/java反射机制/","excerpt":"","text":"JAVA反射机，简单的说就是在程序运行过程中，对于任意一个类、方法和对象，我们都能知道它的信息并且调用；这种动态获取信息以及动态调用对象方法的功能称为java语言的反射机制。反射机制的优点就是可以实现动态创建对象和编译，体现出很大的灵活性。同时，我们可可以通过它来实现对原先无法调用的方法和对象的调用。因此在开发过程中有很重要的作用。那么我们要怎样来使用它呢？ 获取类获取累的对象几乎是所有操作的起始，获取类的方法主要有三种： 通过Class类获取Class personClass=Class.forName(&quot;module.Person&quot;);//获得class 直接获取Class personClass=Person.class; 通过对象获取Person person=new Person(); Class personClass=person.getClass(); 获取构造方法获取类对象后，我们可以通过它获取它的构造方法 获取构造方法数量 personClass.getDeclaredConstructors();// 获取所有的申明构造方法personClass.getConstructors();// 获取公开的构造方法 获取指定参数的构造方法personClass.getConstructor(new Class[]{int.class});//获取int参数的构造方法 获取构造方法的参数类型Constructor constructor=personClass.getConstructors()[i];//获取第i个构造方法constructor.getParameterTypes();//获取该构造方法的全部参数类型 获取属性在获取了类之后，我们就可以通过这个类获取它里面的属性。 获取属性的数量personClass.getFields();//获取所有的公开参数personClass.getDeclaredFields();//获取所有的声明参数这两个方法的区别是getDeclaredFields()返回Class中所有的字段，包括私有字段，而getFields 只返回公共字段，同时包括父类继承的公开字段。类似的在获取方法、获取注解等。 获取指定属性personClass.getField(&quot;gender&quot;); 修改属性Person person=new Person();field.set(person,4);//设置参数 同时如果修改的属性是私有的，我们需要设置field可修改field.setAccessible(true); 获取方法 获取方法数量 personClass.getDeclaredMethods();//获取所有申明的方法personClass.getMethods();//获取公开的方法 获取指定到方法personClass.getDeclaredMethod(&quot;setName&quot;,String.class);//如果没参数就设置null 调用方法method.setAccessible(true);//设置私有参数和方法可修改Person o= (Person) personClass.getConstructor().newInstance();method.invoke(o,&quot;hello&quot;);//person设置name为hello 获取注解可以获取注解信息 获取类、方法、属性、方法参数的注解 personClass.getAnnotation(DefaultName.class);method.getAnnotation(DefaultName.class);field.getAnnotation(DefaultName.class);method.getParameterAnnotations()//获取方法参数注解; 获取注解值((DefaultName)annotation).name();// name为注解方法 java反射的内容还有很多，这里就不再介绍了。","categories":[{"name":"java反射","slug":"java反射","permalink":"https://earthwo.github.io/categories/java反射/"}],"tags":[{"name":"java反射","slug":"java反射","permalink":"https://earthwo.github.io/tags/java反射/"}]},{"title":"matrix pre、post和set的区别","slug":"matrix pre 、post和set的区别","date":"2016-10-10T08:15:57.000Z","updated":"2019-03-11T07:35:22.327Z","comments":true,"path":"2016/10/10/matrix pre 、post和set的区别/","link":"","permalink":"https://earthwo.github.io/2016/10/10/matrix pre 、post和set的区别/","excerpt":"","text":"在使用matrix过程中，我们经常要使用到rotate、scale、translate等变换。Matrix实现这些变换的方法有3个，preXX，postXX和setXX。这个方法单用一次，你会发现实际的效果都是一样的，但是如果你多次使用或者组合使用，所出来的效果可能就完全不同了。那到底这三者有什么不同呢？pre操作从字面上就可以看到是先执行，post操作是按顺序执行，set操作是清除执行。很多文章在将这个时也都只是这么说的，但是想我这样理解能力比较差的人看的一头雾水，不是很清除。其实简单的说，post是按程序语句执行的顺序执行变换，先写的先变，后写的后变；pre是将该操作放到所有的操作的栈顶，后写的先执行；而set最直接，它会将之前所有的操作清除，在执行它。无论是一种单一的操作，还是几种操作混合都是一样的。也许你还是不是很明白，那我就来举个列子：matrix.postScale(2,2);（1）matrix.preRotate(60,115,115);（2）matrix.postRotate(-30,230,230);（3）matrix.preRotate(-60,115,115);（4）matrix.preRotate(60,115,115);（5）matrix.preRotate(-60,115,115);（6）matrix.postRotate(30,230,230);（7） 这些操作看起来很复杂，但其实你只要按照上面的原则，就非常清晰。所有的pre操作都会把该操作放到最前执行，越后面越靠前执行，所以先不用看post操作，这样执行顺序是6-&gt;5-&gt;4-&gt;2,执行完pre后才会执行post，而post是按顺序执行，所以最终的是6-&gt;5-&gt;4-&gt;2-&gt;1-&gt;3-&gt;7。","categories":[{"name":"matrix","slug":"matrix","permalink":"https://earthwo.github.io/categories/matrix/"}],"tags":[{"name":"matrix","slug":"matrix","permalink":"https://earthwo.github.io/tags/matrix/"}]},{"title":"canvas concat和setMatrix的区别","slug":"canvas concat和setMatrix的区别","date":"2016-10-09T08:17:19.000Z","updated":"2019-03-11T07:35:22.324Z","comments":true,"path":"2016/10/09/canvas concat和setMatrix的区别/","link":"","permalink":"https://earthwo.github.io/2016/10/09/canvas concat和setMatrix的区别/","excerpt":"","text":"在自定义View的时候，我们经常会用到Canvas进行绘制，其中也会用到Matrix对图像进行移动、旋转等操作，这个时候就会涉及到concat和setMatrix这两个方法，将Matrix的变化效果设置到Canvas上，那么这两个方法有什么区别呢？闲话不多说，先使用代码看看最终的效果： 使用setMatrix@Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); matrix.setScale(2f,2f); paint.setColor(Color.BLUE); canvas.drawRect(0,0,100,100,paint); canvas.save(); canvas.setMatrix(matrix); paint.setColor(Color.RED); canvas.drawCircle(200,200,100,paint); canvas.restore(); &#125; 实际效果图： 使用concatpaint.setColor(Color.BLUE);canvas.drawRect(0,0,100,100,paint);canvas.save();canvas.concat(matrix);paint.setColor(Color.BLACK);canvas.drawCircle(200,200,100,paint);canvas.restore(); 实际效果图： 从最终的效果图我们可以看出，两者的差距还是很大，那么为什么会有这么大的区别呢？实际上，setMatrix作用的是当前的画布，而concat作用的是画布上的组件。具体讲的详细一点的话，在这里我对matrix放大两倍，使用setMatrix的话，相当于整个坐标轴放大了两倍，而绘制的参数并没有改变。因为canvas的原点并没有在左上角，导致实际上会有偏差。而concat改变的是绘制的参数，200变400，100变200，而坐标轴不变，所以整体上就当好是两倍的效果。","categories":[{"name":"自定义view","slug":"自定义view","permalink":"https://earthwo.github.io/categories/自定义view/"},{"name":"matrix","slug":"自定义view/matrix","permalink":"https://earthwo.github.io/categories/自定义view/matrix/"}],"tags":[{"name":"自定义view","slug":"自定义view","permalink":"https://earthwo.github.io/tags/自定义view/"},{"name":"matrix","slug":"matrix","permalink":"https://earthwo.github.io/tags/matrix/"}]},{"title":"Retrofit缓存实现","slug":"Retrofit2-缓存实现","date":"2016-10-09T05:59:40.000Z","updated":"2019-03-11T07:35:22.320Z","comments":true,"path":"2016/10/09/Retrofit2-缓存实现/","link":"","permalink":"https://earthwo.github.io/2016/10/09/Retrofit2-缓存实现/","excerpt":"","text":"之前在使用网络请求缓存时，一直使用的是手动的方式。手动获取返回的数据，手动存储，手动读取缓存。这种方式麻烦、低效而且容易出错。在项目中一直使用的是retrofit2库作为网络库，retrofit2库本身并不支持存储，但是由于retrofit2基于okhttp实现，可以使用okhttp实现网络缓存。 首先我们要添加缓存地址和缓存最大体积File httpCacheDirectory = new File(getCacheDir(), &quot;responses&quot;);//设置缓存 10MCache cache = new Cache(httpCacheDirectory, 10 * 1024 * 1024); 其次我们要创建okhttpclient，并且添加拦截器和缓存代码OkHttpClient client = new OkHttpClient.Builder() .addInterceptor(interceptor) .cache(cache).build();Retrofit retrofit = new Retrofit.Builder() .baseUrl(&quot;https://api.github.com/&quot;) .client(client) .build(); 在这里最重要的就是拦截器的内容。一般情况下，我们设置缓存的目的无非两种，一是在请求时都直接读取已缓存的数据，二是在有网络时直接连接网络，没有网络时读取缓存数据，而这两者的区别都需要在拦截器中设置。 一、直接读取缓存Interceptor interceptor = new Interceptor() &#123; @Override public Response intercept(Chain chain) throws IOException &#123; Request request = chain.request(); Response response = chain.proceed(request); String cacheControl = request.cacheControl().toString(); if (TextUtils.isEmpty(cacheControl)) &#123; cacheControl = &quot;public, max-age=60&quot;; //60秒之内读缓存 &#125; return response.newBuilder() .header(&quot;Cache-Control&quot;, cacheControl) .removeHeader(&quot;Pragma&quot;) .build(); &#125;&#125;; 其中读缓存的有效时间是60s，表示在60秒之内无论如何都会去取缓存。 二、有网时请求网络，无网络时读取缓存Interceptor interceptor = new Interceptor() &#123; @Override public Response intercept(Chain chain) throws IOException &#123; Request request = chain.request(); Response response = chain.proceed(request); if(isNetworkAvailable())&#123; return response.newBuilder() .header(&quot;Cache-Control&quot;, &quot;public, max-age=&quot; + 0) .removeHeader(&quot;Pragma&quot;) .build(); &#125;else&#123; int maxStale = 60 * 60 * 24 * 30; //缓存的最大时间是30天 return response.newBuilder() .header(&quot;Cache-Control&quot;, &quot;public, only-if-cached, max-stale=&quot; + maxStale) .removeHeader(&quot;Pragma&quot;) .build(); &#125; &#125;&#125;; 在30天之内没网络的情况下会读取缓存。","categories":[{"name":"Retrofit","slug":"Retrofit","permalink":"https://earthwo.github.io/categories/Retrofit/"}],"tags":[{"name":"Retrofit","slug":"Retrofit","permalink":"https://earthwo.github.io/tags/Retrofit/"}]},{"title":"gradle版本切换问题","slug":"gradle版本切换问题","date":"2016-09-30T02:35:51.000Z","updated":"2019-03-11T07:35:22.324Z","comments":true,"path":"2016/09/30/gradle版本切换问题/","link":"","permalink":"https://earthwo.github.io/2016/09/30/gradle版本切换问题/","excerpt":"","text":"最近android studio2.2正式更新，当中有许多新功能对于开发来说都非常有用。我第一时间就更新尝鲜，在体会到它的优点之后，也看到了它的问题。比如，Instant Run虽然能大大加快编译速度，但是它在第一次编译的时候确实太慢了，虽然2.2比之前的版本已经快很多了，但还是比一般情况慢很多；之前我用的是gradle 1.5，但是切换到2.2后编译时出现了大量的报错，整整几百个错误让人不寒而栗，而与其说是错误，不如说是警告，绝大部分还是第三方，虽然不影响正常运行程序，但满屏的红色还是让人很不爽，所以最后我还是切换回1.5。这个时候问题就出现了，切换回去后gradle编译正常，可是当运行程序时却报错Unsupported method: AndroidProject.getPluginGeneration()。解决这个问题最直接的办法是在切回2.2（–！！！）但是这相当于我们被锁在了最新的版本，这怎么能行！！所以我找了一些资料，发现是因为android studio2.2自动会把Instant Run开启，而当你把gradle版本切回老版时，Instant Run依旧是开启状态，而这时已经不支持这个功能了，所有会报这个错误。所以最终的解决方法是Instant Run关闭。操作路径： ####Windows &amp; Linux:File -&gt; Settings -&gt; Build, Execution, Deployment -&gt; Instant Run. ####Mac:Android Studio -&gt; Preferences -&gt; Build, Execution, Deployment -&gt; Instant Run. 最后再说一句：android studio2.2确实比之前的版本好，Instant Run在绝大多数情况下也确实快和方便，建议大家还是把它开起来吧（我最后还是用回到gradle2.2了）。","categories":[{"name":"gradle","slug":"gradle","permalink":"https://earthwo.github.io/categories/gradle/"},{"name":"android studio","slug":"gradle/android-studio","permalink":"https://earthwo.github.io/categories/gradle/android-studio/"}],"tags":[{"name":"gradle","slug":"gradle","permalink":"https://earthwo.github.io/tags/gradle/"},{"name":"android studio","slug":"android-studio","permalink":"https://earthwo.github.io/tags/android-studio/"}]},{"title":"透明activity注意事项","slug":"透明activity注意事项","date":"2016-09-22T02:19:21.000Z","updated":"2019-03-11T07:35:22.331Z","comments":true,"path":"2016/09/22/透明activity注意事项/","link":"","permalink":"https://earthwo.github.io/2016/09/22/透明activity注意事项/","excerpt":"","text":"之前在实现activity 滑动退出时，需要用到透明activity。结果在设置透明activity时遇到了很多的小问题，问题虽小，解决起来也很快，但还是有必要单拎出来说一下，免得其他小伙伴也掉进去。 首先先来看一下怎样设置透明activity：&lt;item name=&quot;android:windowIsTranslucent&quot;&gt;true&lt;/item&gt;&lt;item name=&quot;android:colorBackgroundCacheHint&quot;&gt;@null&lt;/item&gt;&lt;item name=&quot;android:windowBackground&quot;&gt;@android:color/transparent&lt;/item&gt; 看上去好像第三句是关键，其实第一句也极其重要。不设置windowIsTranslucent，整个透明activity会成为黑色。colorBackgroundCacheHint则可以清除背景颜色的缓存。 接下来说说坑的事。 在设置了透明背景后，activity的进入退出动画会消失，解决办法是设置&lt;item name=&quot;android:windowAnimationStyle&quot;&gt; @android:style/Animation.Translucent &lt;/item&gt;。这个时候坑就来了，Translucent动画在应用里面打开和退出activity都是正常的，但是在退出应用时，会依然是这么个动画，这个就很不舒服了。而换其他的动画或者是自己定义的动画，在应用内是没有动画的。最后是在activity中使用代码解决问题。overridePendingTransition(R.anim.anim_enter,R.anim.anim_exit);","categories":[{"name":"tips","slug":"tips","permalink":"https://earthwo.github.io/categories/tips/"}],"tags":[{"name":"tips","slug":"tips","permalink":"https://earthwo.github.io/tags/tips/"}]},{"title":"DownloadManager实现文件下载","slug":"DownloadManager实现文件下载","date":"2016-09-20T07:16:58.000Z","updated":"2019-03-11T07:35:22.316Z","comments":true,"path":"2016/09/20/DownloadManager实现文件下载/","link":"","permalink":"https://earthwo.github.io/2016/09/20/DownloadManager实现文件下载/","excerpt":"","text":"Android开发中，网络功能是必不可少的，其中很多时候我们还会用到文件下载。实现文件下载的方法很多，很多的第三方网络框架也都很容易的实现文件下载。这里给大家介绍系统自带的一个下载文件类DownLoadManager，它相比于其他的方法有几个优势：1.没有兼容问题。DownLoadManager在API 9时就开始支持了，所以不用担心在兼容问题。2.支持断点续传，大文件下载，自动支持通知栏进度显示。3.使用简单。 按照使用的习惯，首先来看看怎样使用String url=&quot;http://7xjrms.com1.z0.glb.clouddn.com/stream.mp4&quot;;DownloadManager.Request request=new DownloadManager.Request(Uri.parse(url));request.setDestinationInExternalFilesDir(this,&quot;/download&quot;,url.hashCode()+&quot;.mp4&quot;);DownloadManager downloadManager= (DownloadManager) getSystemService(Context.DOWNLOAD_SERVICE);downloadManager.enqueue(request); 使用它就这么简单。先设置下载地址，添加请求，再设置保存文件的地址，最后获取下载服务，将请求添加到下载队列。 接下来再看看怎样扩展通过看源码，我们可以看到DownLoadManager里面有两个内部类Request和Query。其中Request我们之前已经用到过了，它主要就是用户网络请求的，而Query则主要用于下载任务的查找等。其它还有一些方法，我们简单来看看： addCompletedDownload()添加一个文件到下载数据库，这样可以在系统的下载中看到这个下载任务，也可以在通知栏中显示。getMimeTypeForDownloadedFile()根据id获取文件类型，如果下载成功，则返回下载文件的文件类型，如果不成功，则返回null。getUriForDownloadedFile()根据id获取文件的uri，失败返回null。openDownloadedFile()根据id打开已下载的文件。（我一直打不开。。。）remove()删除多个下载任务和相应的下载文件enqueue()添加下载任务query()添加查询任务 主要的方法就这些，这些方法主要还是对整个下载服务的管理，而具体对下载任务的设置主要在Request中，接下来我们来看看Request中的方法： setDestinationUri()setDestinationInExternalFilesDir()setDestinationInExternalPublicDir() 这些方法是设置文件保存的位置allowScanningByMediaScanner()文件下载完后是否被媒体扫描（在添加请求前设置）addRequestHeader()添加请求头setAllowedNetworkTypes()设置下载允许的网络(可以设置为DownloadManager.Request.NETWORK_MOBILE， DownloadManager.Request.NETWORK_WIF和DownloadManager.Request. NETWORK_BLUETOOTH)默认情况下都可以setAllowedOverMetered()是否允许“计量式的网络连接”执行下载操作setAllowedOverRoaming()是否允许漫游状态下，执行下载操作setMimeType()设置下载文件的类型setTitle()设置通知的标题setDescription()设置通知的描述setNotificationVisibility()设置是否显示通知setVisibleInDownloadsUi()设置是否显示在系统下载列表中 这些方法，基本上完全满足了我们对于下载一个文件的需求。同时，我们可以监听文件下载完成来进行后续的操作。DownLoadManager在文件现在完成时会发送一个action为ACTION_DOWNLOAD_COMPLETE的广播，所以我们可以注册BroadcastReceiver来监听：private class DownLoadCompleteReceiver extends BroadcastReceiver &#123; @Override public void onReceive(Context context, Intent intent) &#123; if(intent.getAction().equals(DownloadManager.ACTION_DOWNLOAD_COMPLETE))&#123; Toast.makeText(DownloadManagerActivity.this, &quot;下载任务已经完成！&quot;, Toast.LENGTH_SHORT).show(); &#125; &#125; &#125; 获取下载信息我们可以通过DownManager.Query对象来查询所有下载任务信息。setFilterById(long… ids)根据任务编号查询下载任务信息setFilterByStatus(int flags)根据下载状态查询下载任务 在这里我就不再展开了。","categories":[{"name":"http","slug":"http","permalink":"https://earthwo.github.io/categories/http/"}],"tags":[{"name":"http","slug":"http","permalink":"https://earthwo.github.io/tags/http/"}]},{"title":"swipefinishlayout 的实现","slug":"swipefinishlayout-的实现","date":"2016-09-19T09:14:38.000Z","updated":"2019-03-11T07:35:22.328Z","comments":true,"path":"2016/09/19/swipefinishlayout-的实现/","link":"","permalink":"https://earthwo.github.io/2016/09/19/swipefinishlayout-的实现/","excerpt":"","text":"很多android手机用户会发现ios应用自带右滑退出，这个功能虽小，却能很大程度上提高用户的使用体验，尤其是现在手机的尺寸越来越大的情况下。因此，越来越多的android应用也实现了这个效果。之前看到我一个朋友实现了android activity滑动关闭的效果，当时觉得好厉害，但是当自己尝试着去实现时发现，其实这个功能实现还是蛮简单的，现在在这里，我就讲讲如何使用几十行代码实现activity滑动关闭。 实现原理activity滑动关闭的实现原理主要是activity的所有布局都包含在一个自定义的viewgroup中，当手指从屏幕左边缘滑动时，viewgroup做相应的scroll，当手指放开时，根据已经滑动的距离，返回原来的状态或整体滑动到最右边，并退出。 实现步骤第一步，定义一个底层view并加入到viewgroup中其实一开始我并不打算这么做，当时我直接把view都加在swipefinishlayout中。但是后来发现当swipefinishlayout中没有其他布局时，滑动效果无法出现，同时加入到swipefinishlayout中只能是一个view。所以为了解决这个问题，我就在创建时自己先加入一个Framlayout,其他的布局加到Framlayou中。rootView=new FrameLayout(getContext(),attrs,defStyleAttr);LayoutParams layoutParams=new LayoutParams(LayoutParams.MATCH_PARENT,LayoutParams.MATCH_PARENT);rootView.setLayoutParams(layoutParams);this.addView(rootView);this.setBackgroundColor(Color.TRANSPARENT); 这里可以看到，我们把怎个布局的颜色设置为透明，同时把原先设置在布局中的颜色设置给rootview。同时把原先添加到swipefinishlayout中的view添加到Framlayout中。public void addView(View child, int index, LayoutParams params) &#123; if(child==rootView) &#123; super.addView(child, index, params); &#125;else&#123; rootView.addView(child,index,params); &#125; &#125; 同时把原先加到swipefinishlayout中的view加到rootview中。 第二步，重写ontouch方法，让整体随手指滑动儿滑动这部分是整个swipefinishlayout中的重中之重。首先，在手指开始按下时，要判断是否开启滑动操作，而判断的依据可根据实际需求来变换。这里我主要是判断ontouch方法中触点是否在最左边1/7处。firstTouchRect=new Rect(0,0,width/7,height);firstTouchRect.contains(event.getX(), event.getY())而在滑动事件中，整体根据手指的触点位置滚动scrollTo(-(int) x, 0);if(rootView!=null&amp;&amp;isTransparent)&#123; rootView.setAlpha(1-Math.abs(this.getScrollX()*1.0f/width)/5);&#125;invalidate(); 第三步，手指放开时，自动回滚到原来位置或者滑到最右边并退出在这里我们需要用到scroller这个类。根据当前的滑动位置来关闭或者还原，时间都是500msif(isClose)&#123; scroller.startScroll(-startX,0,startX,0,500);&#125;else&#123; scroller.startScroll(-startX,0,startX-width,0,500);&#125;invalidate(); 同时重写computeScroll方法，根据当前的scroller值，滑动整体布局。if(scroller!=null&amp;&amp;scroller.computeScrollOffset())&#123; int x=scroller.getCurrX(); int y=scroller.getCurrY(); if(rootView!=null) scrollTo(x,y); invalidate();&#125; 到这里，一个简单的滑动退出swipefinishlayout就完成了，这当中有很多的参数和样式都可以进行定制和拓展，这里就不在展开。DEMO地址","categories":[{"name":"自定义view","slug":"自定义view","permalink":"https://earthwo.github.io/categories/自定义view/"}],"tags":[{"name":"自定义view","slug":"自定义view","permalink":"https://earthwo.github.io/tags/自定义view/"}]},{"title":"HandlerThread分析","slug":"HanlderThread","date":"2016-09-07T09:05:01.000Z","updated":"2019-03-11T07:35:22.317Z","comments":true,"path":"2016/09/07/HanlderThread/","link":"","permalink":"https://earthwo.github.io/2016/09/07/HanlderThread/","excerpt":"","text":"HandlerThread是Thread的子类，它可以创建一个looper。而该looper对象可以用于创建Handler类来进行来进行调度。之前在用它时有两个疑问：一是Looper是在哪里创建的，二是怎样保证Looper是在创建之后才被使用。接下来通过HandlerThread的源码来看看它是如何实现的。HandlerThread的源码十分简短，总共才100多行。首先看看其构造方法：public HandlerThread(String name) &#123; super(name); mPriority = Process.THREAD_PRIORITY_DEFAULT; &#125; /** * Constructs a HandlerThread. * @param name * @param priority The priority to run the thread at. The value supplied must be from * &#123;@link android.os.Process&#125; and not from java.lang.Thread. */ public HandlerThread(String name, int priority) &#123; super(name); mPriority = priority; &#125; 构造方法其实啥也没干，就是简单的记录线程的name和优先级。再看看run方法：@Overridepublic void run() &#123; mTid = Process.myTid(); Looper.prepare(); synchronized (this) &#123; mLooper = Looper.myLooper(); notifyAll(); &#125; Process.setThreadPriority(mPriority); onLooperPrepared(); Looper.loop(); mTid = -1;&#125; 这里我们看到了，Looper是在run方法中被创建的。在创建完成之后，用了同步锁将looper实例初始化锁了起来，这里用了同步，是为了避免在getLooper时程序无法被唤醒。最后开始循环looper。然后看看getLooper方法：public Looper getLooper() &#123; if (!isAlive()) &#123; return null; &#125; // If the thread has been started, wait until the looper has been created. synchronized (this) &#123; while (isAlive() &amp;&amp; mLooper == null) &#123; try &#123; wait(); &#125; catch (InterruptedException e) &#123; &#125; &#125; &#125; return mLooper; &#125; 首先，looper的获取必须要在线程在alive状态，因此说明在使用时必须先调用onStart方法，在获取这个looper，其次，当looper为null时，程序将等待阻塞，直到在run方法中唤醒程序，返回looper。当不在需要该looper时，可以将looper退出：public boolean quit() &#123; Looper looper = getLooper(); if (looper != null) &#123; looper.quit(); return true; &#125; return false; &#125; public boolean quitSafely() &#123; Looper looper = getLooper(); if (looper != null) &#123; looper.quitSafely(); return true; &#125; return false; &#125; 最后回答之前的两个问题，首先Looper是在run方法中创建的，同时用到了synchronized来避免出现同步问题；在looper获取过程中，如果looper还没有创建，那会阻塞等待run中创建完成之后重新唤醒。","categories":[{"name":"源码阅读","slug":"源码阅读","permalink":"https://earthwo.github.io/categories/源码阅读/"}],"tags":[{"name":"源码阅读","slug":"源码阅读","permalink":"https://earthwo.github.io/tags/源码阅读/"}]},{"title":"Preference使用教程","slug":"Preference使用教程","date":"2016-08-16T06:11:29.000Z","updated":"2019-03-11T07:35:22.320Z","comments":true,"path":"2016/08/16/Preference使用教程/","link":"","permalink":"https://earthwo.github.io/2016/08/16/Preference使用教程/","excerpt":"","text":"前言这几天在看书时，意外地看到了Preference框架。相对于IOS SDK，这个功能在创建设置界面时会更加容易一点。开发者只需要编辑一个简单的xml文件，就能开发出一个简单的设置界面。我在网上找了一些资料，看到这些资料都只是简单的介绍了这个功能的使用，不够具体时间上也比较早。现在我就详细的介绍一下它的使用。 使用场景在Android手机中都有设置功能，许多的android应用也有相应的设置界面允许用户修改应用特性和行为。在为这些应用提供设置 功能时，开发者应该使 Android的Preference API构建一个与其他Android应用中的用户体验一致的界面（包括系统设置）。 概览设置是使用在XML文件中声明的 Preference 类的各种子类构建而成，而不是使用View对象构建用户界面。Preference 对象是单个设置的构建基块。每个Preference都有一个相应的键值对，可供系统用来将设置保存在应用设置的默认SharedPreferences文件中。当用户更改设置时，系统会自动更新SharedPreferences文件中的相应值。开发者只应在需要读取值以根据用户设置确定应用的行为时，才与关联的 SharedPreferences文件直接交互。保存在SharedPreferences中的值主要是以下数据类型：1.布尔型2.浮点型3.整型4.长整型5.字符串6.字符串 Set同时，开发者还需要专门的Activity和Fragment子类来显示UI。在3.0之前的Android版本中，开发者必须使用继承PreferenceActivity的activity；在3.0及更高的版本中，开发者可以使用普通的activity，同时使用继承PreferenceFragment的Fragment。如果需要多组设置，则可以使用PreferenceActivity为大屏幕创建双窗格布局。 首选项Preference 对象是单个设置的构建基块，而其他的应用设置都是Preference的子类表示。每个子类都可以指定标题和默认值等内容，同时也有自己特定的属性和用户界面。最常用的首选项如下：CheckBoxPreference:CheckBoxPreference 可创建一个列表项用于显示复选框，显示一个包含已启用或已禁用设置复选框的项目。ListPreference:ListPreference 可创建一个项目用于打开包含选择列表的对话框,打开一个包含单选按钮列表的对话框。保存的值可以是任一受支持的值类型。EditTextPreference:打开一个包含 EditText 小工具的对话框。DialogPreference：打开一个dialog对话框。MultiSelectListPreference：打开一个包含多选按钮列表的对话框。SwitchPreference：一个switch选择器。 使用 XML 定义首选项开发者开始在运行时直接实例化新的Preference对象，但是一般情况下，还是应该在XML文件中定义设置列表。这样更容易阅读和查看。XML文件必须保存在 res/xml/ 目录中。 XML文件中的根节点必须是元素，在元素中可以添加任意的preference元素，每一个子项都会显示在设置列表中。&lt;EditTextPreference android:key=&quot;edit_preference&quot; android:title=&quot;输入框&quot; android:summary=&quot;输入框&quot;/&gt;&lt;CheckBoxPreference android:key=&quot;checkbox_preference&quot; android:title=&quot;开关&quot; android:summary=&quot;开关按钮&quot; android:defaultValue=&quot;true&quot; /&gt; 在此示例中，两个项有3个共同的属性：1.android:key：对于要保留数据值的首选项，必须拥有此属性。它指定系统在将此设置的值保存在 SharedPreferences 中时所用的唯一键（字符串）。2.android:title：此属性为设置提供用户可见的名称。3.android:summary：此属性为设置提供用户可见的概述。 使用设置组如果开发者的设置列表中需要的设置选项比较多时，开发者可以使用设置组来进行分组，方便用户浏览、理解和处理设置。设置组可以有效的将一个长列表转化成多个段列表，方法有以下两种： 使用标题以分隔线分隔两组设置并为其提供标题，将每组 Preference 对象放入 PreferenceCategory 内。 &lt;PreferenceScreen xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;&lt;PreferenceCategory android:title=&quot;主要组件&quot;&gt; &lt;EditTextPreference android:key=&quot;edit_preference&quot; android:title=&quot;输入框&quot; android:summary=&quot;输入框&quot;/&gt; &lt;CheckBoxPreference android:key=&quot;checkbox_preference&quot; android:title=&quot;开关&quot; android:summary=&quot;开关按钮&quot; android:defaultValue=&quot;true&quot; /&gt;&lt;/PreferenceCategory&gt;&lt;/PreferenceScreen&gt; 使用子屏幕将设置或设置组放入到子屏幕,点击时会跳转到子屏幕显示。 &lt;PreferenceScreen xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;PreferenceScreen android:key=&quot;button_voicemail_setting_key&quot; android:title=&quot;子页面&quot; android:persistent=&quot;false&quot;&gt; &lt;Preference android:summary=&quot;子页面文本框&quot; android:title=&quot;子页面文本框&quot; android:dependency=&quot;list_preference&quot; android:key=&quot;text_preference&quot;&gt; &lt;/Preference&gt; &lt;/PreferenceScreen&gt;&lt;/PreferenceScreen&gt; 使用 Intent 跳转在特殊情况，应用需要在设置页面跳转到应用的其他页面。所以要在用户选择首选项时调用Intent，需要在相应的Preference元素中添加intent。添加的intent的可以分为隐式和显式。&lt;Preference android:title=&quot;intent&quot; &gt; &lt;intent android:action=&quot;android.intent.action.VIEW&quot; android:data=&quot;http://www.google.com&quot; /&gt;&lt;/Preference&gt;&lt;Preference android:title=&quot;intent&quot; &gt; &lt;intent android:targetClass=&quot;com.orange.studydemo.SecondActivity&quot; android:targetPackage=&quot;com.orange.studydemo&quot;/&gt;&lt;/Preference&gt; intent可以添加一下属性：android:action：要分配的操作（按照 setAction() 方法）。android:data：要分配的数据（按照 setData() 方法）。android:mimeType：要分配的 MIME 类型（按照 setType() 方法）。android:targetClass：组件名称的类部分（按照 setComponent() 方法）。android:targetPackage：组件名称的软件包部分（按照 setComponent() 方法）。 创建首选项的 Activity 和 Fragment在XML文件配置完成之后，要在Activity中显式设置，需要扩展PreferenceActivity类。该类会根据自动保留每个Preference相关的设置。public class SettingsActivity extends PreferenceActivity &#123; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); addPreferencesFromResource(R.xml.preferences); &#125;&#125; 在Android3.0及更高的版本中，应该使用PreferenceFragment来代替PreferenceActivity的使用。在PreferenceFragment中使用与在PreferenceActivity中使用基本一样。public static class SettingsFragment extends PreferenceFragment &#123; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); addPreferencesFromResource(R.xml.preferences); &#125;&#125; 同时需要在Activity中添加Fragment，代码如下：public class SettingsActivity extends Activity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); getFragmentManager().beginTransaction() .replace(android.R.id.content, new SettingsFragment()) .commit(); &#125;&#125; 设置默认值在很多情况下，我们需要在用户第一次打开应用时就有默认值。所以需要对相应的Preference设置默认值。设置默认值需要在XML文件中对Preference设置 android:defaultValue 属性。不同的 Preference 的默认值类型页不一样，比如CheckBoxPreference 的默认值是布尔值，而 ListPreference 的默认值类型是string。 然后需要在应用的主activity（设置为 的activity）中的oncreate()方法中调用setDefaultValues（）方法PreferenceManager.setDefaultValues(this,R.xml.main_activity,false); 其中第三个参数表示是否多次设置默认值。如果第三个参数设置为false，则应用只有在第一次调用activity时会设置默认值，如果设置为true，则每次应用打开时都会将值设置为默认值。 使用首选项标头在大显示屏尤其是pad情况下，我们应该使用标头功能，而不是使用嵌套功能。使用标头功能的好处是在大屏幕上，preferenceActivity会自动提供双窗口显示。如下图： 而在小屏幕中则与嵌套差不多。使用标头构建设置的方法： 创建多个PreferenceFragment实例，每个实例都需要一个单独的XML文件。 创建XML标头文件，其中每个设置都要对应一个相应的fragment。&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;preference-headers xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;header android:fragment=&quot;com.example.prefs.SettingsActivity$SettingsFragmentOne&quot; android:title=&quot;标头1&quot; android:summary=&quot;标头1&quot; /&gt; &lt;header android:fragment=&quot;com.example.prefs.SettingsActivity$SettingsFragmentTwo&quot; android:title=&quot;标头2&quot; android:summary=&quot;标头2&quot; &gt; &lt;extra android:name=&quot;someKey&quot; android:value=&quot;someHeaderValue&quot; /&gt; &lt;/header&gt;&lt;/preference-headers&gt; 在元素中可以使用bundle传递其他参数，在片段中可以使用getArgument()来获取参数，从而根据不同的参数使用同一个fragment加载不同的xml文件。 将activity继承PreferenceActivity，并且实现onBuildHeaders()方法来显示标头，同时需要重写isValidFragment方法，对可以使用的fragment返回true。public class SettingsActivity extends PreferenceActivity &#123; @Override public void onBuildHeaders(List&lt;Header&gt; target) &#123; loadHeadersFromResource(R.xml.preference_headers, target); &#125; @Override protected boolean isValidFragment(String fragmentName) &#123; return true; &#125;&#125; 由于header是在android3.0之后添加的新功能，所以如果要兼容3.0之前的版本，我们需要在使用前文介绍的嵌套功能进行兼容。activity主要的代码如下：@Overridepublic void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); if (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.HONEYCOMB) &#123; addPreferencesFromResource(R.xml.preference_headers_legacy); &#125;&#125;@Overridepublic void onBuildHeaders(List&lt;Header&gt; target) &#123; loadHeadersFromResource(R.xml.preference_headers, target);&#125; 读取和监听首选项的变化 读取首选项默认情况下，应用的所有首选项均保存到一个文件中，该文件可以通过调用静态方法 PreferenceManager.getDefaultSharedPreferences()，从应用内的任何位置访问。 SharedPreferences sharedPref = PreferenceManager.getDefaultSharedPreferences(this);String value = sharedPref.getString(key, defaultValue); 监听首选项变化要在任一首选项发生更改时收到回调，Activity需要实现 SharedPreference.OnSharedPreferenceChangeListener 接口，并通过调用 registerOnSharedPreferenceChangeListener() 为 SharedPreferences 对象注册侦听器。该接口只有 onSharedPreferenceChanged() 一种回调方法，在回调中可以获取变化的Preference和相应的值。 public void onSharedPreferenceChanged(SharedPreferences sharedPreferences,String key) &#123; if (key.equals(&quot;key&quot;)) &#123; Preference preference = findPreference(key); String value=sharedPreferences.getString(key, &quot;&quot;); &#125; &#125; 为了能够保证侦听器不被当做垃圾回收，我们最好在 onResume() 和 onPause() 回调期间分别注册和注销SharedPreferences.OnSharedPreferenceChangeListener。@Overrideprotected void onResume() &#123; super.onResume(); getPreferenceScreen().getSharedPreferences() .registerOnSharedPreferenceChangeListener(this);&#125;@Overrideprotected void onPause() &#123; super.onPause(); getPreferenceScreen().getSharedPreferences() .unregisterOnSharedPreferenceChangeListener(this);&#125;","categories":[{"name":"Preference","slug":"Preference","permalink":"https://earthwo.github.io/categories/Preference/"}],"tags":[{"name":"Preference","slug":"Preference","permalink":"https://earthwo.github.io/tags/Preference/"}]},{"title":"IntentService解析","slug":"IntentService解析","date":"2016-08-04T03:10:33.000Z","updated":"2019-03-11T07:35:22.317Z","comments":true,"path":"2016/08/04/IntentService解析/","link":"","permalink":"https://earthwo.github.io/2016/08/04/IntentService解析/","excerpt":"","text":"IntentService是Service的子类，它只要是处理异步请求。与普通的Service相比，它有两点区别：一是它的操作都是在异步线程中进行，二是它执行完成之后会自动停止。那我们就来看看它内部是如何实现的。IntentService的源码真的是非常简单，只有区区几十行代码。首先来看看oncreate方法：@Override public void onCreate() &#123; // TODO: It would be nice to have an option to hold a partial wakelock // during processing, and to have a static startService(Context, Intent) // method that would launch the service &amp; hand off a wakelock. super.onCreate(); HandlerThread thread = new HandlerThread(&quot;IntentService[&quot; + mName + &quot;]&quot;); thread.start(); mServiceLooper = thread.getLooper(); mServiceHandler = new ServiceHandler(mServiceLooper); &#125; 首先它会创建一个HandlerThread，HandlerThread继承自Thread，它内部会获取到一个自己的Looper。然后再用该Thread的looper创建Handler。再来看看onStartCommand方法：@Override public int onStartCommand(Intent intent, int flags, int startId) &#123; onStart(intent, startId); return mRedelivery ? START_REDELIVER_INTENT : START_NOT_STICKY; &#125; 这里主要是执行了onStart方法，那再看看onStart方法：@Override public void onStart(Intent intent, int startId) &#123; Message msg = mServiceHandler.obtainMessage(); msg.arg1 = startId; msg.obj = intent; mServiceHandler.sendMessage(msg); &#125; onStart方法主要就是将传递过来的Intent，作为message传递给ServiceHandler，这样每个操作就会在ServiceHandler中以工作队列的方式依次执行。那再来看看ServiceHandler的具体实现。private final class ServiceHandler extends Handler &#123; public ServiceHandler(Looper looper) &#123; super(looper); &#125; @Override public void handleMessage(Message msg) &#123; onHandleIntent((Intent)msg.obj); stopSelf(msg.arg1); &#125; &#125; ServiceHandler在实现时，一是执行onHandleIntent方法，这个方法需要我们实现并做具体的逻辑操作，然后停止该IntentService。最后在Service被销毁时经looper的任务销毁。@Override public void onDestroy() &#123; mServiceLooper.quit(); &#125; 全部代码几乎都在这里了。最后再来理一下整个流程：首先创建时会创建一个线程，在通过该线程创建Handler，然后将任务添加到添加到该Handler中，在过程中每次创建时都会讲任务添加到Handler的任务队列，执行完成之后就会将服务停止。","categories":[{"name":"源码阅读","slug":"源码阅读","permalink":"https://earthwo.github.io/categories/源码阅读/"}],"tags":[{"name":"源码阅读","slug":"源码阅读","permalink":"https://earthwo.github.io/tags/源码阅读/"}]},{"title":"AsyncTask解析","slug":"AsyncTask解析","date":"2016-07-23T02:31:10.000Z","updated":"2019-03-11T07:35:22.314Z","comments":true,"path":"2016/07/23/AsyncTask解析/","link":"","permalink":"https://earthwo.github.io/2016/07/23/AsyncTask解析/","excerpt":"","text":"AsyncTask是我们在开发过程中经常使用的类，它是一个抽象类，主要用来实现轻量级异步操作。那接下来我们就看看它的内部实现。public AsyncTask() &#123; mWorker = new WorkerRunnable&lt;Params, Result&gt;() &#123; public Result call() throws Exception &#123; mTaskInvoked.set(true); Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND); //noinspection unchecked Result result = doInBackground(mParams); Binder.flushPendingCommands(); return postResult(result); &#125; &#125;; mFuture = new FutureTask&lt;Result&gt;(mWorker) &#123; @Override protected void done() &#123; try &#123; postResultIfNotInvoked(get()); &#125; catch (InterruptedException e) &#123; android.util.Log.w(LOG_TAG, e); &#125; catch (ExecutionException e) &#123; throw new RuntimeException(&quot;An error occurred while executing doInBackground()&quot;, e.getCause()); &#125; catch (CancellationException e) &#123; postResultIfNotInvoked(null); &#125; &#125; &#125;; &#125; AsyncTask的构造方法主要实现了初始化了两个对象，一个是WorkerRunnable对象mWorker，WorkerRunnable是它的内部静态类，并且实现了Callable接口，里面只有一个数组；另一个是FutureTask对象mFuture，该类实现了Runnable接口和Futrue接口。这两个对象具体有什么用，先按下不表。使用AsyncTask时，我们都需要调用excute方法，并且传入相应的参数，那就来看看excute的实现。public final AsyncTask&lt;Params, Progress, Result&gt; execute(Params... params) &#123; return executeOnExecutor(sDefaultExecutor, params); &#125; 这里它调用了executeOnExecutor方法，同时传入sDefaultExecutor和我们外边传入的参数。sDefaultExecutor是一个线程池，它的用处后面再说。public final AsyncTask&lt;Params, Progress, Result&gt; executeOnExecutor(Executor exec, Params... params) &#123; if (mStatus != Status.PENDING) &#123; switch (mStatus) &#123; case RUNNING: throw new IllegalStateException(&quot;Cannot execute task:&quot; + &quot; the task is already running.&quot;); case FINISHED: throw new IllegalStateException(&quot;Cannot execute task:&quot; + &quot; the task has already been executed &quot; + &quot;(a task can be executed only once)&quot;); &#125; &#125; mStatus = Status.RUNNING; onPreExecute(); mWorker.mParams = params; exec.execute(mFuture); return this; &#125; executeOnExecutor方法中，首先是判断整个任务的状态，只有当任务状态为等待时才能执行，同时我们也可以发现，整个类中没有将状态重新置为等待的方法，所以说明一个AsyncTask对象只能执行一次。之后会执行onPreExecute方法，进行任务前的预操作，同时将传入的参数胡设置到mWorker中，然后将FutureTask对象mFuture添加到线程池中执行。接下来就看一下这个sDefaultExecutor线程池的实现。sDefaultExecutor是AsyncTask的静态类SerialExecutor对象，它实现了Executor接口，里面有一个任务队列和一个当前任务对象，在它的execute方法中，我们可以发现，它并没有去实现具体的操作逻辑，只是将添加的任务添加到任务队列中，同时当当前任务对象为空时，从队列中取出任务，在THREAD_POOL_EXECUTOR线程池中执行。THREAD_POOL_EXECUTOR是AsyncTask的静态对象，这样做可以减少线程池的创建。同时它的核心线程数为cpu+1个，最大线程数为cpu*2+1个，线程存活时间为1s，任务队列空间为128。该线程最终会执行添加进来的mFuture任务。那接来下看一下mFuture的实现。public void run() &#123; if (state != NEW || !U.compareAndSwapObject(this, RUNNER, null, Thread.currentThread())) return; try &#123; Callable&lt;V&gt; c = callable; if (c != null &amp;&amp; state == NEW) &#123; V result; boolean ran; try &#123; result = c.call(); ran = true; &#125; catch (Throwable ex) &#123; result = null; ran = false; setException(ex); &#125; if (ran) set(result); &#125; &#125; finally &#123; // runner must be non-null until state is settled to // prevent concurrent calls to run() runner = null; // state must be re-read after nulling runner to prevent // leaked interrupts int s = state; if (s &gt;= INTERRUPTING) handlePossibleCancellationInterrupt(s); &#125; &#125; 之前说过，FutureTask实现了runnable接口，在其run方法中，我们发现它会去调用在创建时传入的Callable对象的call方法，获得返回值后，调用set方法设置返回值，最后调用外AsyncTask中实现的done方法。call方法实现如下:mWorker = new WorkerRunnable&lt;Params, Result&gt;() &#123; public Result call() throws Exception &#123; mTaskInvoked.set(true); Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND); //noinspection unchecked Result result = doInBackground(mParams); Binder.flushPendingCommands(); return postResult(result); &#125; &#125;; call方法中主要是执行doInBackground方法，获得返回值后返回。mFuture = new FutureTask&lt;Result&gt;(mWorker) &#123; @Override protected void done() &#123; try &#123; postResultIfNotInvoked(get()); &#125; catch (InterruptedException e) &#123; android.util.Log.w(LOG_TAG, e); &#125; catch (ExecutionException e) &#123; throw new RuntimeException(&quot;An error occurred while executing doInBackground()&quot;, e.getCause()); &#125; catch (CancellationException e) &#123; postResultIfNotInvoked(null); &#125; &#125; &#125;; 而done方法这时获取之前的结果，并且调用postResultIfNotInvoked方法。private void postResultIfNotInvoked(Result result) &#123; final boolean wasTaskInvoked = mTaskInvoked.get(); if (!wasTaskInvoked) &#123; postResult(result); &#125; &#125; private Result postResult(Result result) &#123; @SuppressWarnings(&quot;unchecked&quot;) Message message = getHandler().obtainMessage(MESSAGE_POST_RESULT, new AsyncTaskResult&lt;Result&gt;(this, result)); message.sendToTarget(); return result; &#125; postResultIfNotInvoked方法中最终会将之前的结果打包成一个message到hanlder。private static class InternalHandler extends Handler &#123; public InternalHandler() &#123; super(Looper.getMainLooper()); &#125; @SuppressWarnings(&#123;&quot;unchecked&quot;, &quot;RawUseOfParameterizedType&quot;&#125;) @Override public void handleMessage(Message msg) &#123; AsyncTaskResult&lt;?&gt; result = (AsyncTaskResult&lt;?&gt;) msg.obj; switch (msg.what) &#123; case MESSAGE_POST_RESULT: // There is only one result result.mTask.finish(result.mData[0]); break; case MESSAGE_POST_PROGRESS: result.mTask.onProgressUpdate(result.mData); break; &#125; &#125; &#125; 该handler创建在主线程中，处理主要分两种，一种是更新进度，一种是结束事件。private void finish(Result result) &#123; if (isCancelled()) &#123; onCancelled(result); &#125; else &#123; onPostExecute(result); &#125; mStatus = Status.FINISHED; &#125; 结束事件时会调用finish方法，最终会执行自己实现的onPostExecute方法，而更新进度时则会执行实现的onProgressUpdate方法。最后总结一下，AsyncTask使用时，会有一个线程池，用来执行具体的任务，还有一个Executor，用来添加、获取任务。同时在执行任务时，会有一个Callable处理多线程任务，同时回调结果，结果回调到runnable接口，同时使用handler执行主线程回调方法。","categories":[{"name":"源码阅读","slug":"源码阅读","permalink":"https://earthwo.github.io/categories/源码阅读/"}],"tags":[{"name":"源码阅读","slug":"源码阅读","permalink":"https://earthwo.github.io/tags/源码阅读/"}]},{"title":"第一个ndk程序","slug":"第一个jni程序","date":"2016-06-14T10:11:23.000Z","updated":"2019-03-11T07:35:22.330Z","comments":true,"path":"2016/06/14/第一个jni程序/","link":"","permalink":"https://earthwo.github.io/2016/06/14/第一个jni程序/","excerpt":"","text":"之前写过一个如何创建ndk程序并且调用相关的c语言方法，虽然方法是可行的，但是过程怎么看都别扭，都有一种投机取巧的感觉。查阅网上的相关资料，资料虽多，但是不是写的很复杂，就是时间太久了无法再适用了。哎，第三方资料都靠不住呀，只能看官方资料了。官方资料其实很简单，而且基于 Android Studio 2.2 或者更高的版本，同时要求 Gradle version 2.2.0 或更高的版本。现在来看看怎样编写第一个ndk程序。首先要先下载一些工具包，这些都可以在sdk manager中下载。这三个包的主要用途如下：ndk:NDK 提供了一系列的工具，帮助开发者快速开发 C（或C++）的动态库，并能自动将 so 和 java 应用一起打包成 apk。这些工具对开发者的帮助是巨大的。CMake:一个外部的构建工具，与Gradle一起构建native库，如果你使用ndk-build就不需要下载它，在这里我使用CMake创建native库。LLDB:调试native代码工具。 在下载了上面三个库之后，如果你需要新建一个项目，那你只需要在创建项目的时候，选择include C++ Support选项，之后Android Studio就会帮你做好所有的事。在创建的新工程中，在main中有一个cpp文件夹，里面有mative-lib.cpp文件。同时在module目录中有一个CMakeLists.txt文件。你可以直接运行程序。 如果你需在在原项目的基础上添加ndk支持，又要怎么做呢？ 1.在下载了那三个工具的情况下，在main目录下添加一个文件夹（cpp）。 2.创建一个C/C++ Source File文件，里面添加c代码：(例子) #include &lt;jni.h&gt;#include &lt;string&gt;extern &quot;C&quot;JNIEXPORT jstringJNICALLJava_library_whitelife_hellojni_JniUtil_getString( JNIEnv *env, jobject /* this */) &#123; std::string hello = &quot;哈哈哈哈&quot;; return env-&gt;NewStringUTF(hello.c_str());&#125; 3.在module的根目录下创建CMakeLists.txt，注意一定要这样命名命名 4.里面添加相关内容 cmake_minimum_required(VERSION 3.4.1)add_library( # library名字. native-lib # Sets the library as a shared library. SHARED # 之前cpp文件的具体地址. src/main/cpp/native-lib.cpp ) 5.最后在module的build.gradle的android中添加相关支持 externalNativeBuild &#123; cmake &#123; path &quot;CMakeLists.txt&quot; &#125; &#125; 6.最后在java代码中调用库和方法 public class JniUtil &#123; public native String getString(); static &#123; System.loadLibrary(&quot;native-lib&quot;); &#125;&#125; 运行相关代码就可以调用c程序方法 ((TextView)findViewById(R.id.tv_text)). setText(new JniUtil().getString());","categories":[{"name":"NDK","slug":"NDK","permalink":"https://earthwo.github.io/categories/NDK/"}],"tags":[{"name":"NDK","slug":"NDK","permalink":"https://earthwo.github.io/tags/NDK/"}]},{"title":"AIDL简单入门","slug":"AIDL简单入门","date":"2016-06-13T07:07:40.000Z","updated":"2019-03-11T07:35:22.313Z","comments":true,"path":"2016/06/13/AIDL简单入门/","link":"","permalink":"https://earthwo.github.io/2016/06/13/AIDL简单入门/","excerpt":"","text":"AIDL是 Android Interface definition language的缩写，是android内部进程通信接口的描述语言，通过它我们可以进行进程间的通信。 AIDL使用步骤使用AIDL一般是在两个应用的通信中使用。一个作为服务端提供接口，一个作为客户端调用接口。 使用步骤1.在服务端定义自定义类型 注意需要实现Parcelable 接口：public class Car implements Parcelable &#123; public Car() &#123; &#125; private int prise; public int getPrise() &#123; return prise; &#125; public void setPrise(int prise) &#123; this.prise = prise; &#125; protected Car(Parcel in) &#123; this.prise=in.readInt();//这两个方法一定要重写，不然传递的数据为空 &#125; @Override public void writeToParcel(Parcel dest, int flags) &#123; dest.writeInt(this.prise);//这两个方法一定要重写，不然传递的数据为空 &#125; @Override public int describeContents() &#123; return 0; &#125; public static final Creator&lt;Car&gt; CREATOR = new Creator&lt;Car&gt;() &#123; @Override public Car createFromParcel(Parcel in) &#123; return new Car(in); &#125; @Override public Car[] newArray(int size) &#123; return new Car[size]; &#125; &#125;;&#125; 2.在服务端定义Car.aidlpackage com.orange.aidl;parcelable Car; 创建时会提示接口名字要唯一，所以我先创建一个其他名字的，在修改名字为car3.在服务端定义IMyAidlInterfaceimport com.orange.aidl.Car;interface IMyAidlInterface &#123; /** * Demonstrates some basic types that you can use as parameters * and return values in AIDL. */ int getCarPrise(in Car car); void setCar(in Car car); void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat, double aDouble, String aString);&#125; 4.在服务端创建并定义Service，同时在AndroidManifest中定义Serviceandroid:name=&quot;.MyService&quot;android:exported=&quot;true&quot;&gt;&lt;/service&gt; public class MyService extends Service &#123; public MyService() &#123; &#125; @Override public IBinder onBind(Intent intent) &#123; return iBinder; &#125; Car carl; private IBinder iBinder= new IMyAidlInterface.Stub() &#123; @Override public int getCarPrise(Car car) throws RemoteException &#123; if(carl!=null)&#123; return carl.getPrise(); &#125;else&#123; return 0; &#125; &#125; @Override public void setCar(Car car) throws RemoteException &#123; carl=car; &#125; @Override public void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat, double aDouble, String aString) throws RemoteException &#123; &#125; &#125;;&#125; 5.在客户端中重复前三步，其中名字都要一样6.在客户端中绑定服务端的服务private void bindService()&#123; Intent intent=new Intent(); intent.setComponent(new ComponentName(&quot;com.orange.aidl&quot;,&quot;com.orange.aidl.MyService&quot;)); bindService(intent,connection, Context.BIND_AUTO_CREATE); &#125; 7.在绑定服务后调用服务端的接口private ServiceConnection connection=new ServiceConnection() &#123; @Override public void onServiceConnected(ComponentName name, IBinder service) &#123; TextView textView= (TextView) findViewById(R.id.tv); iMyAidlInterface=IMyAidlInterface.Stub.asInterface(service); Car car=new Car(); car.setPrise(1245633); try &#123; iMyAidlInterface.setCar(car); int prise= iMyAidlInterface.getCarPrise(car); textView.setText(prise+&quot;&quot;); &#125; catch (RemoteException e) &#123; e.printStackTrace(); &#125; &#125; @Override public void onServiceDisconnected(ComponentName name) &#123; iMyAidlInterface = null; &#125; &#125;; demo地址github地址","categories":[{"name":"AIDL","slug":"AIDL","permalink":"https://earthwo.github.io/categories/AIDL/"}],"tags":[{"name":"AIDL","slug":"AIDL","permalink":"https://earthwo.github.io/tags/AIDL/"}]},{"title":"Andfix的简单使用","slug":"Andfix的简单使用","date":"2016-06-12T03:40:50.000Z","updated":"2019-03-11T07:35:22.313Z","comments":true,"path":"2016/06/12/Andfix的简单使用/","link":"","permalink":"https://earthwo.github.io/2016/06/12/Andfix的简单使用/","excerpt":"","text":"简介AndFix是”Android hot-fix”的简写，用于在线解决Android应用程序的bugs的Android库。AndFix支持Android2.3到Android6.0，支持ARM和X86架构。 原理实现原理是通过改变内部方法来修改bugs 修改过程 使用方法1.添加依赖库dependencies &#123;compile &apos;com.alipay.euler:andfix:0.4.0@aar&apos;&#125; 2.在应用启动时初始化patchManager = new PatchManager(context);patchManager.init(appversion);//current version 3.在启动时加载补丁patchManager.loadPatch(); 4.在开启页面下载新补丁patchManager.addPatch(path); //path是文件保存的地址 补丁制作工具AndFix提供了apkpatch工具用于制作补丁下载地址制作过程：1.先要有一个原始包和一个修改过bugs的包2.在apkpatch工具目录使用以下命令制作补丁文件apkpatch -f &lt;new&gt; -t &lt;old&gt; -o &lt;output&gt; -k &lt;keystore&gt; -p &lt;&gt; -a &lt;alias&gt; -e &lt;&gt;-a,--alias &lt;alias&gt; keystore entry alias.-e,--epassword &lt;&gt; keystore entry password.-f,--from &lt;loc&gt; new Apk file path.-k,--keystore &lt;loc&gt; keystore path.-n,--name &lt;name&gt; patch name.-o,--out &lt;dir&gt; output dir.-p,--kpassword keystore password.-t,--to &lt;loc&gt; old Apk file path. 存在的问题 在64位平台上使用会崩溃崩溃日志Fatal signal 11 (SIGSEGV), code 1, fault addr 0x8000112cbc010 in tid 31274 解决办法:强制使用armeabi平台上的引用包splits &#123;abi &#123;enable truereset()include &apos;armeabi&apos;universalApk false&#125;&#125; 同一个方法不能修改多次同一个方法修改多次会报错修改办法:在addPatch前先删除之前的patchpatchManager.removeAllPatch();patchManager.addPatch(path); demo地址AndFixDemo 项目地址AndFix","categories":[{"name":"andfix","slug":"andfix","permalink":"https://earthwo.github.io/categories/andfix/"}],"tags":[{"name":"andfix","slug":"andfix","permalink":"https://earthwo.github.io/tags/andfix/"}]}],"categories":[{"name":"Android8.0","slug":"Android8-0","permalink":"https://earthwo.github.io/categories/Android8-0/"},{"name":"nio","slug":"nio","permalink":"https://earthwo.github.io/categories/nio/"},{"name":"WebView","slug":"WebView","permalink":"https://earthwo.github.io/categories/WebView/"},{"name":"ConstraintLayout","slug":"ConstraintLayout","permalink":"https://earthwo.github.io/categories/ConstraintLayout/"},{"name":"tips和坑","slug":"tips和坑","permalink":"https://earthwo.github.io/categories/tips和坑/"},{"name":"Rxjava","slug":"Rxjava","permalink":"https://earthwo.github.io/categories/Rxjava/"},{"name":"Android进阶之光","slug":"Android进阶之光","permalink":"https://earthwo.github.io/categories/Android进阶之光/"},{"name":"读书笔记","slug":"Android进阶之光/读书笔记","permalink":"https://earthwo.github.io/categories/Android进阶之光/读书笔记/"},{"name":"源码阅读","slug":"源码阅读","permalink":"https://earthwo.github.io/categories/源码阅读/"},{"name":"okhttp","slug":"okhttp","permalink":"https://earthwo.github.io/categories/okhttp/"},{"name":"源码阅读","slug":"okhttp/源码阅读","permalink":"https://earthwo.github.io/categories/okhttp/源码阅读/"},{"name":"设计模式","slug":"设计模式","permalink":"https://earthwo.github.io/categories/设计模式/"},{"name":"Kotlin","slug":"Kotlin","permalink":"https://earthwo.github.io/categories/Kotlin/"},{"name":"kotlin","slug":"kotlin","permalink":"https://earthwo.github.io/categories/kotlin/"},{"name":"Retrofit","slug":"Retrofit","permalink":"https://earthwo.github.io/categories/Retrofit/"},{"name":"源码阅读","slug":"Retrofit/源码阅读","permalink":"https://earthwo.github.io/categories/Retrofit/源码阅读/"},{"name":"动态代理","slug":"动态代理","permalink":"https://earthwo.github.io/categories/动态代理/"},{"name":"C语言","slug":"C语言","permalink":"https://earthwo.github.io/categories/C语言/"},{"name":"自定义键盘","slug":"自定义键盘","permalink":"https://earthwo.github.io/categories/自定义键盘/"},{"name":"ndk","slug":"ndk","permalink":"https://earthwo.github.io/categories/ndk/"},{"name":"Effective Java","slug":"Effective-Java","permalink":"https://earthwo.github.io/categories/Effective-Java/"},{"name":"读书笔记","slug":"Effective-Java/读书笔记","permalink":"https://earthwo.github.io/categories/Effective-Java/读书笔记/"},{"name":"Executors","slug":"Executors","permalink":"https://earthwo.github.io/categories/Executors/"},{"name":"线程池","slug":"Executors/线程池","permalink":"https://earthwo.github.io/categories/Executors/线程池/"},{"name":"http","slug":"http","permalink":"https://earthwo.github.io/categories/http/"},{"name":"正则表达式","slug":"正则表达式","permalink":"https://earthwo.github.io/categories/正则表达式/"},{"name":"java注解","slug":"java注解","permalink":"https://earthwo.github.io/categories/java注解/"},{"name":"java反射","slug":"java反射","permalink":"https://earthwo.github.io/categories/java反射/"},{"name":"matrix","slug":"matrix","permalink":"https://earthwo.github.io/categories/matrix/"},{"name":"自定义view","slug":"自定义view","permalink":"https://earthwo.github.io/categories/自定义view/"},{"name":"matrix","slug":"自定义view/matrix","permalink":"https://earthwo.github.io/categories/自定义view/matrix/"},{"name":"gradle","slug":"gradle","permalink":"https://earthwo.github.io/categories/gradle/"},{"name":"android studio","slug":"gradle/android-studio","permalink":"https://earthwo.github.io/categories/gradle/android-studio/"},{"name":"tips","slug":"tips","permalink":"https://earthwo.github.io/categories/tips/"},{"name":"Preference","slug":"Preference","permalink":"https://earthwo.github.io/categories/Preference/"},{"name":"NDK","slug":"NDK","permalink":"https://earthwo.github.io/categories/NDK/"},{"name":"AIDL","slug":"AIDL","permalink":"https://earthwo.github.io/categories/AIDL/"},{"name":"andfix","slug":"andfix","permalink":"https://earthwo.github.io/categories/andfix/"}],"tags":[{"name":"Android8.0","slug":"Android8-0","permalink":"https://earthwo.github.io/tags/Android8-0/"},{"name":"nio","slug":"nio","permalink":"https://earthwo.github.io/tags/nio/"},{"name":"WebView","slug":"WebView","permalink":"https://earthwo.github.io/tags/WebView/"},{"name":"ConstraintLayout","slug":"ConstraintLayout","permalink":"https://earthwo.github.io/tags/ConstraintLayout/"},{"name":"tips和坑","slug":"tips和坑","permalink":"https://earthwo.github.io/tags/tips和坑/"},{"name":"Rxjava","slug":"Rxjava","permalink":"https://earthwo.github.io/tags/Rxjava/"},{"name":"读书笔记","slug":"读书笔记","permalink":"https://earthwo.github.io/tags/读书笔记/"},{"name":"Android进阶之光","slug":"Android进阶之光","permalink":"https://earthwo.github.io/tags/Android进阶之光/"},{"name":"源码阅读","slug":"源码阅读","permalink":"https://earthwo.github.io/tags/源码阅读/"},{"name":"okhttp","slug":"okhttp","permalink":"https://earthwo.github.io/tags/okhttp/"},{"name":"设计模式","slug":"设计模式","permalink":"https://earthwo.github.io/tags/设计模式/"},{"name":"Kotlin","slug":"Kotlin","permalink":"https://earthwo.github.io/tags/Kotlin/"},{"name":"kotlin","slug":"kotlin","permalink":"https://earthwo.github.io/tags/kotlin/"},{"name":"Retrofit","slug":"Retrofit","permalink":"https://earthwo.github.io/tags/Retrofit/"},{"name":"动态代理","slug":"动态代理","permalink":"https://earthwo.github.io/tags/动态代理/"},{"name":"C语言","slug":"C语言","permalink":"https://earthwo.github.io/tags/C语言/"},{"name":"自定义键盘","slug":"自定义键盘","permalink":"https://earthwo.github.io/tags/自定义键盘/"},{"name":"ndk","slug":"ndk","permalink":"https://earthwo.github.io/tags/ndk/"},{"name":"Effective Java","slug":"Effective-Java","permalink":"https://earthwo.github.io/tags/Effective-Java/"},{"name":"Executors","slug":"Executors","permalink":"https://earthwo.github.io/tags/Executors/"},{"name":"线程池","slug":"线程池","permalink":"https://earthwo.github.io/tags/线程池/"},{"name":"http","slug":"http","permalink":"https://earthwo.github.io/tags/http/"},{"name":"正则表达式","slug":"正则表达式","permalink":"https://earthwo.github.io/tags/正则表达式/"},{"name":"java注解","slug":"java注解","permalink":"https://earthwo.github.io/tags/java注解/"},{"name":"java反射","slug":"java反射","permalink":"https://earthwo.github.io/tags/java反射/"},{"name":"matrix","slug":"matrix","permalink":"https://earthwo.github.io/tags/matrix/"},{"name":"自定义view","slug":"自定义view","permalink":"https://earthwo.github.io/tags/自定义view/"},{"name":"gradle","slug":"gradle","permalink":"https://earthwo.github.io/tags/gradle/"},{"name":"android studio","slug":"android-studio","permalink":"https://earthwo.github.io/tags/android-studio/"},{"name":"tips","slug":"tips","permalink":"https://earthwo.github.io/tags/tips/"},{"name":"Preference","slug":"Preference","permalink":"https://earthwo.github.io/tags/Preference/"},{"name":"NDK","slug":"NDK","permalink":"https://earthwo.github.io/tags/NDK/"},{"name":"AIDL","slug":"AIDL","permalink":"https://earthwo.github.io/tags/AIDL/"},{"name":"andfix","slug":"andfix","permalink":"https://earthwo.github.io/tags/andfix/"}]}