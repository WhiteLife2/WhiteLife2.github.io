<!DOCTYPE html><html lang="zh-cn"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=Edge"><meta name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no"><meta name="format-detection" content="telephone=no"><meta name="format-detection" content="email=no"><meta name="description" content="study life"><meta name="keywords" content="Hexo, Gruntjs, Nodejs, Reactjs, Vuejs"><title>nio学习笔记(三) - alonealice</title><link rel="stylesheet" href="/css/main_style.min.css"><link rel="icon" href="/favicon.ico"></head><body><input id="navi" type="checkbox"><ul class="main-navication"><li><a href="/"><span>Home</span></a></li><li><a href="https://github.com/earthWo"><span>Github</span></a></li></ul><div class="wrapper" id="wrap"><div class="post-header"><label class="navi-button light" for="navi">MENU</label><img class="background" src="https://img.zcool.cn/community/014177554b6ae7000001bf729a3698.jpg@1280w_1l_0o_100sh.jpg"><div class="post-title"><h1 class="title">nio学习笔记(三)</h1><ul class="meta"><li><i class="icon icon-author"></i>alonealice</li><li><i class="icon icon-clock"></i>9 Minutes</li><li><i class="icon icon-calendar"></i>2018年2月5日</li></ul></div></div><div class="article-content" style="max-width:800px"><h3 id="FileChannel"><a href="#FileChannel" class="headerlink" title="FileChannel"></a>FileChannel</h3><p>FileChannel是一个文件的通道，可以通过它来读写文件。FileChannel无法设置为非阻塞模式。</p>
<h5 id="读数据："><a href="#读数据：" class="headerlink" title="读数据："></a>读数据：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RandomAccessFile accessFile = new RandomAccessFile(filePath, &quot;rw&quot;);</span><br><span class="line">FileChannel fileChannel = accessFile.getChannel();</span><br><span class="line">ByteBuffer buffer = ByteBuffer.allocate(48);</span><br><span class="line">int bytesRead = inChannel.read(buffer);</span><br></pre></td></tr></table></figure>
<p>读数据时，使用read方法返回读取的数据大小，如果返回-1，就说明已经到了文件的最后。</p>
<h5 id="写数据："><a href="#写数据：" class="headerlink" title="写数据："></a>写数据：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String text = &quot;...&quot;;</span><br><span class="line">ByteBuffer buf = ByteBuffer.allocate(48);</span><br><span class="line">buf.clear();</span><br><span class="line">buf.put(text.getBytes());</span><br><span class="line">buf.flip();</span><br><span class="line">while(buf.hasRemaining()) &#123;</span><br><span class="line">    fileChannel.write(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>write方法在写入数据时，每次写入的量是不定的，所以需要在循环体中把所有的数据写入文件。</p>
<p>使用完FileChannel之后，需要把通道关闭。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fileChannel.close();</span><br></pre></td></tr></table></figure>
<h5 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h5><p><code>position(long pos)</code>：该方法可以获取通道的当前位置，同时也可以设置在特定的位置进行读写操作。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">long pos = channel.position();</span><br><span class="line">channel.position(pos +10);</span><br></pre></td></tr></table></figure>
<p>这样操作会是数据之间存在空数据。</p>
<p><code>size</code>：size()方法将返回该通道里数据的大小。</p>
<p><code>truncate()</code>：该方法可以截取指定的数据长度，这样就可以达到截取文件的目的。</p>
<p><code>force()</code>：该方法将通道里尚未写入磁盘的数据强制写到磁盘上。</p>
<h3 id="SocketChannel"><a href="#SocketChannel" class="headerlink" title="SocketChannel"></a>SocketChannel</h3><p>SocketChannel是一个连接到TCP网络套接字的通道，一般会使用两个地方使用到它：使用SocketChannel连接到互联网上的某台服务器，或者使用ServerSocketChannel时，当有新的连接时，会自动创建SocketChannel。</p>
<h5 id="读写数据"><a href="#读写数据" class="headerlink" title="读写数据"></a>读写数据</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SocketChannel socketChannel = SocketChannel.open();</span><br><span class="line">socketChannel.connect(new InetSocketAddress(ip, 80));</span><br><span class="line"></span><br><span class="line">//读取数据</span><br><span class="line">ByteBuffer buf = ByteBuffer.allocate(48);</span><br><span class="line">int bytesRead = socketChannel.read(buf);</span><br><span class="line"></span><br><span class="line">//写入数据</span><br><span class="line">ByteBuffer buf = ByteBuffer.allocate(48);</span><br><span class="line">buf.clear();</span><br><span class="line">buf.put(text.getBytes());</span><br><span class="line">buf.flip();</span><br><span class="line">while(buf.hasRemaining()) &#123;</span><br><span class="line">    channel.write(buf);</span><br><span class="line">&#125;</span><br><span class="line">socketChannel.close();</span><br></pre></td></tr></table></figure>
<h5 id="非阻塞模式"><a href="#非阻塞模式" class="headerlink" title="非阻塞模式"></a>非阻塞模式</h5><p>当设置成非阻塞模式后，就可以在异步模式下调用connect()，read() 和write()了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">socketChannel.configureBlocking(false);</span><br><span class="line">socketChannel.connect(new InetSocketAddress(ip, 80));</span><br><span class="line">while(! socketChannel.finishConnect() )&#123;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">socketChannel.close();</span><br></pre></td></tr></table></figure>
<h3 id="ServerSocketChannel"><a href="#ServerSocketChannel" class="headerlink" title="ServerSocketChannel"></a>ServerSocketChannel</h3><p> ServerSocketChannel 是一个可以监听新进来的TCP连接的通道，主要用于在服务器中监听连接。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ServerSocketChannel serverSocketChannel = ServerSocketChannel.open(); //打来通道</span><br><span class="line">serverSocketChannel.socket().bind(new InetSocketAddress(90)); //绑定端口</span><br><span class="line">while(true)&#123;</span><br><span class="line">    SocketChannel socketChannel =						//获取连接</span><br><span class="line">            serverSocketChannel.accept();</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">serverSocketChannel.close();				//关闭</span><br></pre></td></tr></table></figure>
<h5 id="非阻塞模式-1"><a href="#非阻塞模式-1" class="headerlink" title="非阻塞模式"></a>非阻塞模式</h5><p>ServerSocketChannel同样可以设置为非阻塞模式。此时，accept() 方法会立刻返回，如果还没有新进来的连接,返回的将是null。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ServerSocketChannel serverSocketChannel = ServerSocketChannel.open(); //打来通道</span><br><span class="line">serverSocketChannel.socket().bind(new InetSocketAddress(90)); //绑定端口</span><br><span class="line">while(true)&#123;</span><br><span class="line">    SocketChannel socketChannel =						//获取连接</span><br><span class="line">            serverSocketChannel.accept();</span><br><span class="line">           if(socketChannel!=null)&#123;</span><br><span class="line">              ...   </span><br><span class="line">           &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">serverSocketChannel.close();				//关闭</span><br></pre></td></tr></table></figure>
<h3 id="DatagramChannel"><a href="#DatagramChannel" class="headerlink" title="DatagramChannel"></a>DatagramChannel</h3><p>DatagramChannel是收发UDP包的通道，因此它发送和结束的是数据包。</p>
<p>接收发送数据：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DatagramChannel channel = DatagramChannel.open();  //打开</span><br><span class="line">channel.socket().bind(new InetSocketAddress(100)); //绑定接口</span><br><span class="line"></span><br><span class="line">//接收数据</span><br><span class="line">ByteBuffer buf = ByteBuffer.allocate(48);</span><br><span class="line">buf.clear();</span><br><span class="line">channel.receive(buf); </span><br><span class="line"></span><br><span class="line">//发送数据</span><br><span class="line">ByteBuffer buf = ByteBuffer.allocate(48);</span><br><span class="line">buf.clear();</span><br><span class="line">buf.put(text.getBytes());</span><br><span class="line">buf.flip();</span><br><span class="line">int bytesSent = channel.send(buf, new InetSocketAddress(ip, 100));</span><br></pre></td></tr></table></figure>
<h3 id="Pipe"><a href="#Pipe" class="headerlink" title="Pipe"></a>Pipe</h3><p>管道是2个线程之间的单向数据连接。Pipe有一个source通道和一个sink通道。数据会被写到sink通道，从source通道读取。</p>
<p>读写数据：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Pipe pipe = Pipe.open(); //打开通道</span><br><span class="line">Pipe.SinkChannel sinkChannel = pipe.sink();</span><br><span class="line">String newData = &quot;...&quot;;</span><br><span class="line">ByteBuffer buf = ByteBuffer.allocate(48);</span><br><span class="line">buf.clear();</span><br><span class="line">buf.put(newData.getBytes());</span><br><span class="line"></span><br><span class="line">buf.flip();</span><br><span class="line"></span><br><span class="line">//写入数据</span><br><span class="line">while(buf.hasRemaining()) &#123;</span><br><span class="line">    sinkChannel.write(buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//读取数据</span><br><span class="line">Pipe.SourceChannel sourceChannel = pipe.source();</span><br><span class="line">ByteBuffer buf = ByteBuffer.allocate(48);</span><br><span class="line">int bytesRead = sourceChannel.read(buf);</span><br></pre></td></tr></table></figure></div><div class="article-meta" style="max-width:800px"><div class="tags"><i class="icon icon-tag"></i><ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/nio/">nio</a><span class="tag-list-count">3</span></li></ul></div><div class="categories"><i class="icon icon-category"></i><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/nio/">nio</a><span class="category-list-count">3</span></li></ul></div></div><div class="article-comment" style="max-width:800px"><div class="ds-thread" id="ds-thread" data-thread-key="ck85r7lst002hfxo1dw5ywro6" data-title="nio学习笔记(三)" data-url="https://earthwo.github.io/2018/02/05/nio学习笔记-三/" site-name="ueibo"></div><script>var siteName = document.getElementById('ds-thread').getAttribute('site-name');
var duoshuoQuery = {short_name: siteName};
(function() {
  var ds = document.createElement('script');
  ds.type = 'text/javascript';ds.async = true;
  ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
  ds.charset = 'UTF-8';
  (document.getElementsByTagName('head')[0] 
  || document.getElementsByTagName('body')[0]).appendChild(ds);
})();</script></div><ul class="navication"><li class="home"><a href="/"><i class="icon icon-home"></i></a></li><li><a href="/2018/06/29/Android8-0通知栏/"><i class="icon icon-arror-left"></i></a></li><li><a href="/2018/02/02/nio学习笔记-二/"><i class="icon icon-arror-right"></i></a></li></ul><div class="page-footer"><div class="top"><ul class="social"><li><a href="https://github.com/earthWo" title="Github" target="_blank"><i class="icon icon-github"></i></a></li></ul></div><div class="bottom"><p class="copyright">© 2020 alonealice<br><small><a href="http://www.beian.miit.gov.cn" target="_blank">浙ICP备17033688号</a></small><small>, THEME BY <a href="https://github.com/BoizZ/hexo-theme-laughing" target="_blank">LAUGHING</a></small></p></div></div></div><script>var wrap = document.getElementById('wrap');
window.onload = function () {
  wrap.className += ' done';
}</script></body></html>