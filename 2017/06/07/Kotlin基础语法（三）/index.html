<!DOCTYPE html><html lang="zh-cn"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=Edge"><meta name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no"><meta name="format-detection" content="telephone=no"><meta name="format-detection" content="email=no"><meta name="description" content="study life"><meta name="keywords" content="Hexo, Gruntjs, Nodejs, Reactjs, Vuejs"><title>Kotlin基础语法(三) - alonealice</title><link rel="stylesheet" href="/css/main_style.min.css"><link rel="icon" href="/favicon.ico"></head><body><input id="navi" type="checkbox"><ul class="main-navication"><li><a href="/"><span>Home</span></a></li><li><a href="https://github.com/earthWo"><span>Github</span></a></li></ul><div class="wrapper" id="wrap"><div class="post-header"><label class="navi-button light" for="navi">MENU</label><img class="background" src="https://img.zcool.cn/community/014177554b6ae7000001bf729a3698.jpg@1280w_1l_0o_100sh.jpg"><div class="post-title"><h1 class="title">Kotlin基础语法(三)</h1><ul class="meta"><li><i class="icon icon-author"></i>alonealice</li><li><i class="icon icon-clock"></i>17 Minutes</li><li><i class="icon icon-calendar"></i>2017年6月7日</li></ul></div></div><div class="article-content" style="max-width:800px"><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>在 Kotlin 中所有类都有一个共同的超类<code>Any</code>，这对于没有超类型声明的类是默认超类，Any与java中的Object不同，它只有<code>equals()</code>、<code>hashCode()</code>和<code>toString()</code>三个方法。<br>要声明一个显式的超类型，我们把类型放到类头的冒号之后：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">open class Base(p: Int)</span><br><span class="line"></span><br><span class="line">class Derived(p: Int) : Base(p)</span><br></pre></td></tr></table></figure></p>
<p>基类在声明时必须要有open修饰，表示该类可以被继承。同时如果类有主构造函数，那么其基类必须用主构造函数参数实例化，如果没有主构造函数，那么每个次构造函数必须用super关键字实例化基类。如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class MyView : View &#123;</span><br><span class="line">    constructor(ctx: Context) : super(ctx)</span><br><span class="line"></span><br><span class="line">    constructor(ctx: Context, attrs: AttributeSet) : super(ctx, attrs)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="覆盖方法和属性"><a href="#覆盖方法和属性" class="headerlink" title="覆盖方法和属性"></a>覆盖方法和属性</h4><p>Kotlin 需要显式 标注可覆盖的成员（我们称之为开放）和覆盖后的成员：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">open class Base &#123;</span><br><span class="line">    open val x: Int =3</span><br><span class="line">    open fun v() &#123;&#125;</span><br><span class="line">    fun nv() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Derived() : Base() &#123;</span><br><span class="line">    override val x: Int=7</span><br><span class="line">    override fun v() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>基类可以覆盖的方法属性必须有<code>open</code>，子类覆盖的方法属性必须有<code>override</code>。同时你也可以用一个<code>var</code>属性覆盖一个<code>val</code>属性，但反之则不行。这是允许的，因为一个<code>val</code>属性本质上声明了一个<code>getter</code>方法，而将其覆盖为<code>var</code>只是在子类中额外声明一个<code>setter</code>方法。</p>
<h4 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h4><p>类和其中的某些成员可以声明为<code>abstract</code>。抽象成员在本类中可以不用实现。需要注意的是，我们并不需要用<code>open</code>标注一个抽象类或者函数，因为抽象类本来就是让人继承的。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">open class Base &#123;</span><br><span class="line">    open fun f() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">abstract class Derived : Base() &#123;</span><br><span class="line">    override abstract fun f()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><p>Kotlin的接口与Java 8类似，既包含抽象方法的声明，也可以包含实现。与抽象类不同的是，接口无法保存状态。它可以有属性但必须声明为抽象或提供访问器实现。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">interface MyInterface &#123;</span><br><span class="line">    fun bar()</span><br><span class="line">    fun foo() &#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>实现接口：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Child : MyInterface &#123;</span><br><span class="line">    override fun bar() &#123;</span><br><span class="line">        // 方法体</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>与抽象类一样，接口中无需<code>open</code>修饰，因为本来就是让其他类去实现的。<br>接口中属性的使用：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">interface MyInterface &#123;</span><br><span class="line">    val prop: Int // 抽象的</span><br><span class="line"></span><br><span class="line">    val propertyWithImplementation: String</span><br><span class="line">        get() = &quot;foo&quot;</span><br><span class="line"></span><br><span class="line">    fun foo() &#123;</span><br><span class="line">        print(prop)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Child : MyInterface &#123;</span><br><span class="line">    override val prop: Int = 29</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="可见性修饰符"><a href="#可见性修饰符" class="headerlink" title="可见性修饰符"></a>可见性修饰符</h3><p>在 Kotlin 中有这四个可见性修饰符：<code>private</code>、<code>protected</code>、<code>internal</code>和<code>public</code>。如果没有显式指定修饰符的话，默认可见性是<code>public</code>。<br><code>private</code>、<code>protected</code>和<code>public</code>的作用于在java中基本一样，<code>internal</code>表示它会在相同模块内随处可见。那什么是相同的模块呢？<br>具体地说， 一个模块是编译在一起的一套 Kotlin 文件，比如一个 IntelliJ IDEA 模块；一个 Maven 或者 Gradle 项目或一次 ＜kotlinc＞ Ant 任务执行所编译的一套文件。</p>
<h4 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h4><p>在Kotlin中能够扩展一个类的新功能而无需继承该类或使用像装饰者这样的任何类型的设计模式，就叫做<code>扩展</code>。<code>Kotlin</code>支持<code>扩展函数</code>和<code>扩展属性</code>。<br>声明一个扩展函数，我们需要用一个 接收者类型 也就是被扩展的类型来作为他的前缀，如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Expr</span><br><span class="line">fun Expr.r()&#123;</span><br><span class="line">    Log.d(&quot;&quot;,&quot;&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里就扩展了<code>Expr</code>类。<br>扩展函数是静态分发的，即他们不是根据接收者类型的虚方法。 这意味着调用的扩展函数是由函数调用所在的表达式的类型来决定的， 而不是由表达式运行时求值结果决定的。例如:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">open class C</span><br><span class="line"></span><br><span class="line">class D: C()</span><br><span class="line"></span><br><span class="line">fun C.foo() = &quot;c&quot;</span><br><span class="line"></span><br><span class="line">fun D.foo() = &quot;d&quot;</span><br><span class="line"></span><br><span class="line">fun printFoo(c: C) &#123;</span><br><span class="line">    println(c.foo())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">printFoo(D())</span><br></pre></td></tr></table></figure></p>
<p>这个例子会输出 “c”，因为调用的扩展函数只取决于参数 c 的声明类型，该类型是 C 类。<br>同时，当扩展函数和成员函数相同时，调用会调用成员函数，除非两者出现重载。<br>和函数类似，Kotlin 支持扩展属性：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">val &lt;T&gt; List&lt;T&gt;.lastIndex: Int</span><br><span class="line">    get() = size - 1</span><br></pre></td></tr></table></figure></p>
<p>扩展属性不能有初始化器。他们的行为只能由显式提供的 getters/setters 定义。<br>如果一个类定义有一个伴生对象 ，你也可以为伴生对象定义扩展函数和属性：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class MyClass &#123;</span><br><span class="line">    companion object &#123; &#125;  // 将被称为 &quot;Companion&quot;</span><br><span class="line">&#125;</span><br><span class="line">fun MyClass.Companion.foo() &#123;</span><br><span class="line">    // ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>调用时：<code>MyClass.foo()</code><br>在一个类内部你可以为另一个类声明扩展。在这样的扩展内部，有多个<code>隐式接收者</code>—— 其中的对象成员可以无需通过限定符访问。扩展声明所在的类的实例称为<code>分发接收者</code>（声明拓展的部分），扩展方法调用所在的接收者类型的实例称为<code>扩展接收者</code>(拓展部分)。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class D &#123;</span><br><span class="line">    fun bar() &#123; …… &#125;//扩展接收者</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class C &#123;//分发接收者</span><br><span class="line">    fun baz() &#123; …… &#125;</span><br><span class="line"></span><br><span class="line">    fun D.foo() &#123;</span><br><span class="line">        bar()   // 调用 D.bar</span><br><span class="line">        baz()   // 调用 C.baz</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fun caller(d: D) &#123;</span><br><span class="line">        d.foo()   // 调用扩展函数</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对于分发接收者和扩展接收者的成员名字冲突的情况，扩展接收者优先。</p>
<h4 id="解构声明"><a href="#解构声明" class="headerlink" title="解构声明"></a>解构声明</h4><p>Kotlin可以把一个变量解构成多个变量，如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var a=A()</span><br><span class="line">var(x,userName) = a//x和userName可以随意命名</span><br><span class="line">Log.d(&quot;显示&quot;,&quot;&quot;+x)</span><br></pre></td></tr></table></figure></p>
<p>一个解构声明会被编译成以下代码：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">val x = person.component1()</span><br><span class="line">val userName = person.component2()</span><br></pre></td></tr></table></figure></p>
<p>所以在A中需要添加如下代码:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">operator fun  component1(): Any? &#123;</span><br><span class="line">      return userName</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  operator fun  component2(): Any? &#123;</span><br><span class="line">      return userName</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>请注意，componentN() 函数需要用 operator 关键字标记，以允许在解构声明中使用它们，同时数据类自动声明 componentN() 函数。</p>
<h4 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h4><p>Kotlin 区分可变集合和不可变集合（lists、sets、maps 等）。<br>Kotlin 的<code>List&lt;out T&gt;</code>类型是一个提供只读操作如<code>size</code>、<code>get</code>等的接口，要想编辑需要使用<code>MutableList&lt;T&gt;</code>。同样的这也适用于<code>Set&lt;out T&gt;</code>/<code>MutableSet&lt;T&gt;</code>及<code>Map&lt;K, out V&gt;</code>/<code>MutableMap&lt;K, V&gt;</code>。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">val numbers: MutableList&lt;Int&gt; = mutableListOf(1, 2, 3)</span><br><span class="line">val readOnlyView: List&lt;Int&gt; = numbers</span><br><span class="line">println(numbers)        // 输出 &quot;[1, 2, 3]&quot;</span><br><span class="line">numbers.add(4)</span><br><span class="line">println(readOnlyView)   // 输出 &quot;[1, 2, 3, 4]&quot;</span><br><span class="line">readOnlyView.clear()    //不存在这个方法</span><br></pre></td></tr></table></figure></p>
<p>Kotlin 没有专门的语法结构创建 list 或 set。 要用标准库的方法，如 listOf()、 mutableListOf()、 setOf()、 mutableSetOf()。 在非性能关键代码中创建 map 可以用一个简单的惯用法来完成：mapOf(a to b, c to d)。</p>
<h4 id="区间"><a href="#区间" class="headerlink" title="区间"></a>区间</h4><p>区间表达式由具有操作符形式 .. 的<code>rangeTo</code>函数辅以 in 和 !in 形成。<br>如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (i in 1..10) &#123; // 等同于 1 &lt;= i &amp;&amp; i &lt;= 10</span><br><span class="line">    println(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里需要注意的是<code>1..10</code>是不能倒过来的，即如果写成<code>10..1</code>，那么就表明是 10 &lt;= i &amp;&amp; i &lt;= 1，这样程序是不会执行的。<br>所以如果要使用倒序，则需要使用<code>downTo</code>函数：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for (i in 10 downTo 1) print(i)</span><br></pre></td></tr></table></figure></p>
<p>除此以外，还有几个函数也非常有用：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for (i in 1..10 step 2) print(i)//输出 13579</span><br></pre></td></tr></table></figure></p>
<p><code>step</code>函数表示执行的步长度。<code>step 2</code>说明每部执行2个数（即执行一步，跳一步）。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for (i in 1 until 10) &#123;   // i in [1, 10) 排除了 10</span><br><span class="line">     println(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>until</code>函数表示不包含某数。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for (i in (1..10).reversed())&#123;//10,9,8,7,6,5,4,3,2,1</span><br><span class="line">           println(i)</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></p>
<p><code>reversed</code>能返回函数返回数据反转后的数列。</p>
<h4 id="类型的检查与转换"><a href="#类型的检查与转换" class="headerlink" title="类型的检查与转换"></a>类型的检查与转换</h4><p>我们可以使用<code>is</code>操作符或其否定形式<code>!is</code>来检查对象是否是给定类型。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (obj is String) &#123;</span><br><span class="line">    print(obj.length)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在多数情况下，不需要使用显式转换操作符，因为编译器会跟踪<code>is</code>和<code>!is</code>检查，并在需要时自动插入转换：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fun demo(x: Any) &#123;</span><br><span class="line">    if (x is String) &#123;</span><br><span class="line">        print(x.length) // x 自动转换为字符串</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> if (x !is String) return</span><br><span class="line">    print(x.length) // x 自动转换为字符串</span><br></pre></td></tr></table></figure></p>
<p>这中智能转换也一样适用于when表达式。<br>当变量不能保证检查和使用时不可变时，不会进行智能转换，所以智能转换的使用范围:<br>val 局部变量——总是可以；<br>val 属性——如果属性是 private 或 internal，或者该检查在声明属性的同一模块中执行。智能转换不适用于 open 的属性或者具有自定义 getter 的属性；<br>var 局部变量——如果变量在检查和使用之间没有修改、并且没有在会修改它的 lambda 中捕获；<br>var 属性——决不可能（因为该变量可以随时被其他代码修改）。<br>Kotlin中的可以使用操作符<code>as</code>对类型进行强制转换：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">val x: String = y as String</span><br></pre></td></tr></table></figure></p>
<p> 当y为null时，上述代码会报错，所以我们必须在在转换左右都有可空类型：<br> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">val x: String? = y as String?</span><br></pre></td></tr></table></figure></p>
<h4 id="this作用域"><a href="#this作用域" class="headerlink" title="this作用域"></a>this作用域</h4><p>要访问来自外部作用域的this，我们使用this@label，其中 @label 是一个代指 this 来源的标签：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class A &#123; // 隐式标签 @A</span><br><span class="line">    inner class B &#123; // 隐式标签 @B</span><br><span class="line">        fun Int.foo() &#123; // 隐式标签 @foo</span><br><span class="line">            val a = this@A // A 的 this</span><br><span class="line">            val b = this@B // B 的 this</span><br><span class="line"></span><br><span class="line">            val c = this // foo() 的接收者，一个 Int</span><br><span class="line">            val c1 = this@foo // foo() 的接收者，一个 Int</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="空安全"><a href="#空安全" class="headerlink" title="空安全"></a>空安全</h4><p>在<code>Kotlin</code>中，类型系统会区分一个引用是否可以容纳<code>null</code>:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var a: String = &quot;abc&quot;</span><br><span class="line">a = null // 编译错误</span><br></pre></td></tr></table></figure></p>
<p>当类型允许为空，但依旧被调用时：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var b: String? = &quot;abc&quot;</span><br><span class="line">val l = b.length//编译错误</span><br></pre></td></tr></table></figure></p>
<p>这种情况时会编译错误，这时，我们可以对它进行空判断：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var b: String? = &quot;abc&quot;</span><br><span class="line">if(b!=null)&#123;</span><br><span class="line"> val l = b.length</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>除此以外，我们还可以使用安全调用符，<code>?.</code><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">val l = b?.length</span><br></pre></td></tr></table></figure></p>
<p>它表示当b为null时，返回null，不为null时，返回b.length。<br>除此之外，我们还可以使用<code>Elvis</code>操作符，写作<code>?:</code>：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">val l = b?.length ?: -1</span><br></pre></td></tr></table></figure></p>
<p>它表示当左边的表达式非空时执行左边的表达式，为空时执行右边的表达式。<br>第三中方式是使用!! 操作符：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">val l = b!!.length</span><br></pre></td></tr></table></figure></p>
<p>当b为空时，程序会抛出<code>NPE</code>异常。</p>
</div><div class="article-meta" style="max-width:800px"><div class="tags"><i class="icon icon-tag"></i><ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Kotlin/">Kotlin</a><span class="tag-list-count">2</span></li></ul></div><div class="categories"><i class="icon icon-category"></i><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Kotlin/">Kotlin</a><span class="category-list-count">2</span></li></ul></div></div><div class="article-comment" style="max-width:800px"><div class="ds-thread" id="ds-thread" data-thread-key="ck85r7lun0079fxo17pvarabu" data-title="Kotlin基础语法(三)" data-url="https://earthwo.github.io/2017/06/07/Kotlin基础语法（三）/" site-name="ueibo"></div><script>var siteName = document.getElementById('ds-thread').getAttribute('site-name');
var duoshuoQuery = {short_name: siteName};
(function() {
  var ds = document.createElement('script');
  ds.type = 'text/javascript';ds.async = true;
  ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
  ds.charset = 'UTF-8';
  (document.getElementsByTagName('head')[0] 
  || document.getElementsByTagName('body')[0]).appendChild(ds);
})();</script></div><ul class="navication"><li class="home"><a href="/"><i class="icon icon-home"></i></a></li><li><a href="/2017/06/21/责任链模式/"><i class="icon icon-arror-left"></i></a></li><li><a href="/2017/06/06/Kotlin基础语法（二）/"><i class="icon icon-arror-right"></i></a></li></ul><div class="page-footer"><div class="top"><ul class="social"><li><a href="https://github.com/earthWo" title="Github" target="_blank"><i class="icon icon-github"></i></a></li></ul></div><div class="bottom"><p class="copyright">© 2020 alonealice<br><small><a href="http://www.beian.miit.gov.cn" target="_blank">浙ICP备17033688号</a></small><small>, THEME BY <a href="https://github.com/BoizZ/hexo-theme-laughing" target="_blank">LAUGHING</a></small></p></div></div></div><script>var wrap = document.getElementById('wrap');
window.onload = function () {
  wrap.className += ' done';
}</script></body></html>