<!DOCTYPE html><html lang="zh-cn"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=Edge"><meta name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no"><meta name="format-detection" content="telephone=no"><meta name="format-detection" content="email=no"><meta name="description" content="study life"><meta name="keywords" content="Hexo, Gruntjs, Nodejs, Reactjs, Vuejs"><title>Kotlin基础语法（二） - alonealice</title><link rel="stylesheet" href="/css/main_style.min.css"><link rel="icon" href="/favicon.ico"></head><body><input id="navi" type="checkbox"><ul class="main-navication"><li><a href="/"><span>Home</span></a></li><li><a href="https://github.com/earthWo"><span>Github</span></a></li></ul><div class="wrapper" id="wrap"><div class="post-header"><label class="navi-button light" for="navi">MENU</label><img class="background" src="https://img.zcool.cn/community/014177554b6ae7000001bf729a3698.jpg@1280w_1l_0o_100sh.jpg"><div class="post-title"><h1 class="title">Kotlin基础语法（二）</h1><ul class="meta"><li><i class="icon icon-author"></i>alonealice</li><li><i class="icon icon-clock"></i>11 Minutes</li><li><i class="icon icon-calendar"></i>2017年6月6日</li></ul></div></div><div class="article-content" style="max-width:800px"><h3 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h3><h4 id="类"><a href="#类" class="headerlink" title="类"></a>类</h4><p>在Kotlin中，类依旧使用class定义，用大括号包裹，不过当类里面没有任何代码时，大括号可以省略。</p>
<h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><p>Kotlin中可以有一个主构造函数和多个二级构造函数，如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class A  constructor(name: String)&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中的<code>constructor</code>关键字可以省略。但是如果构造函数有其他声明获取注解，如：<code>private</code>，那么<code>constructor</code>就不能省略。<br>在主构造函数中不能有任何代码，所以初始化代码需要写在<code>init</code>代码块中，或者在参数声明时定义:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class A  (name: String)&#123;</span><br><span class="line">    init &#123;</span><br><span class="line">        print(name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class A  (name: String)&#123;</span><br><span class="line">   var userName=name</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>属性声明可以主构造函数中直接声明：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class A  (var userName: String)&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>二级构造函数声明在类体内，但是必须有<code>constructor</code>关键字，如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">    constructor(name: String)&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果类已经有了一级构造函数，那么二级构造函数在声明时必须代理主构造函数，并且使用关键字<code>this</code>：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class A (var name: String)&#123;</span><br><span class="line"></span><br><span class="line">    constructor(name: String,age: Int) : this(name)&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>两个构造函数在使用时没有区别，所以在声明时参数数量或类型需要不同。<br>在创建类的实例时，不需要关键字new，可以直接创建。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">val a=A(&quot;tim&quot;)</span><br></pre></td></tr></table></figure></p>
<h4 id="属性和字段"><a href="#属性和字段" class="headerlink" title="属性和字段"></a>属性和字段</h4><p>类中的属性用var声明时可变的，用val声明是只读的。使用属性时只要直接用名称使用它即可，如：<code>a.userName</code>。<br>声明属性的示例：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var userName: String?=null</span><br><span class="line">var age=1</span><br></pre></td></tr></table></figure></p>
<p>在确定了属性的类型后，必须要指定其默认值。</p>
<h4 id="get和set方法"><a href="#get和set方法" class="headerlink" title="get和set方法"></a>get和set方法</h4><p>除了在声明属性时指定默认值以外，还可以在get方法中设置值。Kotlin中get和set方法都是默认的，但是我们也可以自定义get和set方法。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var userName: String?</span><br><span class="line">   get() = &quot;tom&quot;</span><br></pre></td></tr></table></figure></p>
<p>这里<code>userName</code>开始没有默认值，但是在get方法中设置了值。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var userName: String?=null</span><br><span class="line">   set(value) &#123;</span><br><span class="line">   userName=value+&quot;.&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里<code>userName</code>传入的值后面添加一个<code>.</code><br>如果你需要改变一个访问器的可见性或者对其注解，但是不需要改变默认的实现， 你可以定义访问器而不定义其实现:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var userName: String?=null</span><br><span class="line">    private set(value) &#123;&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="数据类"><a href="#数据类" class="headerlink" title="数据类"></a>数据类</h4><p>我们经常创建一些只保存数据的类。在这些类中，一些标准函数往往是从 数据机械推导而来的。在 Kotlin 中，这叫做<code>数据类</code>并标记为<code>data</code>：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">data class User(val name: String, val age: Int)</span><br></pre></td></tr></table></figure></p>
<p>编译器自动从主构造函数中声明的所有属性导出以下成员：equals()/hashCode() 对，toString() 格式是 “User(name=John, age=42)”，componentN() 函数 按声明顺序对应于所有属性，copy()函数。<br>对于上面的数据类，程序会自动生成<code>copy</code>函数:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fun copy(name: String = this.name, age: Int = this.age) = User(name, age)</span><br></pre></td></tr></table></figure></p>
<p><code>copy</code>方法使用如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">val jack = User(name = &quot;Jack&quot;, age = 1)</span><br><span class="line">val olderJack = jack.copy(age = 2)</span><br></pre></td></tr></table></figure></p>
<h4 id="密封类"><a href="#密封类" class="headerlink" title="密封类"></a>密封类</h4><p>密封类用来表示受限的类继承结构：当一个值为有限集中的类型、而不能有任何其他类型时(所有的子类都必须在密封类的内部，继承子类的类可以在其他文件)。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sealed class Expr</span><br><span class="line">data class Const(val number: Double) : Expr()</span><br><span class="line">data class Sum(val e1: Expr, val e2: Expr) : Expr()</span><br><span class="line">object NotANumber : Expr()</span><br></pre></td></tr></table></figure></p>
<p>使用密封类的关键好处在于使用 when 表达式 的时候，如果能够验证语句覆盖了所有情况，就不需要为该语句再添加一个 else 子句了。</p>
<h4 id="嵌套类"><a href="#嵌套类" class="headerlink" title="嵌套类"></a>嵌套类</h4><p>类可以嵌套在其他类中<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Outer &#123;</span><br><span class="line">    private val bar: Int = 1</span><br><span class="line">    class Nested &#123;</span><br><span class="line">        fun foo() = 2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h5><p>类可以标记为<code>inner</code>以便能够访问外部类的成员，这个类就是内部类。内部类会带有一个对外部类的对象的引用：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Outer &#123;</span><br><span class="line">    private val bar: Int = 1</span><br><span class="line">    class Nested &#123;</span><br><span class="line">        fun foo() = bar</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h5><p>对象表达式创建匿名内部类：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">window.addMouseListener(object: MouseAdapter() &#123;</span><br><span class="line">    override fun mouseClicked(e: MouseEvent) &#123;</span><br><span class="line">    &#125;                                                                                                       </span><br><span class="line">    override fun mouseEntered(e: MouseEvent) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><p>Kotlin 中的函数使用 fun 关键字声明<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fun setName(name: String) : Int&#123;</span><br><span class="line">      return 1</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>后面的<code>: Int</code>表示返回值为Int,如果不返回任何值，则使用<code>Unit</code>，如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fun setName(name: String) : Unit&#123;</span><br><span class="line">       this.userName=name</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>函数在声明时可以直接设置默认参数，如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fun setName(name: String=&quot;tim&quot;) : Unit&#123;</span><br><span class="line">       this.userName=name</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>覆盖方法总是使用与基类型方法相同的默认参数值。 当覆盖一个带有默认参数值的方法时，必须从签名中省略默认参数值。<br>可以在调用函数时使用命名的函数参数。当一个函数有大量的参数或默认参数时这会非常方便。如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fun setName(name: String=&quot;tim&quot;,a: Boolean=false,b: Boolean=false,c: String) : Unit&#123;</span><br><span class="line">       this.userName=name</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>使用命名参数，增加可读性,同时也可以省略部分参数，如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a.setName(&quot;ddd&quot;,c=&quot;d&quot;)</span><br></pre></td></tr></table></figure></p>
<p>当函数返回单个表达式时，可以省略花括号并且在 = 符号之后指定代码体即可，如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fun double(x: Int): Int = x * 2</span><br></pre></td></tr></table></figure></p>
<p>函数的参数还可以使用<code>Varargs</code>来表示可变数量的参数，如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fun &lt;T&gt; asList(vararg ts: T): List&lt;T&gt; &#123;</span><br><span class="line">    val result = ArrayList&lt;T&gt;()</span><br><span class="line">    for (t in ts) // ts is an Array</span><br><span class="line">        result.add(t)</span><br><span class="line">    return result</span><br><span class="line">&#125;</span><br><span class="line">val list = asList(1, 2, 3)</span><br></pre></td></tr></table></figure></p>
<p>在 Kotlin 中函数可以在文件顶层声明，所有你不需要用类来保存一个函数。此外 除了顶层函数，Kotlin 中函数也可以声明在局部作用域、作为成员函数以及扩展函数。而顶层函数在调用时不需要实例就可以直接调用。<br>Kotlin 支持局部函数，即一个函数在另一个函数内部。如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fun dfs(graph: Graph) &#123;</span><br><span class="line">    fun dfs(current: Vertex, visited: Set&lt;Vertex&gt;) &#123;</span><br><span class="line">        if (!visited.add(current)) return</span><br><span class="line">        for (v in current.neighbors)</span><br><span class="line">            dfs(v, visited)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dfs(graph.vertices[0], HashSet())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><a href="https://www.kotlincn.net/docs/reference/" target="_blank" rel="noopener">参考资料</a></p>
</div><div class="article-meta" style="max-width:800px"><div class="tags"><i class="icon icon-tag"></i><ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Kotlin/">Kotlin</a><span class="tag-list-count">2</span></li></ul></div><div class="categories"><i class="icon icon-category"></i><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Kotlin/">Kotlin</a><span class="category-list-count">2</span></li></ul></div></div><div class="article-comment" style="max-width:800px"><div class="ds-thread" id="ds-thread" data-thread-key="ck85r7ls00012fxo1txd9kf0j" data-title="Kotlin基础语法（二）" data-url="https://earthwo.github.io/2017/06/06/Kotlin基础语法（二）/" site-name="ueibo"></div><script>var siteName = document.getElementById('ds-thread').getAttribute('site-name');
var duoshuoQuery = {short_name: siteName};
(function() {
  var ds = document.createElement('script');
  ds.type = 'text/javascript';ds.async = true;
  ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
  ds.charset = 'UTF-8';
  (document.getElementsByTagName('head')[0] 
  || document.getElementsByTagName('body')[0]).appendChild(ds);
})();</script></div><ul class="navication"><li class="home"><a href="/"><i class="icon icon-home"></i></a></li><li><a href="/2017/06/07/Kotlin基础语法（三）/"><i class="icon icon-arror-left"></i></a></li><li><a href="/2017/05/31/kotlin基础语法（一）/"><i class="icon icon-arror-right"></i></a></li></ul><div class="page-footer"><div class="top"><ul class="social"><li><a href="https://github.com/earthWo" title="Github" target="_blank"><i class="icon icon-github"></i></a></li></ul></div><div class="bottom"><p class="copyright">© 2020 alonealice<br><small><a href="http://www.beian.miit.gov.cn" target="_blank">浙ICP备17033688号</a></small><small>, THEME BY <a href="https://github.com/BoizZ/hexo-theme-laughing" target="_blank">LAUGHING</a></small></p></div></div></div><script>var wrap = document.getElementById('wrap');
window.onload = function () {
  wrap.className += ' done';
}</script></body></html>