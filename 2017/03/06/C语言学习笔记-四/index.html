<!DOCTYPE html><html lang="zh-cn"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=Edge"><meta name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no"><meta name="format-detection" content="telephone=no"><meta name="format-detection" content="email=no"><meta name="description" content="study life"><meta name="keywords" content="Hexo, Gruntjs, Nodejs, Reactjs, Vuejs"><title>C语言学习笔记(四) - alonealice</title><link rel="stylesheet" href="/css/main_style.min.css"><link rel="icon" href="/favicon.ico"></head><body><input id="navi" type="checkbox"><ul class="main-navication"><li><a href="/"><span>Home</span></a></li><li><a href="https://github.com/earthWo"><span>Github</span></a></li></ul><div class="wrapper" id="wrap"><div class="post-header"><label class="navi-button light" for="navi">MENU</label><img class="background" src="https://img.zcool.cn/community/014177554b6ae7000001bf729a3698.jpg@1280w_1l_0o_100sh.jpg"><div class="post-title"><h1 class="title">C语言学习笔记(四)</h1><ul class="meta"><li><i class="icon icon-author"></i>alonealice</li><li><i class="icon icon-clock"></i>6 Minutes</li><li><i class="icon icon-calendar"></i>2017年3月6日</li></ul></div></div><div class="article-content" style="max-width:800px"><h3 id="文件和内存管理"><a href="#文件和内存管理" class="headerlink" title="文件和内存管理"></a>文件和内存管理</h3><ol>
<li><p>文件类型为FILE，typedef定义数据类型，使用时一般使用文件指针：FILE *pFile</p>
</li>
<li><p>文件打开：FILE *pFile;pFile=fopen(“文件名”,使用方式);使用方式有以下：r（只读文本文件），w（只写文本文件），a（追加文本文件，在末尾加内容），rb（只读二进制文件），wb（只写二进制文件），ab（追加二进制文件），r+（打开文件文本，可读可写），w+（打开或新建文本文件，可读可写），a+（打开文件文本，可读可在末尾写），rb+，wb+，ab+</p>
</li>
<li><p>文件关闭fclose(文件指针)，关闭成功返回0，失败EOF</p>
</li>
<li><p>fputc(字符，文件指针)，将字符写入文件；fgetc(文件指针)将文件内容读取一个一个读取；fputs(字符串，文件指针)，将字符写入文件；fgets(数组，长度n，文件指针)将文件内容n读取出来存到数组</p>
</li>
<li><p>fprintf(文件指针，格式字符串，输出列表)：fprintf(fp,”%d”,i)将i以规定格式写到文件；fscanf(文件指针，格式，输入列表)读入文件中的中值以该格式写到i</p>
</li>
<li><p>fread(buffer,size,count,fp)意思是冲fp的文件中读取count次，每次读size字节，写到buffer的地址中；fwrite(buffer,size,count,fp)将buffer的size字节的数据写到fp文件中，写入count次</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">文件读取，写入例子</span><br><span class="line">FILE* file=fopen(&quot;a.txt&quot;,&quot;w+&quot;);</span><br><span class="line">if(file==NULL)&#123;</span><br><span class="line">  puts(&quot;无法打开文件&quot;);</span><br><span class="line">&#125;</span><br><span class="line">fputs(&quot;1234567890&quot;,file);</span><br><span class="line">fclose(file);</span><br><span class="line"></span><br><span class="line">a文件的内容结果（会将原来的内容清掉）：</span><br><span class="line">1234567890</span><br><span class="line"></span><br><span class="line">FILE* file=fopen(&quot;a.txt&quot;,&quot;r+&quot;);</span><br><span class="line">char r[30];</span><br><span class="line">fgets(r, sizeof(r),file);</span><br><span class="line">printf(&quot;输出%s&quot;,r);</span><br><span class="line">fclose(file);</span><br><span class="line"></span><br><span class="line">结果：输出1234567890</span><br><span class="line"></span><br><span class="line">FILE* file=fopen(&quot;a.txt&quot;,&quot;w&quot;);</span><br><span class="line">fprintf(file,&quot;输入的数字%d&quot;,3);</span><br><span class="line">fclose(file);</span><br><span class="line">结果:a文件的内容是：输入的数字3</span><br><span class="line"></span><br><span class="line">(a里面内容是1234567890)</span><br><span class="line">int c;</span><br><span class="line">FILE* file=fopen(&quot;a.txt&quot;,&quot;r&quot;);</span><br><span class="line">fscanf(file,&quot;%c&quot;,&amp;c);</span><br><span class="line">putchar(c);</span><br><span class="line">fclose(file);</span><br><span class="line"></span><br><span class="line">结果：1</span><br><span class="line"></span><br><span class="line">int* c[8];</span><br><span class="line">FILE* file=fopen(&quot;a.txt&quot;,&quot;r&quot;);</span><br><span class="line">fread(&amp;c,10,2,file);</span><br><span class="line">printf(&quot;%s&quot;,c);</span><br><span class="line">fclose(file);</span><br><span class="line"></span><br><span class="line">结果：12345678</span><br><span class="line"></span><br><span class="line">char* c=&quot;123&quot;;</span><br><span class="line">FILE* file=fopen(&quot;a.txt&quot;,&quot;w&quot;);</span><br><span class="line">fwrite(c, strlen(c),1,file);</span><br><span class="line">fclose(file);</span><br><span class="line">结果：文件内容：123</span><br></pre></td></tr></table></figure>
</li>
<li><p>程序被装载在计算机上时，会被组织成4个逻辑段：可执行代码，静态数据，动态数据（堆），栈（局部数据对象，函数的参数，调用函数和被调函数的关系</p>
</li>
<li><p>fseek(文件指针，位移量，起始点)，移动文件的指针位置（可以用来在文件中间读取修改内容）；fewind（文件指针），指针重新指到文件起始位置；ftell（文件指针）获取当前指针位置与文件开头位置的偏移量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">char c[30];</span><br><span class="line">FILE* file=fopen(&quot;a.txt&quot;,&quot;r&quot;);</span><br><span class="line">fgets(&amp;c, 15,file);</span><br><span class="line">printf(&quot;%s\n&quot;,c);</span><br><span class="line">fseek(file,1L,0);</span><br><span class="line">fgets(&amp;c, 15,file);</span><br><span class="line">printf(&quot;%s&quot;,c);</span><br><span class="line">fclose(file);</span><br><span class="line">结果：</span><br><span class="line">123</span><br><span class="line">23</span><br></pre></td></tr></table></figure>
</li>
<li><p>动态管理（stdlib.h中）：*malloc(unsigned int size)，申请内存，返回指针；calloc(unsignedn,unsigned size)，申请n个size大小的连续内存数组，返回指针；realloc（void <em>ptr,size_t size）将指针ptr的空间大小该为size，既可以变大，也可以变小；free（\</em>ptr）释放内存</p>
</li>
<li><p>内存丢失就是原来指向一个内存区域的指针指向了另一个内存区域，导致之前的内存区域无法释放管理，就是内存丢失。</p>
</li>
</ol>
<h3 id="网络嵌套字"><a href="#网络嵌套字" class="headerlink" title="网络嵌套字"></a>网络嵌套字</h3><ol>
<li><p>使用socket TCP时，使用send和recv接受发送数据，UDP时，使用recvfrom和sendto接受发送数据。</p>
</li>
<li><p>WSAStartup函数，初始化套接字库（必须），WSAStartup（WORD,LPWSADATA），传入的数据window socket版本和WSADATA指针</p>
</li>
<li><p>socket(int af,int type,intprotocol) a</p>
<p>af:表示一个地址家族，通常为AF_INET</p>
<p>type:表示套接字类型，SOCK_STREAM表示创建面向连接的流式套接字；SOCK_DGRAM表示创建面向无连接的数据报套接字；SOCK_RAW表示创建原始套接字；protocol:表示套接口所用的协议，不确定设置0</p>
<p>调用成功返回SOCKET</p>
</li>
<li><p>bind(SOCKET s,const structsockaddr FAR* name,int namelen):服务端要用。将套接字绑定在指定的端口和地址上。s：表示套接字；是一个sockaddr结构指针，当中包含了要结合的地址和端口号；namelen是name缓冲区域的长度；成功返回0，失败返回SOCKET_ERROR</p>
</li>
<li><p>listen（SOCKET socket,intbacklog）：backlog表示等待连接的最大队列长度，如果设置为2，那个前两个连接时会放置在等待队列中，第三个客户端连接时会报错</p>
</li>
<li><p>accept(SOCKET s,struct sockaddFAR<em> addr ,int FAR</em> addrlen)addr: 是一个sockaddr结构指针，当中包含了要结合的地址和端口号；addrlen用于接收addr的长度，返回值表示已经接受的客户端连接，后续都用新的socket</p>
</li>
<li><p>closesocket(SOCKET s)关闭socket</p>
</li>
<li><p>connect(SOCKET s,const structsockaddr FAR* name,int namelen)，值与bind一样（子机）</p>
</li>
<li><p>u_short Htons(u_short hostshort):将16位的无符号短整型数据由主机排列方式转换到网络排列方式。hostshort：一个主机排列方式的16位的无符号短整型数据；返回值：一个16位网络排列方式的数据</p>
</li>
<li><p>u_long Htonl(u_long hostlong);Htons一样，16位长整型数据</p>
</li>
<li><p>unsigned long iner_addr(constchar FAR* cp)：cp表示地址的字符串，返回32位无符号长整型</p>
</li>
<li><p>recv(SOCKET s,const char FAR<em>buf,int len,int flags)：buf表示接收数据的缓存区，len表示buf的长度，flags表示函数的调用方式，如果是MSG_PEEK表示查看传来的数据，在序列前段的数据会被复制一份到返回缓冲区中，但是这个数据不会从序列中移走；如果是MSG_OOB，就说明是外带数据（一般传0）</em></p>
</li>
<li><p>*send(SOCKET s,const char FAR<em>buf,int len,int flags)，字段意思跟recv一样</em></p>
</li>
<li><p>*recvfrom(SOCKET s, char FAR<em>buf, int len,int flags, struct socketaddr FAR</em> from,int FAR* fromlen):前面跟之前的一样，from是一个指向地址结构的指针，用来接收发送方的地址信息；fromlen是缓冲区的长度</p>
</li>
<li><p>sendfrom(SOCKET s, char FAR<em>buf, int len,int flags, struct socketaddr FAR</em> to,int FAR* tolen)与recvfrom一样</p>
</li>
<li><p>WASCleanup()用来释放初始化时的资源</p>
</li>
</ol>
</div><div class="article-meta" style="max-width:800px"><div class="tags"><i class="icon icon-tag"></i><ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/C语言/">C语言</a><span class="tag-list-count">4</span></li></ul></div><div class="categories"><i class="icon icon-category"></i><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/C语言/">C语言</a><span class="category-list-count">4</span></li></ul></div></div><div class="article-comment" style="max-width:800px"><div class="ds-thread" id="ds-thread" data-thread-key="ck85q6to2000htfo1pspt3n2q" data-title="C语言学习笔记(四)" data-url="https://earthwo.github.io/2017/03/06/C语言学习笔记-四/" site-name="ueibo"></div><script>var siteName = document.getElementById('ds-thread').getAttribute('site-name');
var duoshuoQuery = {short_name: siteName};
(function() {
  var ds = document.createElement('script');
  ds.type = 'text/javascript';ds.async = true;
  ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
  ds.charset = 'UTF-8';
  (document.getElementsByTagName('head')[0] 
  || document.getElementsByTagName('body')[0]).appendChild(ds);
})();</script></div><ul class="navication"><li class="home"><a href="/"><i class="icon icon-home"></i></a></li><li><a href="/2017/05/11/java动态代理/"><i class="icon icon-arror-left"></i></a></li><li><a href="/2017/03/06/C语言学习笔记-三/"><i class="icon icon-arror-right"></i></a></li></ul><div class="page-footer"><div class="top"><ul class="social"><li><a href="https://github.com/earthWo" title="Github" target="_blank"><i class="icon icon-github"></i></a></li></ul></div><div class="bottom"><p class="copyright">© 2020 alonealice<br><small><a href="http://www.miitbeian.gov.cn" target="_blank">浙ICP备17033688号</a></small><small>, THEME BY <a href="https://github.com/BoizZ/hexo-theme-laughing" target="_blank">LAUGHING</a></small></p></div></div></div><script>var wrap = document.getElementById('wrap');
window.onload = function () {
  wrap.className += ' done';
}</script></body></html>