<!DOCTYPE html><html lang="zh-cn"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=Edge"><meta name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no"><meta name="format-detection" content="telephone=no"><meta name="format-detection" content="email=no"><meta name="description" content="study life"><meta name="keywords" content="Hexo, Gruntjs, Nodejs, Reactjs, Vuejs"><title>android开发小tip与踩过的坑（持续更新） - alonealice</title><link rel="stylesheet" href="/css/main_style.min.css"><link rel="icon" href="/favicon.ico"></head><body><input id="navi" type="checkbox"><ul class="main-navication"><li><a href="/"><span>Home</span></a></li><li><a href="https://github.com/earthWo"><span>Github</span></a></li></ul><div class="wrapper" id="wrap"><div class="post-header"><label class="navi-button light" for="navi">MENU</label><img class="background" src="https://img.zcool.cn/community/014177554b6ae7000001bf729a3698.jpg@1280w_1l_0o_100sh.jpg"><div class="post-title"><h1 class="title">android开发小tip与踩过的坑（持续更新）</h1><ul class="meta"><li><i class="icon icon-author"></i>alonealice</li><li><i class="icon icon-clock"></i>10 Minutes</li><li><i class="icon icon-calendar"></i>2017年7月11日</li></ul></div></div><div class="article-content" style="max-width:800px"><p>这篇文章主要是记录自己在开发过程中遇到的一些小tip，别看这些东西很细微，有时候可以解决大麻烦，有些对于开发非常重要。还有就是自己曾经踩过的坑，我觉得都有必要记录下来。这些坑虽然不是每个人都会踩(有些确实是自己太笨了才踩的)，但是既然我踩了，那可能还会有人踩，这样既惊醒自己，也可帮助他人。文章内容持续更新，也没有具体的分类，遇到一个添加一个。</p>
<h4 id="greendao-生成代码"><a href="#greendao-生成代码" class="headerlink" title="greendao 生成代码"></a>greendao 生成代码</h4><p>很多人都用过greendao，集成greendao时，会自动生成DaoMaster和DaoSession等文件，这些文件至关重要。但是前段时间我在集成后竟然无法生成这些文件，找了半天也不知道原因。后来才知道原因：在配置完greendao之后，必须有实体作为greendao的数据实体，如果一个实体都没有，它是不会生成DaoMaster等文件的；同时，greendao目前好像还不支持kotlin，无法将kotlin的数据类作为实体，还是要将实体卸载java文件中。</p>
<h4 id="greendao-主键自增长"><a href="#greendao-主键自增长" class="headerlink" title="greendao 主键自增长"></a>greendao 主键自增长</h4><p>greendao可以设置主键自增长，但是我在用时就在想，如果没有没有主键，那么long类型不是为0吗，那还是有值呀。后来在使用时果然出现问题。实际上greendao在使用主键自增长是，主键类型必须是Long,而不是long，这种主键就可以为null了。</p>
<h3 id="service启动activity"><a href="#service启动activity" class="headerlink" title="service启动activity"></a>service启动activity</h3><p>当在Service中启动activity时，需要添加<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">it.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</span><br></pre></td></tr></table></figure></p>
<p>因为在service中启动的activity是没有栈的，启动时会程序判断当前是否是在service中启动且包含FLAG_ACTIVITY_NEW_TASK。这样启动的activity相当是singleInstance模式。<br>但是如果你在activity中配置了singleTask模式，就会依旧在task中启动一个。</p>
<h3 id="synchronized使用"><a href="#synchronized使用" class="headerlink" title="synchronized使用"></a>synchronized使用</h3><p>synchronized在锁代码块时其实锁的是对象，所以如果你在锁之前完全没有使用该对象，就白锁了。</p>
<h3 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;&lt;      :     左移运算符，num &lt;&lt; 1,相当于num乘以2(&lt;&lt; 2 相当于乘以4)</span><br><span class="line">&gt;&gt;      :     右移运算符，num &gt;&gt; 1,相当于num除以2</span><br><span class="line">&gt;&gt;&gt;     :     无符号右移，忽略符号位，空位都以0补齐</span><br></pre></td></tr></table></figure>
<p>位运算比普通的运算块</p>
<h3 id="ImageView-scaleType"><a href="#ImageView-scaleType" class="headerlink" title="ImageView scaleType"></a>ImageView scaleType</h3><p>center:图片居中，不缩放，不放大，超过了就截取中间的，不超过就空着。<br>centerInside:图片居中，可缩放，不放大，超过了就缩小放置在中间，不超过就空着。<br>centerCrop:图片居中,可缩放，可放大，超过了就将缩小到有一边与ImageView边相等，不超过放大到最小边与ImageView边相等，保证图片完全充满ImageView<br>fitCenter:图片居中，可缩放，可放大，缩小放大到自己有一边到ImageView边界为止。<br>fitXY:可放大，可缩放，将自己完全充满ImageView，可以变形。<br>fitStart:可放大，可缩放，缩小放大到自己有一边到ImageView边界为止，同时靠左靠上。<br>fitEnd:可放大，可缩放，缩小放大到自己有一边到ImageView边界为止，同时靠右靠下。</p>
<h3 id="FragmentPagerAdapter和FragmentStatePagerAdapter"><a href="#FragmentPagerAdapter和FragmentStatePagerAdapter" class="headerlink" title="FragmentPagerAdapter和FragmentStatePagerAdapter"></a>FragmentPagerAdapter和FragmentStatePagerAdapter</h3><p>FragmentPagerAdapter在滑动时，destroyItem只会将那些不可见的Fragment做detach处理，即只是从屏幕上移除，并不会销毁。同时即使使用notifyDataSetChanged，并且Fragment的数量减少，原来已有的Fragment也不会重新创建。所以这种方法适合item少量的情况。</p>
<p>FragmentStatePagerAdapter在执行destroyItem时，会将那些不可见的Fragment销毁，同时会保存其状态。在再次需要显示的时候回重新创建，并且传入之前的状态。所以这种方式适合item数量比较大时的情况，可以减少fragment的内存，但是在创建和销毁时会有所消耗。</p>
<h3 id="ViewPager-Fragment禁止预加载延迟"><a href="#ViewPager-Fragment禁止预加载延迟" class="headerlink" title="ViewPager+Fragment禁止预加载延迟"></a>ViewPager+Fragment禁止预加载延迟</h3><p>当ViewPager.setOffscreenPageLimit(0);当设置预加载的page&lt;1时，程序还是会设置默认的预加载页面为1，所以该方法不可行。<br>在FragmentPagerAdapter、FragmentStatePagerAdapter的instantiateItem方法中，都有将未显示的fragment设置为不可见状态：fragment.setUserVisibleHint(false);将可见的fragment设置为可见状态：fragment.setUserVisibleHint(true);所以我们只需要在fragment中重写setUserVisibleHint方法，可见时才加载布局。甚至可以使用ViewStub，在可见时初始化整个布局。</p>
<h3 id="ViewPaper直接跳转到后面item"><a href="#ViewPaper直接跳转到后面item" class="headerlink" title="ViewPaper直接跳转到后面item"></a>ViewPaper直接跳转到后面item</h3><p>写一个Scroller类继承Scroller，重写其startScroll方法，将其滑动的时间设置为0。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">      public void startScroll(int startX, int startY, int dx, int dy, int duration) &#123;</span><br><span class="line">          super.startScroll(startX, startY, dx, dy, 0);</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></p>
<p>使用反射的方法，将ViewPager的Scroller替换掉：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Class c=viewPager.getClass();</span><br><span class="line">Field field=c.getDeclaredField(&quot;mScroller&quot;);</span><br><span class="line">field.setAccessible(true);</span><br><span class="line">field.set(viewPager,scroll);</span><br></pre></td></tr></table></figure></p>
<p>这种方式会使普通的滑动的时间也为0，所以在具体使用时，可以通过滑动的具体情况，在跳转多页时才将时间设置0。</p>
<h3 id="ProGuard的常用语法"><a href="#ProGuard的常用语法" class="headerlink" title="ProGuard的常用语法"></a>ProGuard的常用语法</h3><p>-optimizationpasses 5 代码优化次数，android一般为5，理论上越多越好，到时多了混淆时间就长了，而且优化到无法再优化时就停止了，因此不一定是写着的次数<br>-libraryjars class_path 避免混淆应用的依赖包，如android-support-v4<br>-keep [,modifier,…] class_specification 不混淆某些类。例子：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-keep public class javax.**</span><br><span class="line">-keep enum com.facebook.**</span><br><span class="line">-keep class com.baidu.** &#123; *; &#125;</span><br></pre></td></tr></table></figure></p>
<p>-keepclassmembers [,modifier,…] class_specification 不混淆类的成员。例子：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-keepclassmembers class * extends android.app.Activity&#123;</span><br><span class="line">    public void *(android.view.View); //保持activity类里面的void方法，参数为View的不混淆</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>-keepclasseswithmembers [,modifier,…] class_specification 不混淆类及其成员。例子：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-keepclasseswithmembers class * &#123;  //不混淆有该init方法和该类</span><br><span class="line">  public &lt;init&gt;(android.content.Context);  </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>-keepnames class_specification 不混淆类及其成员名。例子：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-keepnames class * implements java.io.Serializable //不混淆实现Serializable接口的类</span><br><span class="line"># parcelable 不被混淆</span><br><span class="line">  -keep class * implements android.os.Parcelable &#123;//不混淆实现Parcelable接口的类</span><br><span class="line">  public static finalandroid.os.ParcelableCreator *;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>-keepattributes {attribute_name,…} 不混淆给定的可选属性。例子：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-keepattributes *Annotation*//不混淆注解</span><br><span class="line">-keepattributes Signature//不混淆泛型</span><br><span class="line">-keepattributes SourceFile,LineNumberTable//不混淆异常时的代码行</span><br></pre></td></tr></table></figure></p>
<p>-keepclassmembernames class_specification 不混淆类的成员名。<br>-keepclasseswithmembernames class_specification 不混淆类及其成员名<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-keepclasseswithmembernames class * &#123;  //不混淆自定义View之类的类</span><br><span class="line">    public &lt;init&gt;(android.content.Context, android.util.AttributeSet);  </span><br><span class="line">&#125;  </span><br><span class="line">assumenosideeffects class_specification 假设调用不产生任何影响，在proguard代码优化时会将该调用remove掉。如Log等等</span><br></pre></td></tr></table></figure></p>
<p>-dontwarn [class_filter] 不提示warnning<br>-dontusemixedcaseclassnames  //混淆时不产生混合大小写的类名<br>-dontskipnonpubliclibraryclasses  //指定不去忽略非公共的库类<br>-dontpreverify  //不预校验<br>-verbose  //显示混淆的log，帮助排错<br>-optimizations !code/simplification/arithmetic,!field/<em>,!class/merging/</em>  //代码混淆采用的算法，一般不改变，使用谷歌默认算法即可</p>
<h3 id="Jobscheduler使用"><a href="#Jobscheduler使用" class="headerlink" title="Jobscheduler使用"></a>Jobscheduler使用</h3><p>在Jobscheduler使用过程中，设置延时setMinimumLatency和设置最大延时setOverrideDeadline，不同手机延时时间可能会出现偏差。比如测试一台sony手机时，延时最小为5s，同时，一旦设置了最大延时则普通的延时时间无效，而如果单设置延时，延时时间也不一定准，而这些在模拟器上则完全没有出现。<br>一旦设置了这两个延时，则无法再设置重复时间，不然会报错，一旦设置了重启设备任务继续时setPersisted，需要配置系统开机事件的权限。<br>当onStopJob返回true，或者jobFinished(params, true)时，系统会在满足条件是重新调用onStartJob，可以设置setBackoffCriteria设置等待时间和时间策略，默认等待时间是30s，策略是指数增长。</p>
<h3 id="BroadCast权限问题"><a href="#BroadCast权限问题" class="headerlink" title="BroadCast权限问题"></a>BroadCast权限问题</h3><p>1.自定义权限时，名字不是任意命名的，最好是<code>包名.名字</code>的形式（经测试，a.b.名字也是可以的，但是直接名字不行）。<br>2.定义权限时，需要在发送方和接收方都定义权限和申请权限。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;uses-permission android:name=&quot;c.a.SEND_MESSAGE&quot; /&gt;</span><br><span class="line">&lt;permission android:name=&quot;c.a.SEND_MESSAGE&quot; /&gt;</span><br></pre></td></tr></table></figure></p>
<p>3.发送带权限的Broadcast时，说明应用要有该权限才能发出这条通知，但是任何普通的receiver都能接收。<br>4.Receiver配置权限后，说明只有有该权限的其他应用的通知，它才能接收到，但是自己的通知还是可以不传权限收到。<br>Broadcast其他tip：静态注册的Receiver，要不是单独一个文件的，要不是public static的；StickyBroadcast已经被废弃。</p>
<h3 id="Service进程"><a href="#Service进程" class="headerlink" title="Service进程"></a>Service进程</h3><p>service启动时可以设置进程<code>android:process=&quot;:web&quot;</code>。当在其他进程启动Service时，如果该Service没有单独设置进程，那么该Service依旧在主进程中。</p>
</div><div class="article-meta" style="max-width:800px"><div class="tags"><i class="icon icon-tag"></i><ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/tips和坑/">tips和坑</a><span class="tag-list-count">3</span></li></ul></div><div class="categories"><i class="icon icon-category"></i><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/tips和坑/">tips和坑</a><span class="category-list-count">3</span></li></ul></div></div><div class="article-comment" style="max-width:800px"><div class="ds-thread" id="ds-thread" data-thread-key="ck85r7lux007yfxo1fv4k2gbo" data-title="android开发小tip与踩过的坑（持续更新）" data-url="https://earthwo.github.io/2017/07/11/android开发小tip与踩过的坑（持续更新）/" site-name="ueibo"></div><script>var siteName = document.getElementById('ds-thread').getAttribute('site-name');
var duoshuoQuery = {short_name: siteName};
(function() {
  var ds = document.createElement('script');
  ds.type = 'text/javascript';ds.async = true;
  ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
  ds.charset = 'UTF-8';
  (document.getElementsByTagName('head')[0] 
  || document.getElementsByTagName('body')[0]).appendChild(ds);
})();</script></div><ul class="navication"><li class="home"><a href="/"><i class="icon icon-home"></i></a></li><li><a href="/2017/07/14/Android《进阶之光》读书笔记（一）/"><i class="icon icon-arror-left"></i></a></li><li><a href="/2017/07/03/BottomNavigationView分析/"><i class="icon icon-arror-right"></i></a></li></ul><div class="page-footer"><div class="top"><ul class="social"><li><a href="https://github.com/earthWo" title="Github" target="_blank"><i class="icon icon-github"></i></a></li></ul></div><div class="bottom"><p class="copyright">© 2020 alonealice<br><small><a href="http://www.beian.miit.gov.cn" target="_blank">浙ICP备17033688号</a></small><small>, THEME BY <a href="https://github.com/BoizZ/hexo-theme-laughing" target="_blank">LAUGHING</a></small></p></div></div></div><script>var wrap = document.getElementById('wrap');
window.onload = function () {
  wrap.className += ' done';
}</script></body></html>