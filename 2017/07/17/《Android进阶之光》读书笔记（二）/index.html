<!DOCTYPE html><html lang="zh-cn"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=Edge"><meta name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no"><meta name="format-detection" content="telephone=no"><meta name="format-detection" content="email=no"><meta name="description" content="study life"><meta name="keywords" content="Hexo, Gruntjs, Nodejs, Reactjs, Vuejs"><title>《Android进阶之光》读书笔记(二) - alonealice</title><link rel="stylesheet" href="/css/main_style.min.css"><link rel="icon" href="/favicon.ico"></head><body><input id="navi" type="checkbox"><ul class="main-navication"><li><a href="/"><span>Home</span></a></li><li><a href="https://github.com/earthWo"><span>Github</span></a></li></ul><div class="wrapper" id="wrap"><div class="post-header"><label class="navi-button light" for="navi">MENU</label><img class="background" src="https://img.zcool.cn/community/014177554b6ae7000001bf729a3698.jpg@1280w_1l_0o_100sh.jpg"><div class="post-title"><h1 class="title">《Android进阶之光》读书笔记(二)</h1><ul class="meta"><li><i class="icon icon-author"></i>alonealice</li><li><i class="icon icon-clock"></i>6 Minutes</li><li><i class="icon icon-calendar"></i>2017年7月17日</li></ul></div></div><div class="article-content" style="max-width:800px"><h2 id="View体系和自定义View"><a href="#View体系和自定义View" class="headerlink" title="View体系和自定义View"></a>View体系和自定义View</h2><h3 id="点击事件坐标系"><a href="#点击事件坐标系" class="headerlink" title="点击事件坐标系"></a>点击事件坐标系</h3><p><code>getX()</code>:获取点击事件距离控件左边的距离，即视图坐标<br><code>getY()</code>:获取点击事件距离控件左边的距离，即视图坐标<br><code>getRawX()</code>:获取点击事件距离整个屏幕左边的距离，即绝对坐标<br><code>getRawY()</code>:获取点击事件距离整个屏幕顶边的距离，即绝对坐标</p>
<h3 id="View的滑动"><a href="#View的滑动" class="headerlink" title="View的滑动"></a>View的滑动</h3><p>Android View移动的6中方法：<code>layout()</code>，<code>offsetLeftAndRight()</code>和<code>offsetTopAndBottom()</code>，<br><code>LayoutParams</code>，动画，<code>scrollTo</code>，<code>scrollBy</code>，<code>scroller</code>。<br><code>offsetLeftAndRight()</code>和<code>offsetTopAndBottom()</code>里面传递的是偏移量。</p>
<p>动画完成后，会回到原来的位置，我们可以在xml中加上<code>fillAfter=&quot;true&quot;</code>，使动画保持在最后一个状态。但是即使这样，view的实际位置依旧在原来的地方，view动画不能改变view的属性。</p>
<p><code>scrollTo</code>和<code>scrollBy</code>移动的是View的内容，他们的移动可以看做是手机的移动。</p>
<p><code>Scroller</code>本生不能实现View的滑动，需要跟View的computeScroll方法配合才能实现滑动效果。</p>
<p><code>Scroller</code>在执行<code>startScroll</code>时 只是设置一些参数，同时调用View的<code>onDraw</code>方法，<code>onDraw()</code>方法会调用<code>computeScroll</code>方法。在<code>computeScroll</code>方法中，我们一般会调用<code>computeScrollOffset()</code>方法。这个方法会判断是否已经滑动完毕，如果未完毕，则根据时间和差值器获取当前滑动的位置。</p>
<p>View动画有一个大的缺陷，就是不具有交互性，所以View动画只能做普通的动画效果，要避免交互操作，但是优点是效率高，使用方便。<br>属性动画可用的动画类型：<code>translationX</code>和<code>translationY</code>(延X或Y轴移动)，<code>rotation</code>、<code>rotationX</code>和<code>rotationY</code>(围绕支点进行旋转)，<code>PrivotX</code>和<code>PrivotY</code>(控制支点位置)，<code>alpha</code>(透明度)，<code>x</code>和<code>y</code>(View的最终位置)。</p>
<p>可以通过添加<code>get</code>和<code>set</code>方法添加属性动画的类型，在set方法中使用<code>requestLayout()</code>重新显示View。<br><code>ValueAnimator</code>不提供任何动画效果，它是一个数值发生器，用来产生一定的规律的数字，从而控制动画实现。</p>
<p>在使用组合动画<code>AnimatorSet</code>动画时，需要先用到<code>AnimatorSet</code>的<code>play</code>方法，该方法builder，builder使用建造者模式构建，当中包括4个方法：<br><code>after(Animator animator)</code>:将现有动画插入到传入的动画之后执行<br><code>after(long delay)</code>:将现有动画延迟指定时间执行<br><code>before(Animator anim)</code>:将现有动画插入到指定动画前执行<br><code>with(Animator anim)</code>:将现有动画和传入动画同时执行</p>
<p>组合动画除了使用<code>AnimatorSet</code>，还可以使用<code>PropertyValuesHolder</code>，当然，我们得结合<code>OnjectAnimator.ofPropertyValuesHolder</code>方法来使用，当然，这种方法动画只能同时进行。代码如下:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PropertyValuesHolder holder1=PropertyValuesHolder.ofFloat(&quot;scaleX&quot;,1.0f,1,5f);</span><br><span class="line">...</span><br><span class="line">ObjectAnimator animator=ObjectAnimator.ofPropertyValuesHolder(view,holder1,holder2,holder3);</span><br></pre></td></tr></table></figure></p>
<p>除此之外，还可以使用xml来进行动画，并通过<code>AnimatorInflater.loadAnimator</code>方法来加载动画。</p>
<h3 id="View事件分发"><a href="#View事件分发" class="headerlink" title="View事件分发"></a>View事件分发</h3><p>一个<code>Activity</code>对象包含一个Window对象，这个对象由<code>PhoneWindow</code>来实现。<code>PhoneWindow</code>将<code>DecorView</code>作为整个应用窗口的根<code>View</code>，而这个<code>DecorView</code>又将屏幕分为两个区域，一个是<code>TitleView</code>，另一个是<code>ContentView</code>，而我们的布局都展示在<code>ContentView</code>中。</p>
<p>事件分发的重要3个方法：<br><code>dispatchTouchEvent(MotionEvent ev)</code>————用来进行事件的分发<br><code>onInterceptTouchEvent(MotionEvent ev)</code>————用来进行事件的拦截（dispatchTouchEvent 方法中执行，在View中不存在，在Viewgroup中）<br><code>onTouchEvent(MotionEvent ev)</code>————用来处理点击事件</p>
<p>分发机制具体的流程：<br>点击事件产生后，事件先会传递给当前的<code>Activity</code>，这会调用<code>Activity</code>的<code>dispatchTouchEvent</code>方法，具体的工作会交由<code>PhoneWindow</code>来完成。然后<code>PhoneWindow</code>再把工作交由<code>DecorView</code>，之后再有<code>DecorView</code>把事件处理交由根<code>ViewGroup</code>。</p>
<p><code>ViewGroup</code>的<code>dispatchTouchEvent</code>方法中，首先要先判断事件是否是DOWN事件，如果是，则进行初始化。因为任何一个动作的开始都是由DOWN开始，所以要先初始化。接下来要判断是否这个ViewGroup是否拦截了这个事件，即mFirstTouchTarget是否为null，拦截了就为null，如果既不是DOWN事件，有拦截了（mFirstTouchTarget==null）那么intercept就直接为true，表示拦截了当次事件。当拦截的情况下。则调用<code>onInterceptTouchEvent</code>方法判断是否依旧拦截。子View可以通过<code>requestDisallowInterceptTouchEvent</code>来设置是否禁止拦截器拦截除了DOWN以外的事件。<br><code>ViewGroup</code>在传递子View的事件时，view的顺序是从上往下传递的，即最新添加的最先执行。同时，View的<code>onTouchListener</code>事件比<code>onTouchEvent</code>有更高的优先级，如果<code>onTouchListener</code>返回true，说明已经消费掉事件，那么<code>onTouchEvent</code>不再执行。</p>
<p>Activity显示的流程：<br>当我们在调用startActivity时，会调用<code>ActivityThread</code>的<code>hanldeLaunchActivity</code>来创建activity。创建时会调用到<code>oncreate</code>方法，从而完成DecorView的创建。然后会执行<code>handleResumeActivity</code>方法，在这个方法里面，会调用Activity的<code>onResume</code>方法。随后会得到<code>DecorView</code>、<code>WindowManager</code>、<code>ViewManager</code>，并且调用其实现类<code>WindowManagerImpl</code>的<code>addView</code>。在<code>WindowManagerImpl</code>的<code>addView</code>方法中，调用<code>WindowManagerGlobal</code>的<code>addView</code>方法，而在这个方法中创建<code>ViewRootImpl</code>实例，并且调用<code>setView()</code>方法，将<code>DecorView</code>加载到Window中。<br>同时，<code>ViewRootImpl</code>还会调用<code>PerformTraveals</code>方法，使<code>ViewTree</code>开始View的工作流程。该方法会依次执行<code>performMeasure</code>、<code>performLayout</code>、<br><code>performDraw</code>方法。</p>
<p><code>MeasureSpec</code>代表了32位的int值，其中高2位是<code>SpecMode(测量模式)</code>，低30位是<code>SpecSize(测量尺寸)</code>。<br><code>SpecMode</code>的3种模式:<br><code>UNSPECIFIED</code>:未指定模式，View想多大就多大，不会受父容器限制。<br><code>AT_MOST</code>:最大模式，对应于wrap_content属性，子View的最终大小是父View指定的SpecSize，并且最大不能大于这个值。<br><code>EXACTLY</code> :精确模式，对应于match_content属性，父容器测量出View所需要的大小，就是SpecSize的值。</p>
</div><div class="article-meta" style="max-width:800px"><div class="tags"><i class="icon icon-tag"></i><ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android进阶之光/">Android进阶之光</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/读书笔记/">读书笔记</a><span class="tag-list-count">8</span></li></ul></div><div class="categories"><i class="icon icon-category"></i><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android进阶之光/">Android进阶之光</a><span class="category-list-count">5</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Android进阶之光/读书笔记/">读书笔记</a><span class="category-list-count">5</span></li></ul></li></ul></div></div><div class="article-comment" style="max-width:800px"><div class="ds-thread" id="ds-thread" data-thread-key="ck85r4teb002uc7o1cxrkdr04" data-title="《Android进阶之光》读书笔记(二)" data-url="https://earthwo.github.io/2017/07/17/《Android进阶之光》读书笔记（二）/" site-name="ueibo"></div><script>var siteName = document.getElementById('ds-thread').getAttribute('site-name');
var duoshuoQuery = {short_name: siteName};
(function() {
  var ds = document.createElement('script');
  ds.type = 'text/javascript';ds.async = true;
  ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
  ds.charset = 'UTF-8';
  (document.getElementsByTagName('head')[0] 
  || document.getElementsByTagName('body')[0]).appendChild(ds);
})();</script></div><ul class="navication"><li class="home"><a href="/"><i class="icon icon-home"></i></a></li><li><a href="/2017/07/18/《Android进阶之光》读书笔记（三）/"><i class="icon icon-arror-left"></i></a></li><li><a href="/2017/07/14/Android《进阶之光》读书笔记（一）/"><i class="icon icon-arror-right"></i></a></li></ul><div class="page-footer"><div class="top"><ul class="social"><li><a href="https://github.com/earthWo" title="Github" target="_blank"><i class="icon icon-github"></i></a></li></ul></div><div class="bottom"><p class="copyright">© 2020 alonealice<br><small><a href="http://www.miitbeian.gov.cn/" target="_blank">浙ICP备17033688号</a></small><small>, THEME BY <a href="https://github.com/BoizZ/hexo-theme-laughing" target="_blank">LAUGHING</a></small></p></div></div></div><script>var wrap = document.getElementById('wrap');
window.onload = function () {
  wrap.className += ' done';
}</script></body></html>