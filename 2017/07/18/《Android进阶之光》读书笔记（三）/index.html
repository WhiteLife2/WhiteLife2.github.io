<!DOCTYPE html><html lang="zh-cn"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=Edge"><meta name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no"><meta name="format-detection" content="telephone=no"><meta name="format-detection" content="email=no"><meta name="description" content="study life"><meta name="keywords" content="Hexo, Gruntjs, Nodejs, Reactjs, Vuejs"><title>《Android进阶之光》读书笔记（三） - alonealice</title><link rel="stylesheet" href="/css/main_style.min.css"><link rel="icon" href="/favicon.ico"></head><body><input id="navi" type="checkbox"><ul class="main-navication"><li><a href="/"><span>Home</span></a></li><li><a href="https://github.com/earthWo"><span>Github</span></a></li></ul><div class="wrapper" id="wrap"><div class="post-header"><label class="navi-button light" for="navi">MENU</label><img class="background" src="https://img.zcool.cn/community/014177554b6ae7000001bf729a3698.jpg@1280w_1l_0o_100sh.jpg"><div class="post-title"><h1 class="title">《Android进阶之光》读书笔记（三）</h1><ul class="meta"><li><i class="icon icon-author"></i>alonealice</li><li><i class="icon icon-clock"></i>4 Minutes</li><li><i class="icon icon-calendar"></i>2017年7月18日</li></ul></div></div><div class="article-content" style="max-width:800px"><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><h3 id="线程基础"><a href="#线程基础" class="headerlink" title="线程基础"></a>线程基础</h3><p>继承是操作系统结构的基础，是程序在一个数据集合上运行的过程，是系统进行资源分配和调度的基本单位。进程可以被看做程序的实体，同样，它也是线程的容器。</p>
<p>线程是操作系统调度的最小单元，也叫做轻量级进程。</p>
<p>使用多线程的原因：使用多线程可以减少程序的响应时间；与进程相比，线程的创建和切换开销更小，同时在数据共享方面效率更高；多cpu或者多核计算机本身就支持多线程，多进程可以提高CPU的使用率;多线程可以简化程序的结构，使程序便于理解和维护。</p>
<p>线程的状态：New(新创建状态，刚创建为调用start方法)；Runnable(可运行状态，调用start方法)；Blocked(阻塞状态，线程被锁阻塞，暂时不活动)；Waiting(等待状态)；Timed waiting(超时等待状态，可以在指定的时间自行返回)；Terminated(终止状态，执行完毕退出或者捕获异常退出)</p>
<p>创建线程的方法：继承Thread类，重写run方法；实现Runnable接口，并实现run方法；实现Callable接口，重写call方法。call方法可以返回一个返回值，也可以抛出异常，同时Callable可以拿到一个Future,来监视目标线程的call方法，但是调用Future的get方法获取结果时，线程会堵塞，知道call方法返回结果。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ExecutorService s=ExecutorService.newSingleThreadPool();</span><br><span class="line">Future f=s.submin(callable);</span><br><span class="line">f.get();</span><br></pre></td></tr></table></figure></p>
<p>三种方法中，推荐使用Runnable，因为没有加强和修改的情况下没有必要使用继承。</p>
<p>使用<code>Lock</code>的lock方法可以对方法中的代码块进行加锁，在通过unlock进行解锁。除此以外，可以通过<code>newCondition</code>方法获取条件对象，调用<code>await</code>方法阻塞当前线程，并放弃锁，等待其他线程调用<code>Condition</code>的<code>signalAll()</code>方法唤醒。</p>
<p>volatile修饰变量之后，当一个线程修改了变量的值时，该变量对其他线程会立刻可见。</p>
<p>volatile无法保证对变量的操作是原子性的，但是它保证是有序性的，即在volatile变量之前的语句不会到之后去执行。</p>
<p>使用volatile的条件：对变量的操作不依赖当前值（如自增，因为其不保证原子性）；没有包含在其他不等式中；</p>
<p>volatile的使用场景：状态标志；双重检查模式</p>
<h3 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h3><p>阻塞队列场景：<br>当队列中没有数据的情况下，消费者端的所有线程都会被自动阻塞（挂起），直到有数据放入队列。<br>当队列中填满数据的情况下，生产者端的所有线程都会被自动阻塞（挂起），直到有空的位置。</p>
<p>核心方法：<br><code>offer(onject)</code>:表示如果可以的话，将object对象添加到BlockingQueue中，成功返回true，失败返回false，该方法不阻塞队列。<br><code>offer(E 0,long timeout,TimeUnit unit)</code>:设定等待时间添加对象，如果时间到了还没有添加，则返回失败。<br><code>put(object)</code>:添加对象，如果没有空间，则线程被阻塞。</p>
<p><code>poll(time)</code>:取走排在首位的对象，没有则等待相应的时间，取不到则返回null<br><code>poll(long time,TimeUnit unit)</code>:取走排在首位的对象，没有则等待相应的时间，取不到则返回false<br><code>take()</code>:取走排在首位的对象，没有则阻塞<br><code>drainTo()</code>:一次性取走所有可用的数据对象</p>
<p>阻塞队列种类：<br>1.<code>ArrayBlockingQueue</code>:<br>使用数组实现有限的阻塞队列，并按照先进先出原则对元素进行排列。默认不保证线程公平（即先阻塞的先用）。保证公平原则的可以如下使用：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ArrayBlockingQueue queue=new ArrayBlockingQueue(200,true);</span><br></pre></td></tr></table></figure></p>
<p>2.<code>LinkedBlockingQueue</code>:<br>使用链表的阻塞队列，按照先进先出原则对元素排列，内部有一个数据缓冲队列。当生产者往里面添加一个数据时会立即返回，数据会添加到队列中，直到队列满时才会阻塞。内部生产者和消费者采用独立的锁来控制数据同步。如果构造它时不指定其容量的大小，那么会产生一个近似于无限大的队列，会无限往里面添加时会消耗掉内存。<br>3.<code>PriorityBlockingQueue</code>:<br>支持优先级的无界队列，默认采取自然升序排列。可以自定义实现compareTo方法指定元素排序规则，也可以构造时传入Comparator来对元素进行排列。<br>4.<code>DelayQueue</code>:<br>支持延时获取元素的无界阻塞队列，里面使用PriorityBlockingQueue实现。队列中的元素必须实现Delayed接口来指定元素到期的时间，到期后才能被取走。<br>5.<code>SynchronousQueue</code>:<br>不存储元素的阻塞队列。即每一插入的操作必须要等待另一个取走操作，反过来也一样。<br>6.<code>LinkedTransferQueue</code>:<br>由链表结构组成的TransferQueue队列，其中实现了一个重要的接口TransferQueue,里面有3个重要的方法：<br>(1)transfer(E e):若当前存在一个正在等待获取的消费者线程，则立即将元素给消费者，否则会将元素插入到队列尾部，并且等待进入阻塞状态，直到被取走。<br>(2)tryTransfer(E e):若当前存在一个正在等待获取的消费者线程，则立即将元素给消费者,否则返回false，这个不是一个阻塞操作。<br>(3)tryTransfer(E e，long timeout,TimeUnit unit):若当前存在一个正在等待获取的消费者线程，则立即将元素给消费者，否则会将元素插入到队列尾部，并且等待进入阻塞状态，直到被取走。若超时则返回false，不超时返回true。<br>7.LinkedBlockingQueue:<br>由链表组成的双向阻塞队列，可以从两端插入移出元素，所以多了addFirst、addLast、offerFirst、offerLast等方法。</p>
<h3 id="线程池-ThreadPoolExecutor"><a href="#线程池-ThreadPoolExecutor" class="headerlink" title="线程池 ThreadPoolExecutor"></a>线程池 ThreadPoolExecutor</h3><p>核心参数：<br>corePoolSize:核心线程数。<br>maximumPoolSize:最大线程数。<br>keepAliveTime:非核心线程闲置超时时间。<br>TimeUnit:参数时间单位。<br>workQueue:任务队列。<br>ThreadFactory:线程工厂，一般无需设置。<br>RejectExecutionHandler:饱和策略。（CallerRunsPolicy:用调用者所在线程来处理任务；DiscardPolicy:不能执行任务，并将任务删除；DiscardOldestPolicy:丢弃队列最近任务，并执行当前任务）</p>
</div><div class="article-meta" style="max-width:800px"><div class="tags"><i class="icon icon-tag"></i><ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android进阶之光/">Android进阶之光</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/读书笔记/">读书笔记</a><span class="tag-list-count">8</span></li></ul></div><div class="categories"><i class="icon icon-category"></i><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android进阶之光/">Android进阶之光</a><span class="category-list-count">5</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Android进阶之光/读书笔记/">读书笔记</a><span class="category-list-count">5</span></li></ul></li></ul></div></div><div class="article-comment" style="max-width:800px"><div class="ds-thread" id="ds-thread" data-thread-key="ck85r7lsy002tfxo1756jvwac" data-title="《Android进阶之光》读书笔记（三）" data-url="https://earthwo.github.io/2017/07/18/《Android进阶之光》读书笔记（三）/" site-name="ueibo"></div><script>var siteName = document.getElementById('ds-thread').getAttribute('site-name');
var duoshuoQuery = {short_name: siteName};
(function() {
  var ds = document.createElement('script');
  ds.type = 'text/javascript';ds.async = true;
  ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
  ds.charset = 'UTF-8';
  (document.getElementsByTagName('head')[0] 
  || document.getElementsByTagName('body')[0]).appendChild(ds);
})();</script></div><ul class="navication"><li class="home"><a href="/"><i class="icon icon-home"></i></a></li><li><a href="/2017/07/20/记录那些经常用却又打死记不住的代码/"><i class="icon icon-arror-left"></i></a></li><li><a href="/2017/07/17/《Android进阶之光》读书笔记（二）/"><i class="icon icon-arror-right"></i></a></li></ul><div class="page-footer"><div class="top"><ul class="social"><li><a href="https://github.com/earthWo" title="Github" target="_blank"><i class="icon icon-github"></i></a></li></ul></div><div class="bottom"><p class="copyright">© 2020 alonealice<br><small><a href="http://www.beian.miit.gov.cn" target="_blank">浙ICP备17033688号</a></small><small>, THEME BY <a href="https://github.com/BoizZ/hexo-theme-laughing" target="_blank">LAUGHING</a></small></p></div></div></div><script>var wrap = document.getElementById('wrap');
window.onload = function () {
  wrap.className += ' done';
}</script></body></html>