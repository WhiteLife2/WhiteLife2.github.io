<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="不懂要会问，打脸要立正">
    <meta name="keyword"  content="">
    <link rel="shortcut icon" href="/img/ironman-draw.png">
    <!-- Place this tag in your head or just before your close body tag. -->
    <script async defer src="https://buttons.github.io/buttons.js"></script>
    <title>
        
          Flutter入门：自定义组件和事件 - alonealice | Blog
        
    </title>

    <link rel="canonical" href="http://alonealice.com/Flutter/Flutter入门：自定义组件和事件/">

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="/css/bootstrap.min.css">

    <!-- Custom CSS --> 
    <link rel="stylesheet" href="/css/beantech.min.css">

    <link rel="stylesheet" href="/css/donate.css">
    
    <!-- Pygments Highlight CSS -->
    <link rel="stylesheet" href="/css/highlight.css">

    <link rel="stylesheet" href="/css/widget.css">

    <link rel="stylesheet" href="/css/rocket.css">

    <link rel="stylesheet" href="/css/signature.css">

    <link rel="stylesheet" href="/css/toc.css">

    <!-- Custom Fonts -->
    <!-- <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"> -->
    <!-- Hux change font-awesome CDN to qiniu -->
    <link href="https://cdn.staticfile.org/font-awesome/4.5.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">


    <!-- Hux Delete, sad but pending in China
    <link href='http://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
    <link href='http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/
    css'>
    -->


    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- ga & ba script hoook -->
    <script></script>
</head>


<!-- hack iOS CSS :active style -->
<body ontouchstart="">
	<!-- Modified by Yu-Hsuan Yen -->
<!-- Post Header -->
<style type="text/css">
    header.intro-header{
        
            background-image: url('/img/article_header/article_bg.jpeg')
            /*post*/
        
    }
    
</style>

<header class="intro-header" >
    <!-- Signature -->
    <div id="signature">
        <div class="container">
            <div class="row">
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                
                    <div class="post-heading">
                        <div class="tags">
                            
                              <a class="tag" href="/tags/#Flutter" title="Flutter">Flutter</a>
                            
                        </div>
                        <h1>Flutter入门：自定义组件和事件</h1>
                        <h2 class="subheading"></h2>
                        <span class="meta">
                            Posted by alonealice on
                            2021-01-07
                        </span>
                    </div>
                


                </div>
            </div>
        </div>
    </div>
</header>

	
    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">alonealice</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <!-- Known Issue, found by Hux:
            <nav>'s height woule be hold on by its content.
            so, when navbar scale out, the <nav> will cover tags.
            also mask any touch event of tags, unfortunately.
        -->
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/">Home</a>
                    </li>

                    

                        
                    

                        
                        <li>
                            <a href="/archive/">Archives</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/about/">About</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/tags/">Tags</a>
                        </li>
                        
                    
                    
                </ul>
            </div>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>
<script>
    // Drop Bootstarp low-performance Navbar
    // Use customize navbar with high-quality material design animation
    // in high-perf jank-free CSS3 implementation
    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    $toggle.addEventListener('click', handleMagic)
    function handleMagic(e){
        if ($navbar.className.indexOf('in') > 0) {
        // CLOSE
            $navbar.className = " ";
            // wait until animation end.
            setTimeout(function(){
                // prevent frequently toggle
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        }else{
        // OPEN
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }
</script>


    <!-- Main Content -->
    <!-- Modify by Yu-Hsuan Yen -->

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

            <!-- Post Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                post-container">

                <h2 id="自定义组件">自定义组件</h2>
<h4 id="组合其它widget">组合其它Widget</h4>
<p>这种方式是通过拼装其它组件来组合成一个新的组件。例如我们之前介绍的<code>Container</code>就是一个组合组件，它是由<code>DecoratedBox</code>、<code>ConstrainedBox</code>、<code>Transform</code>、<code>Padding</code>、<code>Align</code>等组件组成。</p>
<p>在Flutter中，组合的思想非常重要，Flutter提供了非常多的基础组件，而我们的界面开发其实就是按照需要组合这些组件来实现各种不同的布局而已。</p>
<h5 id="示例自定义渐变按钮">示例：自定义渐变按钮</h5>
<p>Flutter Material组件库中的按钮默认不支持渐变背景，为了实现渐变背景按钮，我们自定义一个<code>GradientButton</code>组件，它需要支持一下功能：</p>
<ol>
<li>背景支持渐变色</li>
<li>手指按下时有涟漪效果</li>
<li>可以支持圆角</li>
</ol>
<p>我们<code>DecoratedBox</code>可以支持背景色渐变和圆角，<code>InkWell</code>在手指按下有涟漪效果，所以我们可以通过组合<code>DecoratedBox</code>和<code>InkWell</code>来实现<code>GradientButton</code>，代码如下：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GradientButton</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  GradientButton(&#123;</span><br><span class="line">    <span class="keyword">this</span>.colors,</span><br><span class="line">    <span class="keyword">this</span>.width,</span><br><span class="line">    <span class="keyword">this</span>.height,</span><br><span class="line">    <span class="keyword">this</span>.onPressed,</span><br><span class="line">    <span class="keyword">this</span>.borderRadius,</span><br><span class="line">    <span class="meta">@required</span> <span class="keyword">this</span>.child,</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 渐变色数组</span></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">List</span>&lt;Color&gt; colors;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 按钮宽高</span></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">double</span> width;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">double</span> height;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> Widget child;</span><br><span class="line">  <span class="keyword">final</span> BorderRadius borderRadius;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//点击回调</span></span><br><span class="line">  <span class="keyword">final</span> GestureTapCallback onPressed;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    ThemeData theme = Theme.of(context);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//确保colors数组不空</span></span><br><span class="line">    <span class="built_in">List</span>&lt;Color&gt; _colors = colors ??</span><br><span class="line">        [theme.primaryColor, theme.primaryColorDark ?? theme.primaryColor];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> DecoratedBox(</span><br><span class="line">      decoration: BoxDecoration(</span><br><span class="line">        gradient: LinearGradient(colors: _colors),</span><br><span class="line">        borderRadius: borderRadius,</span><br><span class="line">      ),</span><br><span class="line">      child: Material(</span><br><span class="line">        type: MaterialType.transparency,</span><br><span class="line">        child: InkWell(</span><br><span class="line">          splashColor: _colors.last,</span><br><span class="line">          highlightColor: Colors.transparent,</span><br><span class="line">          borderRadius: borderRadius,</span><br><span class="line">          onTap: onPressed,</span><br><span class="line">          child: ConstrainedBox(</span><br><span class="line">            constraints: BoxConstraints.tightFor(height: height, width: width),</span><br><span class="line">            child: Center(</span><br><span class="line">              child: Padding(</span><br><span class="line">                padding: <span class="keyword">const</span> EdgeInsets.all(<span class="number">8.0</span>),</span><br><span class="line">                child: DefaultTextStyle(</span><br><span class="line">                  style: TextStyle(fontWeight: FontWeight.bold),</span><br><span class="line">                  child: child,</span><br><span class="line">                ),</span><br><span class="line">              ),</span><br><span class="line">            ),</span><br><span class="line">          ),</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到<code>GradientButton</code>是由<code>DecoratedBox</code>、<code>Padding</code>、<code>Center</code>、<code>InkWell</code>等组件组合而成。当然上面的代码只是一个示例，作为一个按钮它还并不完整，比如没有禁用状态，读者可以根据实际需要来完善。</p>
<p>使用GradientButton：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'../widgets/index.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GradientButtonRoute</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _GradientButtonRouteState createState() =&gt; _GradientButtonRouteState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_GradientButtonRouteState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">GradientButtonRoute</span>&gt; </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Container(</span><br><span class="line">      child: Column(</span><br><span class="line">        children: &lt;Widget&gt;[</span><br><span class="line">          GradientButton(</span><br><span class="line">            colors: [Colors.orange, Colors.red],</span><br><span class="line">            height: <span class="number">50.0</span>,</span><br><span class="line">            child: Text(<span class="string">"Submit"</span>),</span><br><span class="line">            onPressed: onTap,</span><br><span class="line">          ),</span><br><span class="line">          GradientButton(</span><br><span class="line">            height: <span class="number">50.0</span>,</span><br><span class="line">            colors: [Colors.lightGreen, Colors.green[<span class="number">700</span>]],</span><br><span class="line">            child: Text(<span class="string">"Submit"</span>),</span><br><span class="line">            onPressed: onTap,</span><br><span class="line">          ),</span><br><span class="line">          GradientButton(</span><br><span class="line">            height: <span class="number">50.0</span>,</span><br><span class="line">            colors: [Colors.lightBlue[<span class="number">300</span>], Colors.blueAccent],</span><br><span class="line">            child: Text(<span class="string">"Submit"</span>),</span><br><span class="line">            onPressed: onTap,</span><br><span class="line">          ),</span><br><span class="line">        ],</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  onTap() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"button click"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="自绘">自绘</h4>
<p>如果遇到无法通过现有的组件来实现需要的UI时，我们可以通过自绘组件的方式来实现，例如我们需要一个颜色渐变的圆形进度条，而Flutter提供的<code>CircularProgressIndicator</code>并不支持在显示精确进度时对进度条应用渐变色（其<code>valueColor</code> 属性只支持执行旋转动画时变化Indicator的颜色），这时最好的方法就是通过自定义组件来绘制出我们期望的外观。我们可以通过Flutter中提供的<code>CustomPaint</code>和<code>Canvas</code>来实现UI自绘。</p>
<h5 id="custompaint">CustomPaint</h5>
<p><code>CustomPaint</code>构造函数：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CustomPaint(&#123;</span><br><span class="line">  Key key,</span><br><span class="line">  <span class="keyword">this</span>.painter, </span><br><span class="line">  <span class="keyword">this</span>.foregroundPainter,</span><br><span class="line">  <span class="keyword">this</span>.size = Size.zero, </span><br><span class="line">  <span class="keyword">this</span>.isComplex = <span class="keyword">false</span>, </span><br><span class="line">  <span class="keyword">this</span>.willChange = <span class="keyword">false</span>, </span><br><span class="line">  Widget child, <span class="comment">//子节点，可以为空</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li><code>painter</code>: 背景画笔，会显示在子节点后面;</li>
<li><code>foregroundPainter</code>: 前景画笔，会显示在子节点前面</li>
<li><code>size</code>：当child为null时，代表默认绘制区域大小，如果有child则忽略此参数，画布尺寸则为child尺寸。如果有child但是想指定画布为特定大小，可以使用SizeBox包裹CustomPaint实现。</li>
<li><code>isComplex</code>：是否复杂的绘制，如果是，Flutter会应用一些缓存策略来减少重复渲染的开销。</li>
<li><code>willChange</code>：和<code>isComplex</code>配合使用，当启用缓存时，该属性代表在下一帧中绘制是否会改变。</li>
</ul>
<p>可以看到，绘制时我们需要提供前景或背景画笔，两者也可以同时提供。我们的画笔需要继承<code>CustomPainter</code>类，我们在画笔类中实现真正的绘制逻辑。</p>
<p>如果<code>CustomPaint</code>有子节点，为了避免子节点不必要的重绘并提高性能，通常情况下都会将子节点包裹在<code>RepaintBoundary</code>组件中，这样会在绘制时就会创建一个新的绘制层（Layer），其子组件将在新的Layer上绘制，而父组件将在原来Layer上绘制，也就是说<code>RepaintBoundary</code> 子组件的绘制将独立于父组件的绘制，<code>RepaintBoundary</code>会隔离其子节点和<code>CustomPaint</code>本身的绘制边界。示例如下：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CustomPaint(</span><br><span class="line">  size: Size(<span class="number">300</span>, <span class="number">300</span>), <span class="comment">//指定画布大小</span></span><br><span class="line">  painter: MyPainter(),</span><br><span class="line">  child: RepaintBoundary(child:...)), </span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h5 id="custompainter">CustomPainter</h5>
<p><code>CustomPainter</code>中提定义了一个虚函数<code>paint</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void paint(Canvas canvas, Size size);</span><br></pre></td></tr></table></figure>
<p><code>paint</code>有两个参数:</p>
<ul>
<li>
<p><code>Canvas</code>：一个画布，包括各种绘制方法，我们列出一下常用的方法：</p>
<p>|API名称 | 功能 | | ---------- | ------ | | drawLine | 画线 | | drawPoint | 画点 | | drawPath | 画路径 | | drawImage | 画图像 | | drawRect | 画矩形 | | drawCircle | 画圆 | | drawOval | 画椭圆 | | drawArc | 画圆弧 |</p>
</li>
<li>
<p><code>Size</code>：当前绘制区域大小。</p>
</li>
</ul>
<h5 id="画笔paint">画笔Paint</h5>
<p>现在画布有了，我们最后还缺一个画笔，Flutter提供了<code>Paint</code>类来实现画笔。在<code>Paint</code>中，我们可以配置画笔的各种属性如粗细、颜色、样式等。如：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> paint = Paint() <span class="comment">//创建一个画笔并配置其属性</span></span><br><span class="line">  ..isAntiAlias = <span class="keyword">true</span> <span class="comment">//是否抗锯齿</span></span><br><span class="line">  ..style = PaintingStyle.fill <span class="comment">//画笔样式：填充</span></span><br><span class="line">  ..color=Color(<span class="number">0x77cdb175</span>);<span class="comment">//画笔颜色</span></span><br></pre></td></tr></table></figure>
<h5 id="示例五子棋盘">示例：五子棋/盘</h5>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'dart:math'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomPaintRoute</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Center(</span><br><span class="line">      child: CustomPaint(</span><br><span class="line">        size: Size(<span class="number">300</span>, <span class="number">300</span>), <span class="comment">//指定画布大小</span></span><br><span class="line">        painter: MyPainter(),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPainter</span> <span class="keyword">extends</span> <span class="title">CustomPainter</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> paint(Canvas canvas, Size size) &#123;</span><br><span class="line">    <span class="built_in">double</span> eWidth = size.width / <span class="number">15</span>;</span><br><span class="line">    <span class="built_in">double</span> eHeight = size.height / <span class="number">15</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//画棋盘背景</span></span><br><span class="line">    <span class="keyword">var</span> paint = Paint()</span><br><span class="line">      ..isAntiAlias = <span class="keyword">true</span></span><br><span class="line">      ..style = PaintingStyle.fill <span class="comment">//填充</span></span><br><span class="line">      ..color = Color(<span class="number">0x77cdb175</span>); <span class="comment">//背景为纸黄色</span></span><br><span class="line">    canvas.drawRect(Offset.zero &amp; size, paint);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//画棋盘网格</span></span><br><span class="line">    paint</span><br><span class="line">      ..style = PaintingStyle.stroke <span class="comment">//线</span></span><br><span class="line">      ..color = Colors.black87</span><br><span class="line">      ..strokeWidth = <span class="number">1.0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">15</span>; ++i) &#123;</span><br><span class="line">      <span class="built_in">double</span> dy = eHeight * i;</span><br><span class="line">      canvas.drawLine(Offset(<span class="number">0</span>, dy), Offset(size.width, dy), paint);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">15</span>; ++i) &#123;</span><br><span class="line">      <span class="built_in">double</span> dx = eWidth * i;</span><br><span class="line">      canvas.drawLine(Offset(dx, <span class="number">0</span>), Offset(dx, size.height), paint);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//画一个黑子</span></span><br><span class="line">    paint</span><br><span class="line">      ..style = PaintingStyle.fill</span><br><span class="line">      ..color = Colors.black;</span><br><span class="line">    canvas.drawCircle(</span><br><span class="line">      Offset(size.width / <span class="number">2</span> - eWidth / <span class="number">2</span>, size.height / <span class="number">2</span> - eHeight / <span class="number">2</span>),</span><br><span class="line">      min(eWidth / <span class="number">2</span>, eHeight / <span class="number">2</span>) - <span class="number">2</span>,</span><br><span class="line">      paint,</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">//画一个白子</span></span><br><span class="line">    paint.color = Colors.white;</span><br><span class="line">    canvas.drawCircle(</span><br><span class="line">      Offset(size.width / <span class="number">2</span> + eWidth / <span class="number">2</span>, size.height / <span class="number">2</span> - eHeight / <span class="number">2</span>),</span><br><span class="line">      min(eWidth / <span class="number">2</span>, eHeight / <span class="number">2</span>) - <span class="number">2</span>,</span><br><span class="line">      paint,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//在实际场景中正确利用此回调可以避免重绘开销，本示例我们简单的返回true</span></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">bool</span> shouldRepaint(CustomPainter oldDelegate) =&gt; <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>绘制是比较昂贵的操作，所以我们在实现自绘控件时应该考虑到性能开销，下面是两条关于性能优化的建议：</p>
<ul>
<li>尽可能的利用好<code>shouldRepaint</code>返回值；在UI树重新build时，控件在绘制前都会先调用该方法以确定是否有必要重绘；假如我们绘制的UI不依赖外部状态，那么就应该始终返回<code>false</code>，因为外部状态改变导致重新build时不会影响我们的UI外观；如果绘制依赖外部状态，那么我们就应该在<code>shouldRepaint</code>中判断依赖的状态是否改变，如果已改变则应返回<code>true</code>来重绘，反之则应返回<code>false</code>不需要重绘。</li>
<li>绘制尽可能多的分层；在上面五子棋的示例中，我们将棋盘和棋子的绘制放在了一起，这样会有一个问题：由于棋盘始终是不变的，用户每次落子时变的只是棋子，但是如果按照上面的代码来实现，每次绘制棋子时都要重新绘制一次棋盘，这是没必要的。优化的方法就是将棋盘单独抽为一个组件，并设置其<code>shouldRepaint</code>回调值为<code>false</code>，然后将棋盘组件作为背景。然后将棋子的绘制放到另一个组件中，这样每次落子时只需要绘制棋子。</li>
</ul>
<h3 id="实现renderobject">实现RenderObject</h3>
<p>Flutter提供的自身具有UI外观的组件，如文本<code>Text</code>、<code>Image</code>都是通过相应的<code>RenderObject</code>渲染出来的，如Text是由<code>RenderParagraph</code>渲染；而<code>Image</code>是由<code>RenderImage</code>渲染。<code>RenderObject</code>是一个抽象类，它定义了一个抽象方法<code>paint(...)</code>：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> paint(PaintingContext context, Offset offset)</span><br></pre></td></tr></table></figure>
<p><code>PaintingContext</code>代表组件的绘制上下文，通过<code>PaintingContext.canvas</code>可以获得<code>Canvas</code>，而绘制逻辑主要是通过<code>Canvas</code> API来实现。子类需要重写此方法以实现自身的绘制逻辑，如<code>RenderParagraph</code>需要实现文本绘制逻辑，而<code>RenderImage</code>需要实现图片绘制逻辑。</p>
<p>可以发现，<code>RenderObject</code>中最终也是通过<code>Canvas</code> API来绘制的，那么通过实现<code>RenderObject</code>的方式和上面介绍的通过<code>CustomPaint</code>和<code>Canvas</code>自绘的方式有什么区别？其实答案很简单，<code>CustomPaint</code>只是为了方便开发者封装的一个代理类，它直接继承自<code>SingleChildRenderObjectWidget</code>，通过<code>RenderCustomPaint</code>的<code>paint</code>方法将<code>Canvas</code>和画笔<code>Painter</code>(需要开发者实现，后面章节介绍)连接起来实现了最终的绘制（绘制逻辑在<code>Painter</code>中）。</p>
<h2 id="事件">事件</h2>
<h4 id="触摸事件">触摸事件</h4>
<p>Flutter中可以使用<code>Listener</code>来监听原始触摸事件</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Listener(&#123;</span><br><span class="line">  Key key,</span><br><span class="line">  <span class="keyword">this</span>.onPointerDown, <span class="comment">//手指按下回调</span></span><br><span class="line">  <span class="keyword">this</span>.onPointerMove, <span class="comment">//手指移动回调</span></span><br><span class="line">  <span class="keyword">this</span>.onPointerUp,<span class="comment">//手指抬起回调</span></span><br><span class="line">  <span class="keyword">this</span>.onPointerCancel,<span class="comment">//触摸事件取消回调</span></span><br><span class="line">  <span class="keyword">this</span>.behavior = HitTestBehavior.deferToChild, <span class="comment">//在命中测试期间如何表现</span></span><br><span class="line">  Widget child</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">PointerEvent _event;</span><br><span class="line">...</span><br><span class="line">Listener(</span><br><span class="line">  child: Container(</span><br><span class="line">    alignment: Alignment.center,</span><br><span class="line">    color: Colors.blue,</span><br><span class="line">    width: <span class="number">300.0</span>,</span><br><span class="line">    height: <span class="number">150.0</span>,</span><br><span class="line">    child: Text(_event?.toString()??<span class="string">""</span>,style: TextStyle(color: Colors.white)),</span><br><span class="line">  ),</span><br><span class="line">  onPointerDown: (PointerDownEvent event) =&gt; setState(()=&gt;_event=event),</span><br><span class="line">  onPointerMove: (PointerMoveEvent event) =&gt; setState(()=&gt;_event=event),</span><br><span class="line">  onPointerUp: (PointerUpEvent event) =&gt; setState(()=&gt;_event=event),</span><br><span class="line">),</span><br></pre></td></tr></table></figure>
<p><code>PointerDownEvent</code>、<code>PointerMoveEvent</code>、<code>PointerUpEvent</code>都是<code>PointerEvent</code>的一个子类，<code>PointerEvent</code>类中包括当前指针的一些信息，如：</p>
<ul>
<li><code>position</code>：它是鼠标相对于当对于全局坐标的偏移。</li>
<li><code>delta</code>：两次指针移动事件（<code>PointerMoveEvent</code>）的距离。</li>
<li><code>pressure</code>：按压力度，如果手机屏幕支持压力传感器(如iPhone的3D Touch)，此属性会更有意义，如果手机不支持，则始终为1。</li>
<li><code>orientation</code>：指针移动方向，是一个角度值。</li>
</ul>
<p>点来介绍一下<code>behavior</code>属性，它决定子组件如何响应命中测试，它的值类型为<code>HitTestBehavior</code>，这是一个枚举类，有三个枚举值：</p>
<ul>
<li><code>deferToChild</code>：子组件会一个接一个的进行命中测试，如果子组件中有测试通过的，则当前组件通过，这就意味着，如果指针事件作用于子组件上时，其父级组件也肯定可以收到该事件。</li>
<li><code>opaque</code>：在命中测试时，将当前组件当成不透明处理(即使本身是透明的)，最终的效果相当于当前Widget的整个区域都是点击区域。</li>
<li><code>translucent</code>：当点击组件透明区域时，可以对自身边界内及底部可视区域都进行命中测试，这意味着点击顶部组件透明区域时，顶部组件和底部组件都可以接收到事件</li>
</ul>
<h5 id="忽略pointerevent">忽略PointerEvent</h5>
<p>我们可以使用<code>IgnorePointer</code>和<code>AbsorbPointer</code>，这两个组件都能阻止子树接收指针事件，不同之处在于<code>AbsorbPointer</code>本身会参与命中测试，而<code>IgnorePointer</code>本身不会参与，这就意味着<code>AbsorbPointer</code>本身是可以接收指针事件的(但其子树不行)，而<code>IgnorePointer</code>不可以。一个简单的例子如下：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Listener(</span><br><span class="line">  child: AbsorbPointer(</span><br><span class="line">    child: Listener(</span><br><span class="line">      child: Container(</span><br><span class="line">        color: Colors.red,</span><br><span class="line">        width: <span class="number">200.0</span>,</span><br><span class="line">        height: <span class="number">100.0</span>,</span><br><span class="line">      ),</span><br><span class="line">      onPointerDown: (event)=&gt;<span class="built_in">print</span>(<span class="string">"in"</span>),</span><br><span class="line">    ),</span><br><span class="line">  ),</span><br><span class="line">  onPointerDown: (event)=&gt;<span class="built_in">print</span>(<span class="string">"up"</span>),</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>点击<code>Container</code>时，由于它在<code>AbsorbPointer</code>的子树上，所以不会响应指针事件，所以日志不会输出&quot;in&quot;，但<code>AbsorbPointer</code>本身是可以接收指针事件的，所以会输出&quot;up&quot;。如果将<code>AbsorbPointer</code>换成<code>IgnorePointer</code>，那么两个都不会输出。</p>
<h3 id="手势识别">手势识别</h3>
<p>Flutter中使用<code>GestureDetector</code>和<code>GestureRecognizer</code> 处理手势。</p>
<h4 id="gesturedetector">GestureDetector</h4>
<p><code>GestureDetector</code>是一个用于手势识别的功能性组件，我们通过它可以来识别各种手势。<code>GestureDetector</code>实际上是指针事件的语义化封装</p>
<h5 id="点击-双击-长按">点击、双击、长按</h5>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GestureDetectorTestRoute</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _GestureDetectorTestRouteState createState() =&gt;</span><br><span class="line">      <span class="keyword">new</span> _GestureDetectorTestRouteState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_GestureDetectorTestRouteState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">GestureDetectorTestRoute</span>&gt; </span>&#123;</span><br><span class="line">  <span class="built_in">String</span> _operation = <span class="string">"No Gesture detected!"</span>; <span class="comment">//保存事件名</span></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Center(</span><br><span class="line">      child: GestureDetector(</span><br><span class="line">        child: Container(</span><br><span class="line">          alignment: Alignment.center,</span><br><span class="line">          color: Colors.blue,</span><br><span class="line">          width: <span class="number">200.0</span>, </span><br><span class="line">          height: <span class="number">100.0</span>,</span><br><span class="line">          child: Text(_operation,</span><br><span class="line">            style: TextStyle(color: Colors.white),</span><br><span class="line">          ),</span><br><span class="line">        ),</span><br><span class="line">        onTap: () =&gt; updateText(<span class="string">"Tap"</span>),<span class="comment">//点击</span></span><br><span class="line">        onDoubleTap: () =&gt; updateText(<span class="string">"DoubleTap"</span>), <span class="comment">//双击</span></span><br><span class="line">        onLongPress: () =&gt; updateText(<span class="string">"LongPress"</span>), <span class="comment">//长按</span></span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> updateText(<span class="built_in">String</span> text) &#123;</span><br><span class="line">    <span class="comment">//更新显示的事件名</span></span><br><span class="line">    setState(() &#123;</span><br><span class="line">      _operation = text;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="拖动-滑动">拖动、滑动</h5>
<p>一次完整的手势过程是指用户手指按下到抬起的整个过程，期间，用户按下手指后可能会移动，也可能不会移动。<code>GestureDetector</code>对于拖动和滑动事件是没有区分的，他们本质上是一样的。<code>GestureDetector</code>会将要监听的组件的原点（左上角）作为本次手势的原点，当用户在监听的组件上按下手指时，手势识别就会开始</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_Drag</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _DragState createState() =&gt; <span class="keyword">new</span> _DragState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_DragState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">_Drag</span>&gt; <span class="title">with</span> <span class="title">SingleTickerProviderStateMixin</span> </span>&#123;</span><br><span class="line">  <span class="built_in">double</span> _top = <span class="number">0.0</span>; <span class="comment">//距顶部的偏移</span></span><br><span class="line">  <span class="built_in">double</span> _left = <span class="number">0.0</span>;<span class="comment">//距左边的偏移</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Stack(</span><br><span class="line">      children: &lt;Widget&gt;[</span><br><span class="line">        Positioned(</span><br><span class="line">          top: _top,</span><br><span class="line">          left: _left,</span><br><span class="line">          child: GestureDetector(</span><br><span class="line">            child: CircleAvatar(child: Text(<span class="string">"A"</span>)),</span><br><span class="line">            <span class="comment">//手指按下时会触发此回调</span></span><br><span class="line">            onPanDown: (DragDownDetails e) &#123;</span><br><span class="line">              <span class="comment">//打印手指按下的位置(相对于屏幕)</span></span><br><span class="line">              <span class="built_in">print</span>(<span class="string">"用户手指按下：<span class="subst">$&#123;e.globalPosition&#125;</span>"</span>);</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="comment">//手指滑动时会触发此回调</span></span><br><span class="line">            onPanUpdate: (DragUpdateDetails e) &#123;</span><br><span class="line">              <span class="comment">//用户手指滑动时，更新偏移，重新构建</span></span><br><span class="line">              setState(() &#123;</span><br><span class="line">                _left += e.delta.dx;</span><br><span class="line">                _top += e.delta.dy;</span><br><span class="line">              &#125;);</span><br><span class="line">            &#125;,</span><br><span class="line">            onPanEnd: (DragEndDetails e)&#123;</span><br><span class="line">              <span class="comment">//打印滑动结束时在x、y轴上的速度</span></span><br><span class="line">              <span class="built_in">print</span>(e.velocity);</span><br><span class="line">            &#125;,</span><br><span class="line">          ),</span><br><span class="line">        )</span><br><span class="line">      ],</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>DragDownDetails.globalPosition</code>：当用户按下时，此属性为用户按下的位置相对于<strong>屏幕</strong>（而非父组件）原点(左上角)的偏移。</li>
<li><code>DragUpdateDetails.delta</code>：当用户在屏幕上滑动时，会触发多次Update事件，<code>delta</code>指一次Update事件的滑动的偏移量。</li>
<li><code>DragEndDetails.velocity</code>：该属性代表用户抬起手指时的滑动速度(包含x、y两个轴的），示例中并没有处理手指抬起时的速度，常见的效果是根据用户抬起手指时的速度做一个减速动画。</li>
</ul>
<h4 id="gesturerecognizer">GestureRecognizer</h4>
<p><code>GestureDetector</code>内部是使用一个或多个<code>GestureRecognizer</code>来识别各种手势的，而<code>GestureRecognizer</code>的作用就是通过<code>Listener</code>来将原始指针事件转换为语义手势，<code>GestureDetector</code>直接可以接收一个子widget。<code>GestureRecognizer</code>是一个抽象类，一种手势的识别器对应一个<code>GestureRecognizer</code>的子类，Flutter实现了丰富的手势识别器，我们可以直接使用。</p>
<p>示例:</p>
<p>假设我们要给一段富文本（<code>RichText</code>）的不同部分分别添加点击事件处理器，但是<code>TextSpan</code>并不是一个widget，这时我们不能用<code>GestureDetector</code>，但<code>TextSpan</code>有一个<code>recognizer</code>属性，它可以接收一个<code>GestureRecognizer</code>。</p>
<p>假设我们需要在点击时给文本变色:</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/gestures.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_GestureRecognizerTestRouteState</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">_GestureRecognizerTestRoute</span>&gt; </span>&#123;</span><br><span class="line">  TapGestureRecognizer _tapGestureRecognizer = <span class="keyword">new</span> TapGestureRecognizer();</span><br><span class="line">  <span class="built_in">bool</span> _toggle = <span class="keyword">false</span>; <span class="comment">//变色开关</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> dispose() &#123;</span><br><span class="line">     <span class="comment">//用到GestureRecognizer的话一定要调用其dispose方法释放资源</span></span><br><span class="line">    _tapGestureRecognizer.dispose();</span><br><span class="line">    <span class="keyword">super</span>.dispose();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Center(</span><br><span class="line">      child: Text.rich(</span><br><span class="line">          TextSpan(</span><br><span class="line">              children: [</span><br><span class="line">                TextSpan(text: <span class="string">"你好世界"</span>),</span><br><span class="line">                TextSpan(</span><br><span class="line">                  text: <span class="string">"点我变色"</span>,</span><br><span class="line">                  style: TextStyle(</span><br><span class="line">                      fontSize: <span class="number">30.0</span>,</span><br><span class="line">                      color: _toggle ? Colors.blue : Colors.red</span><br><span class="line">                  ),</span><br><span class="line">                  recognizer: _tapGestureRecognizer</span><br><span class="line">                    ..onTap = () &#123;</span><br><span class="line">                      setState(() &#123;</span><br><span class="line">                        _toggle = !_toggle;</span><br><span class="line">                      &#125;);</span><br><span class="line">                    &#125;,</span><br><span class="line">                ),</span><br><span class="line">                TextSpan(text: <span class="string">"你好世界"</span>),</span><br><span class="line">              ]</span><br><span class="line">          )</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="手势竞争与冲突">手势竞争与冲突</h4>
<h5 id="竞争">竞争</h5>
<p>如果在上例中我们同时监听水平和垂直方向的拖动事件，那么我们斜着拖动时哪个方向会生效？实际上取决于第一次移动时两个轴上的位移分量，哪个轴的大，哪个轴在本次滑动事件竞争中就胜出。实际上Flutter中的手势识别引入了一个Arena的概念，Arena直译为“竞技场”的意思，每一个手势识别器（<code>GestureRecognizer</code>）都是一个“竞争者”（<code>GestureArenaMember</code>），当发生滑动事件时，他们都要在“竞技场”去竞争本次事件的处理权，而最终只有一个“竞争者”会胜出(win)。例如，假设有一个<code>ListView</code>，它的第一个子组件也是<code>ListView</code>，如果现在滑动这个子<code>ListView</code>，父<code>ListView</code>会动吗？答案是否定的，这时只有子<code>ListView</code>会动，因为这时子<code>ListView</code>会胜出而获得滑动事件的处理权。</p>
<p>我们以拖动手势为例，同时识别水平和垂直方向的拖动手势，当用户按下手指时就会触发竞争（水平方向和垂直方向），一旦某个方向“获胜”，则直到当次拖动手势结束都会沿着该方向移动。代码如下：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BothDirectionTestRoute</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  BothDirectionTestRouteState createState() =&gt;</span><br><span class="line">      <span class="keyword">new</span> BothDirectionTestRouteState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BothDirectionTestRouteState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">BothDirectionTestRoute</span>&gt; </span>&#123;</span><br><span class="line">  <span class="built_in">double</span> _top = <span class="number">0.0</span>;</span><br><span class="line">  <span class="built_in">double</span> _left = <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Stack(</span><br><span class="line">      children: &lt;Widget&gt;[</span><br><span class="line">        Positioned(</span><br><span class="line">          top: _top,</span><br><span class="line">          left: _left,</span><br><span class="line">          child: GestureDetector(</span><br><span class="line">            child: CircleAvatar(child: Text(<span class="string">"A"</span>)),</span><br><span class="line">            <span class="comment">//垂直方向拖动事件</span></span><br><span class="line">            onVerticalDragUpdate: (DragUpdateDetails details) &#123;</span><br><span class="line">              setState(() &#123;</span><br><span class="line">                _top += details.delta.dy;</span><br><span class="line">              &#125;);</span><br><span class="line">            &#125;,</span><br><span class="line">            onHorizontalDragUpdate: (DragUpdateDetails details) &#123;</span><br><span class="line">              setState(() &#123;</span><br><span class="line">                _left += details.delta.dx;</span><br><span class="line">              &#125;);</span><br><span class="line">            &#125;,</span><br><span class="line">          ),</span><br><span class="line">        )</span><br><span class="line">      ],</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此示例运行后，每次拖动只会沿一个方向移动（水平或垂直），而竞争发生在手指按下后首次移动（move）时，此例中具体的“获胜”条件是：首次移动时的位移在水平和垂直方向上的分量大的一个获胜。</p>
<h5 id="手势冲突">手势冲突</h5>
<p>由于手势竞争最终只有一个胜出者，所以，当有多个手势识别器时，可能会产生冲突。假设有一个widget，它可以左右拖动，现在我们也想检测在它上面手指按下和抬起的事件，代码如下：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GestureConflictTestRouteState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">GestureConflictTestRoute</span>&gt; </span>&#123;</span><br><span class="line">  <span class="built_in">double</span> _left = <span class="number">0.0</span>;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Stack(</span><br><span class="line">      children: &lt;Widget&gt;[</span><br><span class="line">        Positioned(</span><br><span class="line">          left: _left,</span><br><span class="line">          child: GestureDetector(</span><br><span class="line">              child: CircleAvatar(child: Text(<span class="string">"A"</span>)), <span class="comment">//要拖动和点击的widget</span></span><br><span class="line">              onHorizontalDragUpdate: (DragUpdateDetails details) &#123;</span><br><span class="line">                setState(() &#123;</span><br><span class="line">                  _left += details.delta.dx;</span><br><span class="line">                &#125;);</span><br><span class="line">              &#125;,</span><br><span class="line">              onHorizontalDragEnd: (details)&#123;</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">"onHorizontalDragEnd"</span>);</span><br><span class="line">              &#125;,</span><br><span class="line">              onTapDown: (details)&#123;</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">"down"</span>);</span><br><span class="line">              &#125;,</span><br><span class="line">              onTapUp: (details)&#123;</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">"up"</span>);</span><br><span class="line">              &#125;,</span><br><span class="line">          ),</span><br><span class="line">        )</span><br><span class="line">      ],</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们如果在外部再用<code>onTapDown</code>、<code>onTapUp</code>来监听的话</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Positioned(</span><br><span class="line">  top:<span class="number">80.0</span>,</span><br><span class="line">  left: _leftB,</span><br><span class="line">  child: Listener(</span><br><span class="line">    onPointerDown: (details) &#123;</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">"down"</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    onPointerUp: (details) &#123;</span><br><span class="line">      <span class="comment">//会触发</span></span><br><span class="line">      <span class="built_in">print</span>(<span class="string">"up"</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    child: GestureDetector(</span><br><span class="line">      child: CircleAvatar(child: Text(<span class="string">"B"</span>)),</span><br><span class="line">      onHorizontalDragUpdate: (DragUpdateDetails details) &#123;</span><br><span class="line">        setState(() &#123;</span><br><span class="line">          _leftB += details.delta.dx;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;,</span><br><span class="line">      onHorizontalDragEnd: (details) &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"onHorizontalDragEnd"</span>);</span><br><span class="line">      &#125;,</span><br><span class="line">    ),</span><br><span class="line">  ),</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h3 id="事件总线">事件总线</h3>
<p>在APP中，我们经常会需要一个广播机制，用以跨页面事件通知，比如一个需要登录的APP中，页面会关注用户登录或注销事件，来进行一些状态更新。这时候，一个事件总线便会非常有用，事件总线通常实现了订阅者模式，订阅者模式包含发布者和订阅者两种角色，可以通过事件总线来触发事件和监听事件</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//订阅者回调签名</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> EventCallback(arg);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventBus</span> </span>&#123;</span><br><span class="line">  <span class="comment">//私有构造函数</span></span><br><span class="line">  EventBus._internal();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//保存单例</span></span><br><span class="line">  <span class="keyword">static</span> EventBus _singleton = <span class="keyword">new</span> EventBus._internal();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//工厂构造函数</span></span><br><span class="line">  <span class="keyword">factory</span> EventBus()=&gt; _singleton;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//保存事件订阅者队列，key:事件名(id)，value: 对应事件的订阅者队列</span></span><br><span class="line">  <span class="keyword">var</span> _emap = <span class="keyword">new</span> <span class="built_in">Map</span>&lt;<span class="built_in">Object</span>, <span class="built_in">List</span>&lt;EventCallback&gt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//添加订阅者</span></span><br><span class="line">  <span class="keyword">void</span> on(eventName, EventCallback f) &#123;</span><br><span class="line">    <span class="keyword">if</span> (eventName == <span class="keyword">null</span> || f == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    _emap[eventName] ??= <span class="keyword">new</span> <span class="built_in">List</span>&lt;EventCallback&gt;();</span><br><span class="line">    _emap[eventName].add(f);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//移除订阅者</span></span><br><span class="line">  <span class="keyword">void</span> off(eventName, [EventCallback f]) &#123;</span><br><span class="line">    <span class="keyword">var</span> list = _emap[eventName];</span><br><span class="line">    <span class="keyword">if</span> (eventName == <span class="keyword">null</span> || list == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="keyword">null</span>) &#123;</span><br><span class="line">      _emap[eventName] = <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      list.remove(f);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//触发事件，事件触发后该事件所有订阅者会被调用</span></span><br><span class="line">  <span class="keyword">void</span> emit(eventName, [arg]) &#123;</span><br><span class="line">    <span class="keyword">var</span> list = _emap[eventName];</span><br><span class="line">    <span class="keyword">if</span> (list == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">int</span> len = list.length - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//反向遍历，防止订阅者在回调中移除自身带来的下标错位 </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = len; i &gt; <span class="number">-1</span>; --i) &#123;</span><br><span class="line">      list[i](arg);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个top-level（全局）变量，页面引入该文件后可以直接使用bus</span></span><br><span class="line"><span class="keyword">var</span> bus = <span class="keyword">new</span> EventBus();</span><br></pre></td></tr></table></figure>
<p>使用示例：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//页面A中</span></span><br><span class="line">...</span><br><span class="line"> <span class="comment">//监听登录事件</span></span><br><span class="line">bus.on(<span class="string">"login"</span>, (arg) &#123;</span><br><span class="line">  <span class="comment">// do something</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//登录页B中</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">//登录成功后触发登录事件，页面A中订阅者会被调用</span></span><br><span class="line">bus.emit(<span class="string">"login"</span>, userInfo);</span><br></pre></td></tr></table></figure>
<h3 id="notification">Notification</h3>
<p>通知（Notification）是Flutter中一个重要的机制，在widget树中，每一个节点都可以分发通知，通知会沿着当前节点向上传递，所有父节点都可以通过<code>NotificationListener</code>来监听通知。Flutter中将这种由子向父的传递通知的机制称为<strong>通知冒泡</strong>（Notification Bubbling）。通知冒泡和用户触摸事件冒泡是相似的，但有一点不同：通知冒泡可以中止，但用户触摸事件不行。</p>
<p>Flutter中很多地方使用了通知，如可滚动组件（Scrollable Widget）滑动时就会分发<strong>滚动通知</strong>（ScrollNotification），而Scrollbar正是通过监听ScrollNotification来确定滚动条位置的。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">NotificationListener(</span><br><span class="line">  onNotification: (notification)&#123;</span><br><span class="line">    <span class="keyword">switch</span> (notification.runtimeType)&#123;</span><br><span class="line">      <span class="keyword">case</span> ScrollStartNotification: <span class="built_in">print</span>(<span class="string">"开始滚动"</span>); <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> ScrollUpdateNotification: <span class="built_in">print</span>(<span class="string">"正在滚动"</span>); <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> ScrollEndNotification: <span class="built_in">print</span>(<span class="string">"滚动停止"</span>); <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> OverscrollNotification: <span class="built_in">print</span>(<span class="string">"滚动到边界"</span>); <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  child: ListView.builder(</span><br><span class="line">      itemCount: <span class="number">100</span>,</span><br><span class="line">      itemBuilder: (context, index) &#123;</span><br><span class="line">        <span class="keyword">return</span> ListTile(title: Text(<span class="string">"$index"</span>),);</span><br><span class="line">      &#125;</span><br><span class="line">  ),</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p><code>ScrollStartNotification</code>、<code>ScrollUpdateNotification</code>等都是继承自<code>ScrollNotification</code>类，不同类型的通知子类会包含不同的信息，比如<code>ScrollUpdateNotification</code>有一个<code>scrollDelta</code>属性，它记录了移动的位移</p>
<p>上例中，我们通过<code>NotificationListener</code>来监听子<code>ListView</code>的滚动通知的，<code>NotificationListener</code>定义如下：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NotificationListener</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Notification</span>&gt; <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> NotificationListener(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    <span class="meta">@required</span> <span class="keyword">this</span>.child,</span><br><span class="line">    <span class="keyword">this</span>.onNotification,</span><br><span class="line">  &#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line"> ...<span class="comment">//省略无关代码 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>
<p><code>NotificationListener</code> 继承自<code>StatelessWidget</code>类，所以它可以直接嵌套到Widget树中。</p>
</li>
<li>
<p><code>NotificationListener</code> 可以指定一个模板参数，该模板参数类型必须是继承自<code>Notification</code>；当显式指定模板参数时，<code>NotificationListener</code> 便只会接收该参数类型的通知。举个例子，如果我们将上例子代码改为：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//指定监听通知的类型为滚动结束通知(ScrollEndNotification)</span></span><br><span class="line">NotificationListener&lt;ScrollEndNotification&gt;(</span><br><span class="line">  onNotification: (notification)&#123;</span><br><span class="line">    <span class="comment">//只会在滚动结束时才会触发此回调</span></span><br><span class="line">    <span class="built_in">print</span>(notification);</span><br><span class="line">  &#125;,</span><br><span class="line">  child: ListView.builder(</span><br><span class="line">      itemCount: <span class="number">100</span>,</span><br><span class="line">      itemBuilder: (context, index) &#123;</span><br><span class="line">        <span class="keyword">return</span> ListTile(title: Text(<span class="string">"$index"</span>),);</span><br><span class="line">      &#125;</span><br><span class="line">  ),</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>上面代码运行后便只会在滚动结束时在控制台打印出通知的信息。</p>
</li>
<li>
<p><code>onNotification</code>回调为通知处理回调，其函数签名如下：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> NotificationListenerCallback&lt;T <span class="keyword">extends</span> Notification&gt; = <span class="built_in">bool</span> <span class="built_in">Function</span>(T notification);</span><br></pre></td></tr></table></figure>
<p>它的返回值类型为布尔值，当返回值为<code>true</code>时，阻止冒泡，其父级Widget将再也收不到该通知；当返回值为<code>false</code> 时继续向上冒泡通知。</p>
</li>
</ol>
<p>Flutter的UI框架实现中，除了在可滚动组件在滚动过程中会发出<code>ScrollNotification</code>之外，还有一些其它的通知，如<code>SizeChangedLayoutNotification</code>、<code>KeepAliveNotification</code> 、<code>LayoutChangedNotification</code>等，Flutter正是通过这种通知机制来使父元素可以在一些特定时机来做一些事情。</p>
<h4 id="自定义通知">自定义通知</h4>
<p>除了Flutter内部通知，我们也可以自定义通知，下面我们看看如何实现自定义通知：</p>
<ol>
<li>
<p>定义一个通知类，要继承自Notification类；</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyNotification</span> <span class="keyword">extends</span> <span class="title">Notification</span> </span>&#123;</span><br><span class="line">  MyNotification(<span class="keyword">this</span>.msg);</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> msg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>分发通知。</p>
<p><code>Notification</code>有一个<code>dispatch(context)</code>方法，它是用于分发通知的，我们说过<code>context</code>实际上就是操作<code>Element</code>的一个接口，它与<code>Element</code>树上的节点是对应的，通知会从<code>context</code>对应的<code>Element</code>节点向上冒泡。</p>
</li>
</ol>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NotificationRoute</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  NotificationRouteState createState() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> NotificationRouteState();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NotificationRouteState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">NotificationRoute</span>&gt; </span>&#123;</span><br><span class="line">  <span class="built_in">String</span> _msg=<span class="string">""</span>;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="comment">//监听通知  </span></span><br><span class="line">    <span class="keyword">return</span> NotificationListener&lt;MyNotification&gt;(</span><br><span class="line">      onNotification: (notification) &#123;</span><br><span class="line">        setState(() &#123;</span><br><span class="line">          _msg+=notification.msg+<span class="string">"  "</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;,</span><br><span class="line">      child: Center(</span><br><span class="line">        child: Column(</span><br><span class="line">          mainAxisSize: MainAxisSize.min,</span><br><span class="line">          children: &lt;Widget&gt;[</span><br><span class="line"><span class="comment">//          RaisedButton(</span></span><br><span class="line"><span class="comment">//           onPressed: () =&gt; MyNotification("Hi").dispatch(context),</span></span><br><span class="line"><span class="comment">//           child: Text("Send Notification"),</span></span><br><span class="line"><span class="comment">//          ),  </span></span><br><span class="line">            Builder(</span><br><span class="line">              builder: (context) &#123;</span><br><span class="line">                <span class="keyword">return</span> RaisedButton(</span><br><span class="line">                  <span class="comment">//按钮点击时分发通知  </span></span><br><span class="line">                  onPressed: () =&gt; MyNotification(<span class="string">"Hi"</span>).dispatch(context),</span><br><span class="line">                  child: Text(<span class="string">"Send Notification"</span>),</span><br><span class="line">                );</span><br><span class="line">              &#125;,</span><br><span class="line">            ),</span><br><span class="line">            Text(_msg)</span><br><span class="line">          ],</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyNotification</span> <span class="keyword">extends</span> <span class="title">Notification</span> </span>&#123;</span><br><span class="line">  MyNotification(<span class="keyword">this</span>.msg);</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> msg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="阻止冒泡">阻止冒泡</h5>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NotificationRouteState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">NotificationRoute</span>&gt; </span>&#123;</span><br><span class="line">  <span class="built_in">String</span> _msg=<span class="string">""</span>;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="comment">//监听通知</span></span><br><span class="line">    <span class="keyword">return</span> NotificationListener&lt;MyNotification&gt;(</span><br><span class="line">      onNotification: (notification)&#123;</span><br><span class="line">        <span class="built_in">print</span>(notification.msg); <span class="comment">//打印通知</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125;,</span><br><span class="line">      child: NotificationListener&lt;MyNotification&gt;(</span><br><span class="line">        onNotification: (notification) &#123;</span><br><span class="line">          setState(() &#123;</span><br><span class="line">            _msg+=notification.msg+<span class="string">"  "</span>;</span><br><span class="line">          &#125;);</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">false</span>; </span><br><span class="line">        &#125;,</span><br><span class="line">        child: ...<span class="comment">//省略重复代码</span></span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上列中两个<code>NotificationListener</code>进行了嵌套，子<code>NotificationListener</code>的<code>onNotification</code>回调返回了<code>false</code>，表示不阻止冒泡，所以父<code>NotificationListener</code>仍然会受到通知，所以控制台会打印出通知信息；如果将子<code>NotificationListener</code>的<code>onNotification</code>回调的返回值改为<code>true</code>，则父<code>NotificationListener</code>便不会再打印通知了，因为子<code>NotificationListener</code>已经终止通知冒泡了。</p>
<h5 id="通知冒泡">通知冒泡</h5>
<p>由于通知是通过<code>Notification</code>的<code>dispatch(context)</code>方法发出的，那我们先看看<code>dispatch(context)</code>方法中做了什么，下面是相关源码：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> dispatch(BuildContext target) &#123;</span><br><span class="line">  target?.visitAncestorElements(visitAncestor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>dispatch(context)</code>中调用了当前context的<code>visitAncestorElements</code>方法，该方法会从当前Element开始向上遍历父级元素；<code>visitAncestorElements</code>有一个遍历回调参数，在遍历过程中对遍历到的父级元素都会执行该回调。遍历的终止条件是：已经遍历到根Element或某个遍历回调返回<code>false</code>。源码中传给<code>visitAncestorElements</code>方法的遍历回调为<code>visitAncestor</code>方法，我们看看<code>visitAncestor</code>方法的实现：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//遍历回调，会对每一个父级Element执行此回调</span></span><br><span class="line"><span class="built_in">bool</span> visitAncestor(<span class="built_in">Element</span> element) &#123;</span><br><span class="line">  <span class="comment">//判断当前element对应的Widget是否是NotificationListener。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//由于NotificationListener是继承自StatelessWidget，</span></span><br><span class="line">  <span class="comment">//故先判断是否是StatelessElement</span></span><br><span class="line">  <span class="keyword">if</span> (element <span class="keyword">is</span> StatelessElement) &#123;</span><br><span class="line">    <span class="comment">//是StatelessElement，则获取element对应的Widget，判断</span></span><br><span class="line">    <span class="comment">//是否是NotificationListener 。</span></span><br><span class="line">    <span class="keyword">final</span> StatelessWidget widget = element.widget;</span><br><span class="line">    <span class="keyword">if</span> (widget <span class="keyword">is</span> NotificationListener&lt;Notification&gt;) &#123;</span><br><span class="line">      <span class="comment">//是NotificationListener，则调用该NotificationListener的_dispatch方法</span></span><br><span class="line">      <span class="keyword">if</span> (widget._dispatch(<span class="keyword">this</span>, element)) </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>visitAncestor</code>会判断每一个遍历到的父级Widget是否是<code>NotificationListener</code>，如果不是，则返回<code>true</code>继续向上遍历，如果是，则调用<code>NotificationListener</code>的<code>_dispatch</code>方法，我们看看<code>_dispatch</code>方法的源码：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bool</span> _dispatch(Notification notification, <span class="built_in">Element</span> element) &#123;</span><br><span class="line">  <span class="comment">// 如果通知监听器不为空，并且当前通知类型是该NotificationListener</span></span><br><span class="line">  <span class="comment">// 监听的通知类型，则调用当前NotificationListener的onNotification</span></span><br><span class="line">  <span class="keyword">if</span> (onNotification != <span class="keyword">null</span> &amp;&amp; notification <span class="keyword">is</span> T) &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">bool</span> result = onNotification(notification);</span><br><span class="line">    <span class="comment">// 返回值决定是否继续向上遍历</span></span><br><span class="line">    <span class="keyword">return</span> result == <span class="keyword">true</span>; </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到<code>NotificationListener</code>的<code>onNotification</code>回调最终是在<code>_dispatch</code>方法中执行的，然后会根据返回值来确定是否继续向上冒泡。上面的源码实现其实并不复杂，通过阅读这些源码，一些额外的点读者可以注意一下：</p>
<ol>
<li><code>Context</code>上也提供了遍历Element树的方法。</li>
<li>我们可以通过<code>Element.widget</code>得到<code>element</code>节点对应的widget；我们已经反复讲过Widget和Element的对应关系，读者通过这些源码来加深理解。</li>
</ol>

                

                <hr>
                <!-- Pager -->
                <ul class="pager">
                    
                        <li class="previous">
                            <a href="/Flutter/Flutter入门：文件和网络/" data-toggle="tooltip" data-placement="top" title="Flutter入门：文件和网络">&larr; Previous Post</a>
                        </li>
                    
                    
                        <li class="next">
                            <a href="/Flutter/Flutter入门：功能组件和动画/" data-toggle="tooltip" data-placement="top" title="Flutter入门：功能组件和动画">Next Post &rarr;</a>
                        </li>
                    
                </ul>

                <br>

                <!--打赏-->
                
                <!--打赏-->

                <br>
                <!--分享-->
                
                    <div class="social-share"  data-wechat-qrcode-helper="" align="center"></div>
                    <!--  css & js -->
                    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/css/share.min.css">
                    <script src="https://cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/js/social-share.min.js"></script>
                
                <!--分享-->
                <br>                       
                
                <!-- require APlayer -->
                

                <!-- duoshuo Share start -->
                
                <!-- 多说 Share end-->

                <!-- 多说评论框 start -->
                
                <!-- 多说评论框 end -->

                <!-- disqus comment start -->
                
                <!-- disqus comment end -->

                

            </div>
            
            <!-- Tabe of Content -->
            <!-- Table of Contents -->

  
    <style>
      span.toc-nav-number{
        display: none
      }
    </style>
  
    
      <aside id="sidebar">
        <div id="toc" class="toc-article">
        <strong class="toc-title">Contents</strong>
        
          <ol class="toc-nav"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#自定义组件"><span class="toc-nav-number">1.</span> <span class="toc-nav-text">&#x81EA;&#x5B9A;&#x4E49;&#x7EC4;&#x4EF6;</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#组合其它widget"><span class="toc-nav-number">1.0.1.</span> <span class="toc-nav-text">&#x7EC4;&#x5408;&#x5176;&#x5B83;Widget</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#示例自定义渐变按钮"><span class="toc-nav-number">1.0.1.1.</span> <span class="toc-nav-text">&#x793A;&#x4F8B;&#xFF1A;&#x81EA;&#x5B9A;&#x4E49;&#x6E10;&#x53D8;&#x6309;&#x94AE;</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#自绘"><span class="toc-nav-number">1.0.2.</span> <span class="toc-nav-text">&#x81EA;&#x7ED8;</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#custompaint"><span class="toc-nav-number">1.0.2.1.</span> <span class="toc-nav-text">CustomPaint</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#custompainter"><span class="toc-nav-number">1.0.2.2.</span> <span class="toc-nav-text">CustomPainter</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#画笔paint"><span class="toc-nav-number">1.0.2.3.</span> <span class="toc-nav-text">&#x753B;&#x7B14;Paint</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#示例五子棋盘"><span class="toc-nav-number">1.0.2.4.</span> <span class="toc-nav-text">&#x793A;&#x4F8B;&#xFF1A;&#x4E94;&#x5B50;&#x68CB;/&#x76D8;</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#实现renderobject"><span class="toc-nav-number">1.1.</span> <span class="toc-nav-text">&#x5B9E;&#x73B0;RenderObject</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#事件"><span class="toc-nav-number">2.</span> <span class="toc-nav-text">&#x4E8B;&#x4EF6;</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#触摸事件"><span class="toc-nav-number">2.0.1.</span> <span class="toc-nav-text">&#x89E6;&#x6478;&#x4E8B;&#x4EF6;</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#忽略pointerevent"><span class="toc-nav-number">2.0.1.1.</span> <span class="toc-nav-text">&#x5FFD;&#x7565;PointerEvent</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#手势识别"><span class="toc-nav-number">2.1.</span> <span class="toc-nav-text">&#x624B;&#x52BF;&#x8BC6;&#x522B;</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#gesturedetector"><span class="toc-nav-number">2.1.1.</span> <span class="toc-nav-text">GestureDetector</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#点击-双击-长按"><span class="toc-nav-number">2.1.1.1.</span> <span class="toc-nav-text">&#x70B9;&#x51FB;&#x3001;&#x53CC;&#x51FB;&#x3001;&#x957F;&#x6309;</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#拖动-滑动"><span class="toc-nav-number">2.1.1.2.</span> <span class="toc-nav-text">&#x62D6;&#x52A8;&#x3001;&#x6ED1;&#x52A8;</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#gesturerecognizer"><span class="toc-nav-number">2.1.2.</span> <span class="toc-nav-text">GestureRecognizer</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#手势竞争与冲突"><span class="toc-nav-number">2.1.3.</span> <span class="toc-nav-text">&#x624B;&#x52BF;&#x7ADE;&#x4E89;&#x4E0E;&#x51B2;&#x7A81;</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#竞争"><span class="toc-nav-number">2.1.3.1.</span> <span class="toc-nav-text">&#x7ADE;&#x4E89;</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#手势冲突"><span class="toc-nav-number">2.1.3.2.</span> <span class="toc-nav-text">&#x624B;&#x52BF;&#x51B2;&#x7A81;</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#事件总线"><span class="toc-nav-number">2.2.</span> <span class="toc-nav-text">&#x4E8B;&#x4EF6;&#x603B;&#x7EBF;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#notification"><span class="toc-nav-number">2.3.</span> <span class="toc-nav-text">Notification</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#自定义通知"><span class="toc-nav-number">2.3.1.</span> <span class="toc-nav-text">&#x81EA;&#x5B9A;&#x4E49;&#x901A;&#x77E5;</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#阻止冒泡"><span class="toc-nav-number">2.3.1.1.</span> <span class="toc-nav-text">&#x963B;&#x6B62;&#x5192;&#x6CE1;</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#通知冒泡"><span class="toc-nav-number">2.3.1.2.</span> <span class="toc-nav-text">&#x901A;&#x77E5;&#x5192;&#x6CE1;</span></a></li></ol></li></ol></li></ol></li></ol>
        
        </div>
      </aside>
    

                
            <!-- Sidebar Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                <!-- Featured Tags -->
                
                <section>
                    <!-- no hr -->
                    <h5><a href="/tags/">FEATURED TAGS</a></h5>
                    <div class="tags">
                       
                          <a class="tag" href="/tags/#Flutter" title="Flutter">Flutter</a>
                        
                    </div>
                </section>
                

                <!-- Friends Blog -->
                
            </div>
        </div>
    </div>
</article>








<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>
<!-- anchor-js, Doc:http://bryanbraun.github.io/anchorjs/ -->
<script>
    async("https://cdn.bootcss.com/anchor-js/1.1.1/anchor.min.js",function(){
        anchors.options = {
          visible: 'hover',
          placement: 'left',
          icon: 'ℬ'
        };
        anchors.add().remove('.intro-header h1').remove('.subheading').remove('.sidebar-container h5');
    })
</script>
<style>
    /* place left on bigger screen */
    @media all and (min-width: 800px) {
        .anchorjs-link{
            position: absolute;
            left: -0.75em;
            font-size: 1.1em;
            margin-top : -0.1em;
        }
    }
</style>


<!-- chrome Firefox 中文锚点定位失效-->
<script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.js"></script>
<!-- smooth scroll behavior polyfill  -->
<script type="text/javascript" src="/js/smoothscroll.js"></script>
<script>
        $('#toc').on('click','a',function(a){
            // var isChrome = window.navigator.userAgent.indexOf("Chrome") !== -1;
            // console.log(window.navigator.userAgent,isChrome)
                // if(isChrome) {
                    // console.log(a.currentTarget.outerHTML);
                    // console.log($(a.currentTarget).attr("href"));
                    //跳转到指定锚点
                    // document.getElementById(a.target.innerText.toLowerCase()).scrollIntoView(true);
                    document.getElementById($(a.currentTarget).attr("href").replace("#","")).scrollIntoView({behavior: 'smooth' });
                // }
        })  
</script>


    <!-- Footer -->
    <!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                
                
                

                

                

                
                    <li>
                        <a target="_blank"  href="https://github.com/earthwo">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                

                

                </ul>
                <p class="copyright text-muted">
                    Copyright &copy; alonealice 2021 
                    <br>
                    Theme by <a href="http://beantech.org">BeanTech</a> 
                    <span style="display: inline-block; margin: 0 5px;">
                        <i class="fa fa-heart"></i>
                    </span> 
                    re-Ported by <a href="http://www.huweihuang.com">胡伟煌</a> |
                    <br> 
                    <a href="http://www.beian.miit.gov.cn">浙ICP备17033688号</a>   
                </p>
            </div>
        </div>
    </div>
</footer>

<!-- jQuery -->
<script src="/js/jquery.min.js"></script>

<!-- Bootstrap Core JavaScript -->
<script src="/js/bootstrap.min.js"></script>

<!-- Custom Theme JavaScript -->
<script src="/js/hux-blog.min.js"></script>


<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>

<!-- 
     Because of the native support for backtick-style fenced code blocks 
     right within the Markdown is landed in Github Pages, 
     From V1.6, There is no need for Highlight.js, 
     so Huxblog drops it officially.

     - https://github.com/blog/2100-github-pages-now-faster-and-simpler-with-jekyll-3-0  
     - https://help.github.com/articles/creating-and-highlighting-code-blocks/    
-->
<!--
    <script>
        async("http://cdn.bootcss.com/highlight.js/8.6/highlight.min.js", function(){
            hljs.initHighlightingOnLoad();
        })
    </script>
    <link href="http://cdn.bootcss.com/highlight.js/8.6/styles/github.min.css" rel="stylesheet">
-->


<!-- jquery.tagcloud.js -->
<script>
    // only load tagcloud.js in tag.html
    if($('#tag_cloud').length !== 0){
        async("http://alonealice.com/js/jquery.tagcloud.js",function(){
            $.fn.tagcloud.defaults = {
                //size: {start: 1, end: 1, unit: 'em'},
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>

<!--fastClick.js -->
<script>
    async("https://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>


<!-- Google Analytics -->


<script>
    // dynamic User by Hux
    var _gaId = 'UA-XXXXXXXX-X';
    var _gaDomain = 'yoursite';

    // Originial
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', _gaId, _gaDomain);
    ga('send', 'pageview');
</script>




<!-- Baidu Tongji -->

<script>
    // dynamic User by Hux
    var _baId = 'xxx';

    // Originial
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?" + _baId;
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
</script>






	<a id="rocket" href="#top" class=""></a>
	<script type="text/javascript" src="/js/totop.js?v=1.0.0" async=""></script>
    <script type="text/javascript" src="/js/toc.js?v=1.0.0" async=""></script>
<!-- Image to hack wechat -->
<img src="http://alonealice.com/img/icon_wechat.png" width="0" height="0" />
<!-- Migrate from head to bottom, no longer block render and still work -->

</body>

</html>
