<!DOCTYPE html><html lang="zh-cn"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=Edge"><meta name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no"><meta name="format-detection" content="telephone=no"><meta name="format-detection" content="email=no"><meta name="description" content="study life"><meta name="keywords" content="Hexo, Gruntjs, Nodejs, Reactjs, Vuejs"><title>AsyncTask解析 - alonealice</title><link rel="stylesheet" href="/css/main_style.min.css"><link rel="icon" href="/favicon.ico"></head><body><input id="navi" type="checkbox"><ul class="main-navication"><li><a href="/"><span>Home</span></a></li><li><a href="https://github.com/earthWo"><span>Github</span></a></li></ul><div class="wrapper" id="wrap"><div class="post-header"><label class="navi-button light" for="navi">MENU</label><img class="background" src="https://img.zcool.cn/community/014177554b6ae7000001bf729a3698.jpg@1280w_1l_0o_100sh.jpg"><div class="post-title"><h1 class="title">AsyncTask解析</h1><ul class="meta"><li><i class="icon icon-author"></i>alonealice</li><li><i class="icon icon-clock"></i>14 Minutes</li><li><i class="icon icon-calendar"></i>2016年7月23日</li></ul></div></div><div class="article-content" style="max-width:800px"><p>AsyncTask是我们在开发过程中经常使用的类，它是一个抽象类，主要用来实现轻量级异步操作。那接下来我们就看看它的内部实现。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public AsyncTask() &#123;</span><br><span class="line">        mWorker = new WorkerRunnable&lt;Params, Result&gt;() &#123;</span><br><span class="line">            public Result call() throws Exception &#123;</span><br><span class="line">                mTaskInvoked.set(true);</span><br><span class="line"></span><br><span class="line">                Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</span><br><span class="line">                //noinspection unchecked</span><br><span class="line">                Result result = doInBackground(mParams);</span><br><span class="line">                Binder.flushPendingCommands();</span><br><span class="line">                return postResult(result);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        mFuture = new FutureTask&lt;Result&gt;(mWorker) &#123;</span><br><span class="line">            @Override</span><br><span class="line">            protected void done() &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    postResultIfNotInvoked(get());</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    android.util.Log.w(LOG_TAG, e);</span><br><span class="line">                &#125; catch (ExecutionException e) &#123;</span><br><span class="line">                    throw new RuntimeException(&quot;An error occurred while executing doInBackground()&quot;,</span><br><span class="line">                            e.getCause());</span><br><span class="line">                &#125; catch (CancellationException e) &#123;</span><br><span class="line">                    postResultIfNotInvoked(null);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>AsyncTask的构造方法主要实现了初始化了两个对象，一个是WorkerRunnable对象mWorker，WorkerRunnable是它的内部静态类，并且实现了Callable接口，里面只有一个数组；另一个是FutureTask对象mFuture，该类实现了Runnable接口和Futrue接口。这两个对象具体有什么用，先按下不表。<br>使用AsyncTask时，我们都需要调用excute方法，并且传入相应的参数，那就来看看excute的实现。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public final AsyncTask&lt;Params, Progress, Result&gt; execute(Params... params) &#123;</span><br><span class="line">       return executeOnExecutor(sDefaultExecutor, params);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>这里它调用了executeOnExecutor方法，同时传入sDefaultExecutor和我们外边传入的参数。sDefaultExecutor是一个线程池，它的用处后面再说。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public final AsyncTask&lt;Params, Progress, Result&gt; executeOnExecutor(Executor exec,</span><br><span class="line">            Params... params) &#123;</span><br><span class="line">        if (mStatus != Status.PENDING) &#123;</span><br><span class="line">            switch (mStatus) &#123;</span><br><span class="line">                case RUNNING:</span><br><span class="line">                    throw new IllegalStateException(&quot;Cannot execute task:&quot;</span><br><span class="line">                            + &quot; the task is already running.&quot;);</span><br><span class="line">                case FINISHED:</span><br><span class="line">                    throw new IllegalStateException(&quot;Cannot execute task:&quot;</span><br><span class="line">                            + &quot; the task has already been executed &quot;</span><br><span class="line">                            + &quot;(a task can be executed only once)&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mStatus = Status.RUNNING;</span><br><span class="line"></span><br><span class="line">        onPreExecute();</span><br><span class="line"></span><br><span class="line">        mWorker.mParams = params;</span><br><span class="line">        exec.execute(mFuture);</span><br><span class="line"></span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>executeOnExecutor方法中，首先是判断整个任务的状态，只有当任务状态为等待时才能执行，同时我们也可以发现，整个类中没有将状态重新置为等待的方法，所以说明一个AsyncTask对象只能执行一次。之后会执行onPreExecute方法，进行任务前的预操作，同时将传入的参数胡设置到mWorker中，然后将FutureTask对象mFuture添加到线程池中执行。接下来就看一下这个sDefaultExecutor线程池的实现。<br>sDefaultExecutor是AsyncTask的静态类SerialExecutor对象，它实现了Executor接口，里面有一个任务队列和一个当前任务对象，在它的execute方法中，我们可以发现，它并没有去实现具体的操作逻辑，只是将添加的任务添加到任务队列中，同时当当前任务对象为空时，从队列中取出任务，在THREAD_POOL_EXECUTOR线程池中执行。THREAD_POOL_EXECUTOR是AsyncTask的静态对象，这样做可以减少线程池的创建。同时它的核心线程数为cpu+1个，最大线程数为cpu*2+1个，线程存活时间为1s，任务队列空间为128。该线程最终会执行添加进来的mFuture任务。<br>那接来下看一下mFuture的实现。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void run() &#123;</span><br><span class="line">       if (state != NEW ||</span><br><span class="line">           !U.compareAndSwapObject(this, RUNNER, null, Thread.currentThread()))</span><br><span class="line">           return;</span><br><span class="line">       try &#123;</span><br><span class="line">           Callable&lt;V&gt; c = callable;</span><br><span class="line">           if (c != null &amp;&amp; state == NEW) &#123;</span><br><span class="line">               V result;</span><br><span class="line">               boolean ran;</span><br><span class="line">               try &#123;</span><br><span class="line">                   result = c.call();</span><br><span class="line">                   ran = true;</span><br><span class="line">               &#125; catch (Throwable ex) &#123;</span><br><span class="line">                   result = null;</span><br><span class="line">                   ran = false;</span><br><span class="line">                   setException(ex);</span><br><span class="line">               &#125;</span><br><span class="line">               if (ran)</span><br><span class="line">                   set(result);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; finally &#123;</span><br><span class="line">           // runner must be non-null until state is settled to</span><br><span class="line">           // prevent concurrent calls to run()</span><br><span class="line">           runner = null;</span><br><span class="line">           // state must be re-read after nulling runner to prevent</span><br><span class="line">           // leaked interrupts</span><br><span class="line">           int s = state;</span><br><span class="line">           if (s &gt;= INTERRUPTING)</span><br><span class="line">               handlePossibleCancellationInterrupt(s);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>之前说过，FutureTask实现了runnable接口，在其run方法中，我们发现它会去调用在创建时传入的Callable对象的call方法，获得返回值后，调用set方法设置返回值，最后调用外AsyncTask中实现的done方法。<br>call方法实现如下:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mWorker = new WorkerRunnable&lt;Params, Result&gt;() &#123;</span><br><span class="line">           public Result call() throws Exception &#123;</span><br><span class="line">               mTaskInvoked.set(true);</span><br><span class="line"></span><br><span class="line">               Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</span><br><span class="line">               //noinspection unchecked</span><br><span class="line">               Result result = doInBackground(mParams);</span><br><span class="line">               Binder.flushPendingCommands();</span><br><span class="line">               return postResult(result);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;;</span><br></pre></td></tr></table></figure></p>
<p>call方法中主要是执行doInBackground方法，获得返回值后返回。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mFuture = new FutureTask&lt;Result&gt;(mWorker) &#123;</span><br><span class="line">           @Override</span><br><span class="line">           protected void done() &#123;</span><br><span class="line">               try &#123;</span><br><span class="line">                   postResultIfNotInvoked(get());</span><br><span class="line">               &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                   android.util.Log.w(LOG_TAG, e);</span><br><span class="line">               &#125; catch (ExecutionException e) &#123;</span><br><span class="line">                   throw new RuntimeException(&quot;An error occurred while executing doInBackground()&quot;,</span><br><span class="line">                           e.getCause());</span><br><span class="line">               &#125; catch (CancellationException e) &#123;</span><br><span class="line">                   postResultIfNotInvoked(null);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;;</span><br></pre></td></tr></table></figure></p>
<p>而done方法这时获取之前的结果，并且调用postResultIfNotInvoked方法。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void postResultIfNotInvoked(Result result) &#123;</span><br><span class="line">        final boolean wasTaskInvoked = mTaskInvoked.get();</span><br><span class="line">        if (!wasTaskInvoked) &#123;</span><br><span class="line">            postResult(result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Result postResult(Result result) &#123;</span><br><span class="line">        @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">        Message message = getHandler().obtainMessage(MESSAGE_POST_RESULT,</span><br><span class="line">                new AsyncTaskResult&lt;Result&gt;(this, result));</span><br><span class="line">        message.sendToTarget();</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>postResultIfNotInvoked方法中最终会将之前的结果打包成一个message到hanlder。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private static class InternalHandler extends Handler &#123;</span><br><span class="line">        public InternalHandler() &#123;</span><br><span class="line">            super(Looper.getMainLooper());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @SuppressWarnings(&#123;&quot;unchecked&quot;, &quot;RawUseOfParameterizedType&quot;&#125;)</span><br><span class="line">        @Override</span><br><span class="line">        public void handleMessage(Message msg) &#123;</span><br><span class="line">            AsyncTaskResult&lt;?&gt; result = (AsyncTaskResult&lt;?&gt;) msg.obj;</span><br><span class="line">            switch (msg.what) &#123;</span><br><span class="line">                case MESSAGE_POST_RESULT:</span><br><span class="line">                    // There is only one result</span><br><span class="line">                    result.mTask.finish(result.mData[0]);</span><br><span class="line">                    break;</span><br><span class="line">                case MESSAGE_POST_PROGRESS:</span><br><span class="line">                    result.mTask.onProgressUpdate(result.mData);</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>该handler创建在主线程中，处理主要分两种，一种是更新进度，一种是结束事件。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void finish(Result result) &#123;</span><br><span class="line">        if (isCancelled()) &#123;</span><br><span class="line">            onCancelled(result);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            onPostExecute(result);</span><br><span class="line">        &#125;</span><br><span class="line">        mStatus = Status.FINISHED;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>结束事件时会调用finish方法，最终会执行自己实现的onPostExecute方法，而更新进度时则会执行实现的onProgressUpdate方法。<br>最后总结一下，AsyncTask使用时，会有一个线程池，用来执行具体的任务，还有一个Executor，用来添加、获取任务。同时在执行任务时，会有一个Callable处理多线程任务，同时回调结果，结果回调到runnable接口，同时使用handler执行主线程回调方法。</p>
</div><div class="article-meta" style="max-width:800px"><div class="tags"><i class="icon icon-tag"></i><ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/源码阅读/">源码阅读</a><span class="tag-list-count">8</span></li></ul></div><div class="categories"><i class="icon icon-category"></i><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/源码阅读/">源码阅读</a><span class="category-list-count">6</span></li></ul></div></div><div class="article-comment" style="max-width:800px"><div class="ds-thread" id="ds-thread" data-thread-key="ck85r7luk0072fxo1rufws4a0" data-title="AsyncTask解析" data-url="https://earthwo.github.io/2016/07/23/AsyncTask解析/" site-name="ueibo"></div><script>var siteName = document.getElementById('ds-thread').getAttribute('site-name');
var duoshuoQuery = {short_name: siteName};
(function() {
  var ds = document.createElement('script');
  ds.type = 'text/javascript';ds.async = true;
  ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
  ds.charset = 'UTF-8';
  (document.getElementsByTagName('head')[0] 
  || document.getElementsByTagName('body')[0]).appendChild(ds);
})();</script></div><ul class="navication"><li class="home"><a href="/"><i class="icon icon-home"></i></a></li><li><a href="/2016/08/04/IntentService解析/"><i class="icon icon-arror-left"></i></a></li><li><a href="/2016/06/14/第一个jni程序/"><i class="icon icon-arror-right"></i></a></li></ul><div class="page-footer"><div class="top"><ul class="social"><li><a href="https://github.com/earthWo" title="Github" target="_blank"><i class="icon icon-github"></i></a></li></ul></div><div class="bottom"><p class="copyright">© 2020 alonealice<br><small><a href="http://www.beian.miit.gov.cn" target="_blank">浙ICP备17033688号</a></small><small>, THEME BY <a href="https://github.com/BoizZ/hexo-theme-laughing" target="_blank">LAUGHING</a></small></p></div></div></div><script>var wrap = document.getElementById('wrap');
window.onload = function () {
  wrap.className += ' done';
}</script></body></html>