<!DOCTYPE html><html lang="zh-cn"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=Edge"><meta name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no"><meta name="format-detection" content="telephone=no"><meta name="format-detection" content="email=no"><meta name="description" content="study life"><meta name="keywords" content="Hexo, Gruntjs, Nodejs, Reactjs, Vuejs"><title>Executor 框架与线程池 - alonealice</title><link rel="stylesheet" href="/css/main_style.min.css"><link rel="icon" href="/favicon.ico"></head><body><input id="navi" type="checkbox"><ul class="main-navication"><li><a href="/"><span>Home</span></a></li><li><a href="https://github.com/earthWo"><span>Github</span></a></li></ul><div class="wrapper" id="wrap"><div class="post-header"><label class="navi-button light" for="navi">MENU</label><img class="background" src="https://img.zcool.cn/community/014177554b6ae7000001bf729a3698.jpg@1280w_1l_0o_100sh.jpg"><div class="post-title"><h1 class="title">Executor 框架与线程池</h1><ul class="meta"><li><i class="icon icon-author"></i>alonealice</li><li><i class="icon icon-clock"></i>6 Minutes</li><li><i class="icon icon-calendar"></i>2016年11月4日</li></ul></div></div><div class="article-content" style="max-width:800px"><p>Executor 框架是 Java 5 中引入的，其内部使用了线程池机制，通过该框架来控制线程的启动、执行和关闭，可以简化并发编程的操作。通过 Executor 来启动线程比使用 Thread 的 start 方法更好。首先是能够降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。其次能够提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。最后还能提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。<br>Executor 接口中之定义了一个方法 execute（Runnable command），该方法接收一个 Runable 实例，它用来执行一个任务，任务即一个实现了 Runnable 接口的类。ExecutorService 接口继承自 Executor 接口，它提供了更丰富的实现多线程的方法。<br>ExecutorService 的生命周期包括三种状态：运行、关闭、终止。创建后便进入运行状态，当调用了 shutdown（）方法时，便进入关闭状态，此时意味着 ExecutorService 不再接受新的任务，但它还在执行已经提交了的任务，当素有已经提交了的任务执行完后，便到达终止状态。<br>Executors 提供了一系列工厂方法用于创先线程池，返回的线程池都实现了 ExecutorService 接口，我们可以使用它来创建ExecutorService实例。<br>提供的方法主要有以下几个：</p>
<p>public static ExecutorService newCachedThreadPool()<br>创建一个可缓存的线程池。调用execute时将重用以前构造的可用的线程。如果现有线程没有可用的，则创建一个新线程并添加到池中。在缓存中如果有60s都未被使用的线程将会被移除，它最多可以Integer.MAX_VALUE个线程。</p>
<p>public static ExecutorService newFixedThreadPool(int nThreads)<br>创建固定数目线程的线程池。它与newCachedThreadPool差不多，但是它最多只能有nThreads个线程，所以它不能随时创建新的线程，当线程池满时，需要创建新的线程时会在队列中等待，知道有线程执行完成并且从池中移除。</p>
<p>public static ExecutorService newSingleThreadExecutor()<br>创建一个单线程化的Executor，其在任何时候线程池中都只有一个线程，执行完之后会移除。</p>
<p>public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize)<br>创建一个支持定时及周期性的任务执行的线程池，多数情况下可用来替代Timer类。</p>
<h4 id="Executor-运行-Runnable-任务"><a href="#Executor-运行-Runnable-任务" class="headerlink" title="Executor 运行 Runnable 任务"></a>Executor 运行 Runnable 任务</h4><p>在获取上述的几个实例后，我们就可以调用实例的execute方法运行runnable方法。<br>示例：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ExecutorService executor= Executors.newCachedThreadPool();</span><br><span class="line">       executor.execute(new Runnable() &#123;</span><br><span class="line">           @Override</span><br><span class="line">           public void run() &#123;</span><br><span class="line">               while(true) &#123;</span><br><span class="line">                   num1++;</span><br><span class="line">                   Log.d(&quot;num1&quot;, num1 + &quot;&quot;);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br></pre></td></tr></table></figure></p>
<h4 id="Executor-运行-Callable-任务"><a href="#Executor-运行-Callable-任务" class="headerlink" title="Executor 运行 Callable 任务"></a>Executor 运行 Callable 任务</h4><p>在使用线程的过程中，我们经常会遇到由于没有返回值而带来的问题。而在使用ExecutorService的时候，我们就可以运行Callable接口来获得返回值。Callable 的 call()方法可以通过 ExecutorService 的 submit(Callable task) 方法来执行，并且返回一个 Future，同样，将 Runnable 的对象传递给 ExecutorService 的 submit 方法，则该 run 方法自动在一个线程上执行，并且会返回执行结果 Future 对象，但是在该 Future 对象上调用 get 方法，将返回 null。<br>示例：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Callable&lt;String&gt;s=new Callable&lt;String&gt;() &#123;</span><br><span class="line">           @Override</span><br><span class="line">           public String call() throws Exception &#123;</span><br><span class="line">               for(int i=0;i&lt;100000;i++)&#123;</span><br><span class="line">                   num1++;</span><br><span class="line">               &#125;</span><br><span class="line">               return  num1+10+&quot;&quot;;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;;</span><br><span class="line">       Future&lt;String&gt;f= executor.submit(s);</span><br><span class="line">       try &#123;</span><br><span class="line">           Log.d(&quot;最后的结果&quot;,f.get());</span><br><span class="line">       &#125; catch (InterruptedException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125; catch (ExecutionException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="自定义线程池"><a href="#自定义线程池" class="headerlink" title="自定义线程池"></a>自定义线程池</h4><p>除了使用自带的线程池，我们也可以自定义线程池来执行任务。自定义线程池主要是使用ThreadPoolExecutor类创建。其构造方法如下：<br><code>public ThreadPoolExecutor (int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit,BlockingQueue&lt;Runnable&gt; workQueue)</code></p>
<p>当中参数的含义如下：<br><code>corePoolSize</code> 线程池中的最少线程数，当添加新任务时，当池中的线程少于corePoolSize，即使有空闲线程，也会新建线程添加到池中。<br><code>maximumPoolSize</code> 线程池中最大的线程数。<br><code>keepAliveTime</code> 空闲线程的保持时间<br><code>unit</code> 时间单位（秒/分…）<br><code>workQueue</code> 任务执行前保存任务的队列</p>
<p>所以当有新任务要处理时，先看线程数是否大于corePoolSize，再看缓冲队列是否满，最后看线程数是否大于最大maximumPoolSize。</p>
<h4 id="不同缓冲队列的区别"><a href="#不同缓冲队列的区别" class="headerlink" title="不同缓冲队列的区别"></a>不同缓冲队列的区别</h4><p>SynchronousQueue：它将任务直接提交给线程处理，当不存在空闲线程时会创建新线程，所以maximumPoolSizes应设置为Integer.MAX_VALUE，已避免提交任务失败，newCachedThreadPool就是采取这种队列。<br>LinkedBlockingQueue：队列的容量是无限的，所以线程中最大线程数不会超过corePoolSize，newFixedThreadPool就是采用这种队列。<br>ArrayBlockingQueue：有界队列，队列中的任务数量有限，这样可以防止资源过度消耗。<br>示例：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ThreadPoolExecutor r=new ThreadPoolExecutor(3,5,50, TimeUnit.SECONDS,new ArrayBlockingQueue&lt;Runnable&gt;(20));</span><br><span class="line">        r.execute(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                num1++;</span><br><span class="line">                Log.d(&quot;num1&quot;, num1 + &quot;&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure></p>
</div><div class="article-meta" style="max-width:800px"><div class="tags"><i class="icon icon-tag"></i><ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Executors/">Executors</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/线程池/">线程池</a><span class="tag-list-count">1</span></li></ul></div><div class="categories"><i class="icon icon-category"></i><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Executors/">Executors</a><span class="category-list-count">1</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Executors/线程池/">线程池</a><span class="category-list-count">1</span></li></ul></li></ul></div></div><div class="article-comment" style="max-width:800px"><div class="ds-thread" id="ds-thread" data-thread-key="ck85q6toa000vtfo1px5llkcu" data-title="Executor 框架与线程池" data-url="https://earthwo.github.io/2016/11/04/ExecutorsExecutor 框架与线程池的使用/" site-name="ueibo"></div><script>var siteName = document.getElementById('ds-thread').getAttribute('site-name');
var duoshuoQuery = {short_name: siteName};
(function() {
  var ds = document.createElement('script');
  ds.type = 'text/javascript';ds.async = true;
  ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
  ds.charset = 'UTF-8';
  (document.getElementsByTagName('head')[0] 
  || document.getElementsByTagName('body')[0]).appendChild(ds);
})();</script></div><ul class="navication"><li class="home"><a href="/"><i class="icon icon-home"></i></a></li><li><a href="/2016/11/04/Effective-Java读书笔记(1)/"><i class="icon icon-arror-left"></i></a></li><li><a href="/2016/10/27/http断点下载/"><i class="icon icon-arror-right"></i></a></li></ul><div class="page-footer"><div class="top"><ul class="social"><li><a href="https://github.com/earthWo" title="Github" target="_blank"><i class="icon icon-github"></i></a></li></ul></div><div class="bottom"><p class="copyright">© 2020 alonealice<br><small><a href="http://www.miitbeian.gov.cn" target="_blank">浙ICP备17033688号</a></small><small>, THEME BY <a href="https://github.com/BoizZ/hexo-theme-laughing" target="_blank">LAUGHING</a></small></p></div></div></div><script>var wrap = document.getElementById('wrap');
window.onload = function () {
  wrap.className += ' done';
}</script></body></html>