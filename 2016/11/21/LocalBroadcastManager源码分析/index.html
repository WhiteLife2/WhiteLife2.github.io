<!DOCTYPE html><html lang="zh-cn"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=Edge"><meta name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no"><meta name="format-detection" content="telephone=no"><meta name="format-detection" content="email=no"><meta name="description" content="study life"><meta name="keywords" content="Hexo, Gruntjs, Nodejs, Reactjs, Vuejs"><title>LocalBroadcastManager源码分析 - alonealice</title><link rel="stylesheet" href="/css/main_style.min.css"><link rel="icon" href="/favicon.ico"></head><body><input id="navi" type="checkbox"><ul class="main-navication"><li><a href="/"><span>Home</span></a></li><li><a href="https://github.com/earthWo"><span>Github</span></a></li></ul><div class="wrapper" id="wrap"><div class="post-header"><label class="navi-button light" for="navi">MENU</label><img class="background" src="https://img.zcool.cn/community/014177554b6ae7000001bf729a3698.jpg@1280w_1l_0o_100sh.jpg"><div class="post-title"><h1 class="title">LocalBroadcastManager源码分析</h1><ul class="meta"><li><i class="icon icon-author"></i>alonealice</li><li><i class="icon icon-clock"></i>17 Minutes</li><li><i class="icon icon-calendar"></i>2016年11月21日</li></ul></div></div><div class="article-content" style="max-width:800px"><p>当我们在发送广播时，有时会遇到这样的问题，就是我不想让该广播被其他应用接收，或者我的广播接收器不想接收其他的应用的广播，这该怎么做呢？解决的方案有很多中，比如可以自定义广播的权限；比如可以给intent设置package等。但是这些方法，一旦应用被反编译，就完全无法保障其他应用再来发冒充我们的广播了。在Android系统中，有一个LocalBroadcastManager类，就是专门来解决广播只在应用内部流通的问题。<br>LocalBroadcastManager是在android.support.v4包中，它能使发送的广播只在本应用中传递，同时自己的接收器也不会接受到其他应用的广播。那它内部是怎样实现的呢？<br>LocalBroadcastManager使用了单例模式，其构造方法如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static LocalBroadcastManager getInstance(Context context) &#123;</span><br><span class="line">        synchronized (mLock) &#123;</span><br><span class="line">            if (mInstance == null) &#123;</span><br><span class="line">                mInstance = new LocalBroadcastManager(context.getApplicationContext());</span><br><span class="line">            &#125;</span><br><span class="line">            return mInstance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private LocalBroadcastManager(Context context) &#123;</span><br><span class="line">        mAppContext = context;</span><br><span class="line">        mHandler = new Handler(context.getMainLooper()) &#123;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void handleMessage(Message msg) &#123;</span><br><span class="line">                switch (msg.what) &#123;</span><br><span class="line">                    case MSG_EXEC_PENDING_BROADCASTS:</span><br><span class="line">                        executePendingBroadcasts();</span><br><span class="line">                        break;</span><br><span class="line">                    default:</span><br><span class="line">                        super.handleMessage(msg);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>这里的mLock对象是一个空Object对象，只是单纯的在这里用来锁一下。同时，在构造方法找那个，实现了一个在主线程中的Handler，这个hander具体怎么样，后面再说。<br>LocalBroadcastManager主要有三个方法，registerReceiver、unregisterReceiver和sendBroadcast。从名字就可以知道，一个用来注册接收器，一个用来注销接收器，还有一个用来发送广播，那我们一次来看看是怎么实现的。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void registerReceiver(BroadcastReceiver receiver, IntentFilter filter) &#123;</span><br><span class="line">        synchronized (mReceivers) &#123;</span><br><span class="line">            ReceiverRecord entry = new ReceiverRecord(filter, receiver);</span><br><span class="line">            ArrayList&lt;IntentFilter&gt; filters = mReceivers.get(receiver);</span><br><span class="line">            if (filters == null) &#123;</span><br><span class="line">                filters = new ArrayList&lt;IntentFilter&gt;(1);</span><br><span class="line">                mReceivers.put(receiver, filters);</span><br><span class="line">            &#125;</span><br><span class="line">            filters.add(filter);</span><br><span class="line">            for (int i=0; i&lt;filter.countActions(); i++) &#123;</span><br><span class="line">                String action = filter.getAction(i);</span><br><span class="line">                ArrayList&lt;ReceiverRecord&gt; entries = mActions.get(action);</span><br><span class="line">                if (entries == null) &#123;</span><br><span class="line">                    entries = new ArrayList&lt;ReceiverRecord&gt;(1);</span><br><span class="line">                    mActions.put(action, entries);</span><br><span class="line">                &#125;</span><br><span class="line">                entries.add(entry);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private static class ReceiverRecord &#123;</span><br><span class="line">           final IntentFilter filter;</span><br><span class="line">           final BroadcastReceiver receiver;</span><br><span class="line">           boolean broadcasting;</span><br><span class="line"></span><br><span class="line">           ReceiverRecord(IntentFilter _filter, BroadcastReceiver _receiver) &#123;</span><br><span class="line">               filter = _filter;</span><br><span class="line">               receiver = _receiver;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">          ...</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></p>
<p>首先是registerReceiver，首先先将BroadcastReceiver和IntentFilter封装成一个ReceiverRecord，再判断是否存有相同的BroadcastReceiver，如果没有，则以BroadcastReceiver为key，ArrayList<intentfilter>为值，添加到列表，同时在ArrayList<intentfilter>添加传入的IntentFilter；同样，又以IntentFilter的action为key，将ReceiverRecord存入到列表。<br>发送广播：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public boolean sendBroadcast(Intent intent) &#123;</span><br><span class="line">        synchronized (mReceivers) &#123;</span><br><span class="line">            final String action = intent.getAction();</span><br><span class="line">            final String type = intent.resolveTypeIfNeeded(</span><br><span class="line">                    mAppContext.getContentResolver());</span><br><span class="line">            final Uri data = intent.getData();</span><br><span class="line">            final String scheme = intent.getScheme();</span><br><span class="line">            final Set&lt;String&gt; categories = intent.getCategories();</span><br><span class="line"></span><br><span class="line">            final boolean debug = DEBUG ||</span><br><span class="line">                    ((intent.getFlags() &amp; Intent.FLAG_DEBUG_LOG_RESOLUTION) != 0);</span><br><span class="line">            if (debug) Log.v(</span><br><span class="line">                    TAG, &quot;Resolving type &quot; + type + &quot; scheme &quot; + scheme</span><br><span class="line">                    + &quot; of intent &quot; + intent);</span><br><span class="line"></span><br><span class="line">            ArrayList&lt;ReceiverRecord&gt; entries = mActions.get(intent.getAction());</span><br><span class="line">            if (entries != null) &#123;</span><br><span class="line">                if (debug) Log.v(TAG, &quot;Action list: &quot; + entries);</span><br><span class="line"></span><br><span class="line">                ArrayList&lt;ReceiverRecord&gt; receivers = null;</span><br><span class="line">                for (int i=0; i&lt;entries.size(); i++) &#123;</span><br><span class="line">                    ReceiverRecord receiver = entries.get(i);</span><br><span class="line">                    if (debug) Log.v(TAG, &quot;Matching against filter &quot; + receiver.filter);</span><br><span class="line"></span><br><span class="line">                    if (receiver.broadcasting) &#123;</span><br><span class="line">                        if (debug) &#123;</span><br><span class="line">                            Log.v(TAG, &quot;  Filter&apos;s target already added&quot;);</span><br><span class="line">                        &#125;</span><br><span class="line">                        continue;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    int match = receiver.filter.match(action, type, scheme, data,</span><br><span class="line">                            categories, &quot;LocalBroadcastManager&quot;);</span><br><span class="line">                    if (match &gt;= 0) &#123;</span><br><span class="line">                        if (debug) Log.v(TAG, &quot;  Filter matched!  match=0x&quot; +</span><br><span class="line">                                Integer.toHexString(match));</span><br><span class="line">                        if (receivers == null) &#123;</span><br><span class="line">                            receivers = new ArrayList&lt;ReceiverRecord&gt;();</span><br><span class="line">                        &#125;</span><br><span class="line">                        receivers.add(receiver);</span><br><span class="line">                        receiver.broadcasting = true;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        if (debug) &#123;</span><br><span class="line">                            String reason;</span><br><span class="line">                            switch (match) &#123;</span><br><span class="line">                                case IntentFilter.NO_MATCH_ACTION: reason = &quot;action&quot;; break;</span><br><span class="line">                                case IntentFilter.NO_MATCH_CATEGORY: reason = &quot;category&quot;; break;</span><br><span class="line">                                case IntentFilter.NO_MATCH_DATA: reason = &quot;data&quot;; break;</span><br><span class="line">                                case IntentFilter.NO_MATCH_TYPE: reason = &quot;type&quot;; break;</span><br><span class="line">                                default: reason = &quot;unknown reason&quot;; break;</span><br><span class="line">                            &#125;</span><br><span class="line">                            Log.v(TAG, &quot;  Filter did not match: &quot; + reason);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (receivers != null) &#123;</span><br><span class="line">                    for (int i=0; i&lt;receivers.size(); i++) &#123;</span><br><span class="line">                        receivers.get(i).broadcasting = false;</span><br><span class="line">                    &#125;</span><br><span class="line">                    mPendingBroadcasts.add(new BroadcastRecord(intent, receivers));</span><br><span class="line">                    if (!mHandler.hasMessages(MSG_EXEC_PENDING_BROADCASTS)) &#123;</span><br><span class="line">                        mHandler.sendEmptyMessage(MSG_EXEC_PENDING_BROADCASTS);</span><br><span class="line">                    &#125;</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></intentfilter></intentfilter></p>
<p>简单分析一下：首先是根据传入intent的action，遍历所有该action的ReceiverRecord，同时通过IntentFilter的match方法匹配传入intent的各项数据是否符合ReceiverRecord中的IntentFilter，如果匹配，则保存该ReceiverRecord，同时将该ReceiverRecord的状态设置为发送中。最后将这些ReceiverRecord的状态通信置为为发送，将这些ReceiverRecord和intent保存成BroadcastRecord,添加到BroadcastRecord列表，再使用handler在主线程中发送广播。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private static class BroadcastRecord &#123;</span><br><span class="line">      final Intent intent;</span><br><span class="line">      final ArrayList&lt;ReceiverRecord&gt; receivers;</span><br><span class="line"></span><br><span class="line">      BroadcastRecord(Intent _intent, ArrayList&lt;ReceiverRecord&gt; _receivers) &#123;</span><br><span class="line">          intent = _intent;</span><br><span class="line">          receivers = _receivers;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>具体发送代码：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void executePendingBroadcasts() &#123;</span><br><span class="line">       while (true) &#123;</span><br><span class="line">           BroadcastRecord[] brs = null;</span><br><span class="line">           synchronized (mReceivers) &#123;</span><br><span class="line">               final int N = mPendingBroadcasts.size();</span><br><span class="line">               if (N &lt;= 0) &#123;</span><br><span class="line">                   return;</span><br><span class="line">               &#125;</span><br><span class="line">               brs = new BroadcastRecord[N];</span><br><span class="line">               mPendingBroadcasts.toArray(brs);</span><br><span class="line">               mPendingBroadcasts.clear();</span><br><span class="line">           &#125;</span><br><span class="line">           for (int i=0; i&lt;brs.length; i++) &#123;</span><br><span class="line">               BroadcastRecord br = brs[i];</span><br><span class="line">               for (int j=0; j&lt;br.receivers.size(); j++) &#123;</span><br><span class="line">                   br.receivers.get(j).receiver.onReceive(mAppContext, br.intent);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>将BroadcastRecord列表转成数组后，循环遍历每个intent 的ReceiverRecord，直接调用里面的BroadcastReceiver的onReceive方法，完成广播的发送。<br>最后再来看看注销广播：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void unregisterReceiver(BroadcastReceiver receiver) &#123;</span><br><span class="line">       synchronized (mReceivers) &#123;</span><br><span class="line">           ArrayList&lt;IntentFilter&gt; filters = mReceivers.remove(receiver);</span><br><span class="line">           if (filters == null) &#123;</span><br><span class="line">               return;</span><br><span class="line">           &#125;</span><br><span class="line">           for (int i=0; i&lt;filters.size(); i++) &#123;</span><br><span class="line">               IntentFilter filter = filters.get(i);</span><br><span class="line">               for (int j=0; j&lt;filter.countActions(); j++) &#123;</span><br><span class="line">                   String action = filter.getAction(j);</span><br><span class="line">                   ArrayList&lt;ReceiverRecord&gt; receivers = mActions.get(action);</span><br><span class="line">                   if (receivers != null) &#123;</span><br><span class="line">                       for (int k=0; k&lt;receivers.size(); k++) &#123;</span><br><span class="line">                           if (receivers.get(k).receiver == receiver) &#123;</span><br><span class="line">                               receivers.remove(k);</span><br><span class="line">                               k--;</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;</span><br><span class="line">                       if (receivers.size() &lt;= 0) &#123;</span><br><span class="line">                           mActions.remove(action);</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>注销广播无非也就是根据receive，将ReceiverRecord列表和actions列表中的数据移除。<br>这里我们看到了，避免外部广播的方式其实就是广播的发送不通过系统的进程间通信，而是直接在内部直接调用的方式，从而完成广播的传递。</p>
</div><div class="article-meta" style="max-width:800px"><div class="tags"><i class="icon icon-tag"></i><ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/源码阅读/">源码阅读</a><span class="tag-list-count">8</span></li></ul></div><div class="categories"><i class="icon icon-category"></i><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/源码阅读/">源码阅读</a><span class="category-list-count">6</span></li></ul></div></div><div class="article-comment" style="max-width:800px"><div class="ds-thread" id="ds-thread" data-thread-key="ck85r7luo007cfxo1dzd372lx" data-title="LocalBroadcastManager源码分析" data-url="https://earthwo.github.io/2016/11/21/LocalBroadcastManager源码分析/" site-name="ueibo"></div><script>var siteName = document.getElementById('ds-thread').getAttribute('site-name');
var duoshuoQuery = {short_name: siteName};
(function() {
  var ds = document.createElement('script');
  ds.type = 'text/javascript';ds.async = true;
  ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
  ds.charset = 'UTF-8';
  (document.getElementsByTagName('head')[0] 
  || document.getElementsByTagName('body')[0]).appendChild(ds);
})();</script></div><ul class="navication"><li class="home"><a href="/"><i class="icon icon-home"></i></a></li><li><a href="/2016/12/07/ThreadLocal解析/"><i class="icon icon-arror-left"></i></a></li><li><a href="/2016/11/07/Effective-java读书笔记(3)/"><i class="icon icon-arror-right"></i></a></li></ul><div class="page-footer"><div class="top"><ul class="social"><li><a href="https://github.com/earthWo" title="Github" target="_blank"><i class="icon icon-github"></i></a></li></ul></div><div class="bottom"><p class="copyright">© 2020 alonealice<br><small><a href="http://www.beian.miit.gov.cn" target="_blank">浙ICP备17033688号</a></small><small>, THEME BY <a href="https://github.com/BoizZ/hexo-theme-laughing" target="_blank">LAUGHING</a></small></p></div></div></div><script>var wrap = document.getElementById('wrap');
window.onload = function () {
  wrap.className += ' done';
}</script></body></html>